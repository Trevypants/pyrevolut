{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyRevolut: A Revolut Business API Wrapper","text":"<p><code>pyrevolut</code> is an un-official wrapper around the Revolut Business API.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyrevolut\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\n# Initialize the client\nclient.open()\n\n# List all accounts for the authenticated user\naccounts = client.Accounts.get_all_accounts()\n\n# Close the client\nclient.close()\n\n# You can also use the client as a context manager\nwith Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True\n) as client:\n    accounts = client.Accounts.get_all_accounts()\n</code></pre>"},{"location":"#advanced-usage","title":"Advanced Usage","text":"<p>It is possible to use the client library asynchronously by using the <code>AsyncClient</code> object.</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\n# Run without context manager\nasync def run():\n    await client.open() \n    accounts = await client.Accounts.get_all_accounts()\n    await client.close() \n    return accounts\n\n# Run with context manager\nasync def run_context_manager():\n    async with client:\n        accounts = await client.Accounts.get_all_accounts() \n    return accounts\n\n# List all accounts for the authenticated user\naccounts = asyncio.run(run())\naccounts_context_manager = asyncio.run(run_context_manager())\n\n</code></pre>"},{"location":"#authentication","title":"Authentication","text":"<p>In order to make use of the Revolut Business API, you will need to go through several steps to authenticate your application. The basic guide can be found here. We have provided a simple CLI tool to help you generate the necessary credentials. This tool follows the steps outlined in the guide.</p> <pre><code>\npyrevolut auth-manual\n\n</code></pre> <p>or equivalently</p> <pre><code>\npython -m pyrevolut auth-manual\n\n</code></pre> <p>Upon completion, you will have a <code>.json</code> file that you can use to authenticate your application.</p> <p>Alternatively, in the event that you already have all your credential information stored, you can simply create a <code>.json</code> file with the following structure:</p> <pre><code>{\n    \"certificate\": {\n        \"public\": \"public-certificate-base64-encoded\",\n        \"private\": \"private-key-base64-encoded\",\n        \"expiration_dt\": \"2500-01-01T00:00:00Z\"\n    },\n    \"client_assert_jwt\": {\n        \"jwt\": \"client-assertion-jwt\",\n        \"expiration_dt\": \"2500-01-01T00:00:00Z\"\n    },\n    \"tokens\": {\n        \"access_token\": \"access-token\",\n        \"refresh_token\": \"refresh-token\",\n        \"token_type\": \"bearer\",\n        \"access_token_expiration_dt\": \"2020-01-01T17:22:42.934699Z\",\n        \"refresh_token_expiration_dt\": \"2500-01-01T00:00:00Z\"\n    }\n}\n</code></pre>"},{"location":"#api-support-status","title":"API Support Status","text":"<p>The wrapper currently supports the following APIs:</p> <ul> <li>[x] Accounts</li> <li>[x] Retrieve all accounts</li> <li>[x] Retrieve an account</li> <li>[x] Retrieve account's full bank details</li> <li>[ ] Cards (Live only)</li> <li>[ ] Retrieve a list of cards</li> <li>[ ] Create a card</li> <li>[ ] Retrieve card details</li> <li>[ ] Update card details</li> <li>[ ] Terminate a card</li> <li>[ ] Freeze a card</li> <li>[ ] Unfreeze a card</li> <li>[ ] Retrieve sensitive card details</li> <li>[x] Counterparties</li> <li>[x] Retrieve a list of counterparties</li> <li>[x] Retrieve a counterparty</li> <li>[x] Delete a counterparty</li> <li>[x] Create a counterparty (Personal)</li> <li>[x] Create a counterparty (Business)</li> <li>[x] Validate an account name (CoP)</li> <li>[x] Foreign exchange</li> <li>[x] Get an exchange rate</li> <li>[x] Exchange money</li> <li>[ ] Payment drafts</li> <li>[x] Retrieve all payments drafts</li> <li>[ ] Create a payment draft</li> <li>[x] Retrieve a payment draft</li> <li>[ ] Delete a payment draft</li> <li>[x] Payout links</li> <li>[x] Retrieve a list of payout links</li> <li>[x] Retrieve a payout link</li> <li>[x] Create a payout link</li> <li>[x] Cancel a payout link</li> <li>[x] Simulations (Sandbox only)</li> <li>[x] Simulate a transfer state update</li> <li>[x] Simulate an account top-up</li> <li>[ ] Team members (Live only)</li> <li>[ ] Retrieve a list of team members</li> <li>[ ] Invite a new memebr to your business</li> <li>[ ] Retrieve team roles</li> <li>[x] Transactions</li> <li>[x] Retrieve a list of transactions</li> <li>[x] Retrieve a transaction</li> <li>[x] Transfers</li> <li>[x] Move money between your accounts</li> <li>[x] Create a transfer to another account</li> <li>[x] Get transfer reasons</li> <li>[x] Webhooks (v2)</li> <li>[x] Create a new webhook</li> <li>[x] Retrieve a list of webhooks</li> <li>[x] Retrieve a webhook</li> <li>[x] Update a webhook</li> <li>[x] Delete a webhook</li> <li>[x] Rotate a webhook signing secret</li> <li>[x] Retrieve a list of failed webhook events</li> <li>[x] Verify a webhook signature</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>In order to facilitate a streamlined development process, we have a few guidelines that we would like to follow. Please refer to the CONTRIBUTING.md  file for more information.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p> <p>Disclaimer: <code>pyrevolut</code> is an un-official API wrapper. It is in no way endorsed by or affiliated with Revolut or any associated organization. Make sure to read and understand the terms of service of the underlying API before using this package. The authors accept no responsiblity for any damage that might stem from use of this package.</p>"},{"location":"code_reference/api/common/","title":"Common API Resources","text":"<p>Here are the common resources used by the Revolut Business API.</p>"},{"location":"code_reference/api/common/#pyrevolut.api.common.ModelBaseAmount","title":"<code>ModelBaseAmount</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for amount</p> Source code in <code>pyrevolut/api/common/models/amount.py</code> <pre><code>class ModelBaseAmount(BaseModel):\n    \"\"\"Base model for amount\"\"\"\n\n    amount: Annotated[float, Field(description=\"The value.\")]\n    currency: Annotated[\n        Currency,\n        Field(description=\"The currency, provided as a 3-letter ISO 4217 code.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/common/#pyrevolut.api.common.BaseEndpointSync","title":"<code>BaseEndpointSync</code>","text":"<p>Base class for all endpoints.</p> Source code in <code>pyrevolut/api/common/endpoint.py</code> <pre><code>class BaseEndpointSync:\n    \"\"\"Base class for all endpoints.\"\"\"\n\n    def __init__(self, client: \"Client\"):\n        \"\"\"Create a new Base endpoint handler\n\n        Parameters\n        ----------\n        client : Client\n            The client to use for the endpoint\n        \"\"\"\n        self.client = client\n</code></pre>"},{"location":"code_reference/api/common/#pyrevolut.api.common.BaseEndpointSync.__init__","title":"<code>__init__(client)</code>","text":"<p>Create a new Base endpoint handler</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The client to use for the endpoint</p> required Source code in <code>pyrevolut/api/common/endpoint.py</code> <pre><code>def __init__(self, client: \"Client\"):\n    \"\"\"Create a new Base endpoint handler\n\n    Parameters\n    ----------\n    client : Client\n        The client to use for the endpoint\n    \"\"\"\n    self.client = client\n</code></pre>"},{"location":"code_reference/api/common/#pyrevolut.api.common.BaseEndpointAsync","title":"<code>BaseEndpointAsync</code>","text":"<p>Base  class for all async endpoints.</p> Source code in <code>pyrevolut/api/common/endpoint.py</code> <pre><code>class BaseEndpointAsync:\n    \"\"\"Base  class for all async endpoints.\"\"\"\n\n    def __init__(self, client: \"AsyncClient\"):\n        \"\"\"Create a new Base endpoint handler\n\n        Parameters\n        ----------\n        client : AsyncClient\n            The async client to use for the endpoint\n        \"\"\"\n        self.client = client\n</code></pre>"},{"location":"code_reference/api/common/#pyrevolut.api.common.BaseEndpointAsync.__init__","title":"<code>__init__(client)</code>","text":"<p>Create a new Base endpoint handler</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AsyncClient</code> <p>The async client to use for the endpoint</p> required Source code in <code>pyrevolut/api/common/endpoint.py</code> <pre><code>def __init__(self, client: \"AsyncClient\"):\n    \"\"\"Create a new Base endpoint handler\n\n    Parameters\n    ----------\n    client : AsyncClient\n        The async client to use for the endpoint\n    \"\"\"\n    self.client = client\n</code></pre>"},{"location":"code_reference/api/accounts/asynchronous/","title":"Accounts Asynchronous Endpoints","text":"<p>This <code>Accounts</code> endpoint provides asynchronous methods to interact with the accounts of the authenticated user.</p> <p>Example usage of the Accounts endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        accounts = await client.Accounts.get_all_accounts()\n        print(accounts)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/accounts/asynchronous/#pyrevolut.api.accounts.endpoint.EndpointAccountsAsync","title":"<code>EndpointAccountsAsync</code>","text":"<p>               Bases: <code>BaseEndpointAsync</code></p> <p>The async Accounts API Get the balances, full banking details, and other details of your business accounts.</p> Source code in <code>pyrevolut/api/accounts/endpoint/asynchronous.py</code> <pre><code>class EndpointAccountsAsync(BaseEndpointAsync):\n    \"\"\"The async Accounts API\n    Get the balances, full banking details, and other details of your business accounts.\n    \"\"\"\n\n    async def get_all_accounts(\n        self,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveAllAccounts.Response]:\n        \"\"\"\n        Get a list of all your accounts.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        list[dict] | list[RetrieveAllAccounts.Response]\n            The list of all your accounts\n        \"\"\"\n        endpoint = RetrieveAllAccounts\n        path = endpoint.ROUTE\n        params = endpoint.Params()\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def get_account(\n        self,\n        account_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveAnAccount.Response:\n        \"\"\"\n        Get the information about one of your accounts. Specify the account by its ID.\n\n        Parameters\n        ----------\n        account_id : UUID\n            The account ID.\n\n        Returns\n        -------\n        dict | RetrieveAnAccount.Response\n            The information about the account\n        \"\"\"\n        endpoint = RetrieveAnAccount\n        path = endpoint.ROUTE.format(account_id=account_id)\n        params = endpoint.Params()\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def get_full_bank_details(\n        self,\n        account_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveFullBankDetails.Response:\n        \"\"\"\n        Get all the bank details of one of your accounts. Specify the account by its ID.\n\n        Parameters\n        ----------\n        account_id : UUID\n            The account ID.\n\n        Returns\n        -------\n        dict | RetrieveFullBankDetails.Response\n            The bank details of the account\n        \"\"\"\n        endpoint = RetrieveFullBankDetails\n        path = endpoint.ROUTE.format(account_id=account_id)\n        params = endpoint.Params()\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/accounts/asynchronous/#pyrevolut.api.accounts.endpoint.EndpointAccountsAsync.get_account","title":"<code>get_account(account_id, **kwargs)</code>  <code>async</code>","text":"<p>Get the information about one of your accounts. Specify the account by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>UUID</code> <p>The account ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The information about the account</p> Source code in <code>pyrevolut/api/accounts/endpoint/asynchronous.py</code> <pre><code>async def get_account(\n    self,\n    account_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveAnAccount.Response:\n    \"\"\"\n    Get the information about one of your accounts. Specify the account by its ID.\n\n    Parameters\n    ----------\n    account_id : UUID\n        The account ID.\n\n    Returns\n    -------\n    dict | RetrieveAnAccount.Response\n        The information about the account\n    \"\"\"\n    endpoint = RetrieveAnAccount\n    path = endpoint.ROUTE.format(account_id=account_id)\n    params = endpoint.Params()\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/accounts/asynchronous/#pyrevolut.api.accounts.endpoint.EndpointAccountsAsync.get_all_accounts","title":"<code>get_all_accounts(**kwargs)</code>  <code>async</code>","text":"<p>Get a list of all your accounts.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all your accounts</p> Source code in <code>pyrevolut/api/accounts/endpoint/asynchronous.py</code> <pre><code>async def get_all_accounts(\n    self,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveAllAccounts.Response]:\n    \"\"\"\n    Get a list of all your accounts.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    list[dict] | list[RetrieveAllAccounts.Response]\n        The list of all your accounts\n    \"\"\"\n    endpoint = RetrieveAllAccounts\n    path = endpoint.ROUTE\n    params = endpoint.Params()\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/accounts/asynchronous/#pyrevolut.api.accounts.endpoint.EndpointAccountsAsync.get_full_bank_details","title":"<code>get_full_bank_details(account_id, **kwargs)</code>  <code>async</code>","text":"<p>Get all the bank details of one of your accounts. Specify the account by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>UUID</code> <p>The account ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The bank details of the account</p> Source code in <code>pyrevolut/api/accounts/endpoint/asynchronous.py</code> <pre><code>async def get_full_bank_details(\n    self,\n    account_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveFullBankDetails.Response:\n    \"\"\"\n    Get all the bank details of one of your accounts. Specify the account by its ID.\n\n    Parameters\n    ----------\n    account_id : UUID\n        The account ID.\n\n    Returns\n    -------\n    dict | RetrieveFullBankDetails.Response\n        The bank details of the account\n    \"\"\"\n    endpoint = RetrieveFullBankDetails\n    path = endpoint.ROUTE.format(account_id=account_id)\n    params = endpoint.Params()\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/","title":"Accounts Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Accounts</code> endpoint.</p>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.resources.ResourceAccount","title":"<code>ResourceAccount</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Account resource model.</p> Source code in <code>pyrevolut/api/accounts/resources/account.py</code> <pre><code>class ResourceAccount(BaseModel):\n    \"\"\"\n    Account resource model.\n    \"\"\"\n\n    id: Annotated[\n        UUID,\n        Field(description=\"The account ID.\"),\n    ]\n    name: Annotated[\n        str | None,\n        Field(description=\"The account name.\"),\n    ] = None\n    balance: Annotated[\n        float,\n        Field(description=\"The current balance on the account.\"),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(description=\"ISO 4217 currency code in upper case.\"),\n    ]\n    state: Annotated[\n        EnumAccountState,\n        Field(description=\"Indicates the state of the account.\"),\n    ]\n    public: Annotated[\n        bool,\n        Field(\n            description=\"Indicates whether the account is visible to other businesses on Revolut.\"\n        ),\n    ]\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the account was created in ISO 8601 format.\"\n        ),\n    ]\n    updated_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the account was last updated in ISO 8601 format.\"\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveAllAccounts","title":"<code>RetrieveAllAccounts</code>","text":"<p>Get a list of all your accounts.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_all_accounts.py</code> <pre><code>class RetrieveAllAccounts:\n    \"\"\"\n    Get a list of all your accounts.\n    \"\"\"\n\n    ROUTE = \"/1.0/accounts\"\n\n    class Params(BaseModel):\n        \"\"\"\n        Query parameters for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(ResourceAccount):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveAllAccounts.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_all_accounts.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    Query parameters for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveAllAccounts.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceAccount</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_all_accounts.py</code> <pre><code>class Response(ResourceAccount):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveAnAccount","title":"<code>RetrieveAnAccount</code>","text":"<p>Get the information about one of your accounts. Specify the account by its ID.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_an_account.py</code> <pre><code>class RetrieveAnAccount:\n    \"\"\"\n    Get the information about one of your accounts. Specify the account by its ID.\n    \"\"\"\n\n    ROUTE = \"/1.0/accounts/{account_id}\"\n\n    class Params(BaseModel):\n        \"\"\"\n        Query parameters for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(ResourceAccount):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveAnAccount.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_an_account.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    Query parameters for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveAnAccount.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceAccount</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_an_account.py</code> <pre><code>class Response(ResourceAccount):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveFullBankDetails","title":"<code>RetrieveFullBankDetails</code>","text":"<p>Get all the bank details of one of your accounts. Specify the account by its ID.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_full_bank_details.py</code> <pre><code>class RetrieveFullBankDetails:\n    \"\"\"\n    Get all the bank details of one of your accounts. Specify the account by its ID.\n    \"\"\"\n\n    ROUTE = \"/1.0/accounts/{account_id}/bank-details\"\n\n    class Params(BaseModel):\n        \"\"\"\n        Query parameters for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        class ModelBeneficiaryAddress(BaseModel):\n            \"\"\"The address of the beneficiary.\"\"\"\n\n            street_line1: Annotated[\n                str | None,\n                Field(description=\"Street line 1 information.\"),\n            ] = None\n            street_line2: Annotated[\n                str | None,\n                Field(description=\"Street line 2 information.\"),\n            ] = None\n            region: Annotated[\n                str | None,\n                Field(description=\"The name of the region.\"),\n            ] = None\n            city: Annotated[\n                str | None,\n                Field(description=\"The name of the city.\"),\n            ] = None\n            country: Annotated[\n                CountryAlpha2,\n                Field(\n                    description=\"The country of the counterparty as the 2-letter ISO 3166 code.\"\n                ),\n            ]\n            postcode: Annotated[\n                str,\n                Field(description=\"The postcode of the counterparty address.\"),\n            ]\n\n        class ModelEstimatedTime(BaseModel):\n            \"\"\"The estimated time of the inboud transfer of the funds,\n            i.e. when we expect the recipient to receive the transfer.\n            \"\"\"\n\n            unit: Annotated[\n                EnumTimeUnit,\n                Field(\n                    description=\"The estimated time unit of the inbound transfer of the funds.\"\n                ),\n            ]\n            min: Annotated[\n                int | None,\n                Field(description=\"The minimum time estimate.\", ge=0),\n            ] = None\n            max: Annotated[\n                int | None,\n                Field(description=\"The maximum time estimate.\", ge=0),\n            ] = None\n\n        iban: Annotated[\n            str | None,\n            Field(description=\"The IBAN number.\"),\n        ] = None\n        bic: Annotated[\n            str | None,\n            Field(description=\"The BIC number, also known as SWIFT code.\"),\n        ] = None\n        account_no: Annotated[\n            str | None,\n            Field(description=\"The account number.\"),\n        ] = None\n        sort_code: Annotated[\n            str | None,\n            Field(description=\"The sort code of the account.\"),\n        ] = None\n        routing_number: Annotated[\n            str | None,\n            Field(description=\"The routing number of the account.\"),\n        ] = None\n        beneficiary: Annotated[\n            str,\n            Field(description=\"The name of the counterparty.\"),\n        ]\n        beneficiary_address: Annotated[\n            ModelBeneficiaryAddress,\n            Field(description=\"The address of the counterparty.\"),\n        ]\n        bank_country: Annotated[\n            CountryAlpha2 | None,\n            Field(description=\"The country of the bank as the 2-letter ISO 3166 code.\"),\n        ] = None\n        pooled: Annotated[\n            bool | None,\n            Field(\n                description=\"Indicates whether the account address is pooled or unique.\"\n            ),\n        ] = None\n        unique_reference: Annotated[\n            str | None,\n            Field(description=\"The reference of the pooled account.\"),\n        ] = None\n        schemes: Annotated[\n            list[EnumPaymentScheme],\n            Field(\n                description=\"The schemes that are available for this currency account.\"\n            ),\n        ]\n        estimated_time: Annotated[\n            ModelEstimatedTime,\n            Field(\n                description=\"\"\"\n                The estimated time of the inboud transfer of the funds, \n                i.e. when we expect the recipient to receive the transfer.\n                \"\"\"\n            ),\n        ]\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveFullBankDetails.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_full_bank_details.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    Query parameters for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveFullBankDetails.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_full_bank_details.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    class ModelBeneficiaryAddress(BaseModel):\n        \"\"\"The address of the beneficiary.\"\"\"\n\n        street_line1: Annotated[\n            str | None,\n            Field(description=\"Street line 1 information.\"),\n        ] = None\n        street_line2: Annotated[\n            str | None,\n            Field(description=\"Street line 2 information.\"),\n        ] = None\n        region: Annotated[\n            str | None,\n            Field(description=\"The name of the region.\"),\n        ] = None\n        city: Annotated[\n            str | None,\n            Field(description=\"The name of the city.\"),\n        ] = None\n        country: Annotated[\n            CountryAlpha2,\n            Field(\n                description=\"The country of the counterparty as the 2-letter ISO 3166 code.\"\n            ),\n        ]\n        postcode: Annotated[\n            str,\n            Field(description=\"The postcode of the counterparty address.\"),\n        ]\n\n    class ModelEstimatedTime(BaseModel):\n        \"\"\"The estimated time of the inboud transfer of the funds,\n        i.e. when we expect the recipient to receive the transfer.\n        \"\"\"\n\n        unit: Annotated[\n            EnumTimeUnit,\n            Field(\n                description=\"The estimated time unit of the inbound transfer of the funds.\"\n            ),\n        ]\n        min: Annotated[\n            int | None,\n            Field(description=\"The minimum time estimate.\", ge=0),\n        ] = None\n        max: Annotated[\n            int | None,\n            Field(description=\"The maximum time estimate.\", ge=0),\n        ] = None\n\n    iban: Annotated[\n        str | None,\n        Field(description=\"The IBAN number.\"),\n    ] = None\n    bic: Annotated[\n        str | None,\n        Field(description=\"The BIC number, also known as SWIFT code.\"),\n    ] = None\n    account_no: Annotated[\n        str | None,\n        Field(description=\"The account number.\"),\n    ] = None\n    sort_code: Annotated[\n        str | None,\n        Field(description=\"The sort code of the account.\"),\n    ] = None\n    routing_number: Annotated[\n        str | None,\n        Field(description=\"The routing number of the account.\"),\n    ] = None\n    beneficiary: Annotated[\n        str,\n        Field(description=\"The name of the counterparty.\"),\n    ]\n    beneficiary_address: Annotated[\n        ModelBeneficiaryAddress,\n        Field(description=\"The address of the counterparty.\"),\n    ]\n    bank_country: Annotated[\n        CountryAlpha2 | None,\n        Field(description=\"The country of the bank as the 2-letter ISO 3166 code.\"),\n    ] = None\n    pooled: Annotated[\n        bool | None,\n        Field(\n            description=\"Indicates whether the account address is pooled or unique.\"\n        ),\n    ] = None\n    unique_reference: Annotated[\n        str | None,\n        Field(description=\"The reference of the pooled account.\"),\n    ] = None\n    schemes: Annotated[\n        list[EnumPaymentScheme],\n        Field(\n            description=\"The schemes that are available for this currency account.\"\n        ),\n    ]\n    estimated_time: Annotated[\n        ModelEstimatedTime,\n        Field(\n            description=\"\"\"\n            The estimated time of the inboud transfer of the funds, \n            i.e. when we expect the recipient to receive the transfer.\n            \"\"\"\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveFullBankDetails.Response.ModelBeneficiaryAddress","title":"<code>ModelBeneficiaryAddress</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The address of the beneficiary.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_full_bank_details.py</code> <pre><code>class ModelBeneficiaryAddress(BaseModel):\n    \"\"\"The address of the beneficiary.\"\"\"\n\n    street_line1: Annotated[\n        str | None,\n        Field(description=\"Street line 1 information.\"),\n    ] = None\n    street_line2: Annotated[\n        str | None,\n        Field(description=\"Street line 2 information.\"),\n    ] = None\n    region: Annotated[\n        str | None,\n        Field(description=\"The name of the region.\"),\n    ] = None\n    city: Annotated[\n        str | None,\n        Field(description=\"The name of the city.\"),\n    ] = None\n    country: Annotated[\n        CountryAlpha2,\n        Field(\n            description=\"The country of the counterparty as the 2-letter ISO 3166 code.\"\n        ),\n    ]\n    postcode: Annotated[\n        str,\n        Field(description=\"The postcode of the counterparty address.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/accounts/pydantic/#pyrevolut.api.accounts.get.RetrieveFullBankDetails.Response.ModelEstimatedTime","title":"<code>ModelEstimatedTime</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The estimated time of the inboud transfer of the funds, i.e. when we expect the recipient to receive the transfer.</p> Source code in <code>pyrevolut/api/accounts/get/retrieve_full_bank_details.py</code> <pre><code>class ModelEstimatedTime(BaseModel):\n    \"\"\"The estimated time of the inboud transfer of the funds,\n    i.e. when we expect the recipient to receive the transfer.\n    \"\"\"\n\n    unit: Annotated[\n        EnumTimeUnit,\n        Field(\n            description=\"The estimated time unit of the inbound transfer of the funds.\"\n        ),\n    ]\n    min: Annotated[\n        int | None,\n        Field(description=\"The minimum time estimate.\", ge=0),\n    ] = None\n    max: Annotated[\n        int | None,\n        Field(description=\"The maximum time estimate.\", ge=0),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/accounts/synchronous/","title":"Accounts Synchronous Endpoints","text":"<p>This <code>Accounts</code> endpoint provides methods to interact with the accounts of the authenticated user.</p> <p>Example usage of the Accounts endpoint object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    accounts = client.Accounts.get_all_accounts()\n    print(accounts)\n</code></pre>"},{"location":"code_reference/api/accounts/synchronous/#pyrevolut.api.accounts.endpoint.EndpointAccountsSync","title":"<code>EndpointAccountsSync</code>","text":"<p>               Bases: <code>BaseEndpointSync</code></p> <p>The Accounts API Get the balances, full banking details, and other details of your business accounts.</p> Source code in <code>pyrevolut/api/accounts/endpoint/synchronous.py</code> <pre><code>class EndpointAccountsSync(BaseEndpointSync):\n    \"\"\"The Accounts API\n    Get the balances, full banking details, and other details of your business accounts.\n    \"\"\"\n\n    def get_all_accounts(\n        self,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveAllAccounts.Response]:\n        \"\"\"\n        Get a list of all your accounts.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        list[dict] | list[RetrieveAllAccounts.Response]\n            The list of all your accounts\n        \"\"\"\n        endpoint = RetrieveAllAccounts\n        path = endpoint.ROUTE\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_account(\n        self,\n        account_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveAnAccount.Response:\n        \"\"\"\n        Get the information about one of your accounts. Specify the account by its ID.\n\n        Parameters\n        ----------\n        account_id : UUID\n            The account ID.\n\n        Returns\n        -------\n        dict | RetrieveAnAccount.Response\n            The information about the account\n        \"\"\"\n        endpoint = RetrieveAnAccount\n        path = endpoint.ROUTE.format(account_id=account_id)\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_full_bank_details(\n        self,\n        account_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveFullBankDetails.Response:\n        \"\"\"\n        Get all the bank details of one of your accounts. Specify the account by its ID.\n\n        Parameters\n        ----------\n        account_id : UUID\n            The account ID.\n\n        Returns\n        -------\n        dict | RetrieveFullBankDetails.Response\n            The bank details of the account\n        \"\"\"\n        endpoint = RetrieveFullBankDetails\n        path = endpoint.ROUTE.format(account_id=account_id)\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/accounts/synchronous/#pyrevolut.api.accounts.endpoint.EndpointAccountsSync.get_account","title":"<code>get_account(account_id, **kwargs)</code>","text":"<p>Get the information about one of your accounts. Specify the account by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>UUID</code> <p>The account ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The information about the account</p> Source code in <code>pyrevolut/api/accounts/endpoint/synchronous.py</code> <pre><code>def get_account(\n    self,\n    account_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveAnAccount.Response:\n    \"\"\"\n    Get the information about one of your accounts. Specify the account by its ID.\n\n    Parameters\n    ----------\n    account_id : UUID\n        The account ID.\n\n    Returns\n    -------\n    dict | RetrieveAnAccount.Response\n        The information about the account\n    \"\"\"\n    endpoint = RetrieveAnAccount\n    path = endpoint.ROUTE.format(account_id=account_id)\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/accounts/synchronous/#pyrevolut.api.accounts.endpoint.EndpointAccountsSync.get_all_accounts","title":"<code>get_all_accounts(**kwargs)</code>","text":"<p>Get a list of all your accounts.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all your accounts</p> Source code in <code>pyrevolut/api/accounts/endpoint/synchronous.py</code> <pre><code>def get_all_accounts(\n    self,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveAllAccounts.Response]:\n    \"\"\"\n    Get a list of all your accounts.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    list[dict] | list[RetrieveAllAccounts.Response]\n        The list of all your accounts\n    \"\"\"\n    endpoint = RetrieveAllAccounts\n    path = endpoint.ROUTE\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/accounts/synchronous/#pyrevolut.api.accounts.endpoint.EndpointAccountsSync.get_full_bank_details","title":"<code>get_full_bank_details(account_id, **kwargs)</code>","text":"<p>Get all the bank details of one of your accounts. Specify the account by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>UUID</code> <p>The account ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The bank details of the account</p> Source code in <code>pyrevolut/api/accounts/endpoint/synchronous.py</code> <pre><code>def get_full_bank_details(\n    self,\n    account_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveFullBankDetails.Response:\n    \"\"\"\n    Get all the bank details of one of your accounts. Specify the account by its ID.\n\n    Parameters\n    ----------\n    account_id : UUID\n        The account ID.\n\n    Returns\n    -------\n    dict | RetrieveFullBankDetails.Response\n        The bank details of the account\n    \"\"\"\n    endpoint = RetrieveFullBankDetails\n    path = endpoint.ROUTE.format(account_id=account_id)\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/","title":"Cards Asynchronous Endpoints","text":"<p>This <code>Cards</code> endpoint provides asynchronous methods to interact with the cards of the authenticated user.</p> <p>Example usage of the Cards endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        cards = await client.Cards.get_all_cards()\n        print(cards)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync","title":"<code>EndpointCardsAsync</code>","text":"<p>               Bases: <code>BaseEndpointAsync</code></p> <p>The async Cards API Manage cards for the business team members, freeze, unfreeze, terminate and update card settings, such as transaction limits.</p> <p>This feature is available in the UK, US and the EEA. This feature is not available in Sandbox.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>class EndpointCardsAsync(BaseEndpointAsync):\n    \"\"\"The async Cards API\n    Manage cards for the business team members, freeze, unfreeze,\n    terminate and update card settings, such as transaction limits.\n\n    This feature is available in the UK, US and the EEA.\n    This feature is not available in Sandbox.\n    \"\"\"\n\n    async def get_all_cards(\n        self,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        limit: int | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfCards.Response]:\n        \"\"\"\n        Get the list of all cards in your organisation.\n        The results are paginated and sorted by the created_at date in reverse chronological order.\n\n        Parameters\n        ----------\n        created_before : datetime | DateTime | str | int | float | None\n            Retrieves cards with created_at &lt; created_before.\n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n        limit : int | None\n            The maximum number of cards returned per page.\n            To get to the next page, make a new request and use the\n            created_at date of the last card returned in the previous\n            response as the value for created_before.\n\n            If not provided, the default value is 100.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfCards.Response]\n            The list of all cards in your organisation.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = RetrieveListOfCards\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            created_before=created_before,\n            limit=limit,\n        )\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def get_card(\n        self,\n        card_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveCardDetails.Response:\n        \"\"\"\n        Get the details of a specific card, based on its ID.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n\n        Returns\n        -------\n        dict | RetrieveCardDetails.Response\n            The details of the card.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = RetrieveCardDetails\n        path = endpoint.ROUTE.format(card_id=card_id)\n        params = endpoint.Params()\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def get_card_sensitive_details(\n        self,\n        card_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveSensitiveCardDetails.Response:\n        \"\"\"\n        Get sensitive details of a specific card, based on its ID.\n        Requires the READ_SENSITIVE_CARD_DATA token scope.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n\n        Returns\n        -------\n        dict | RetrieveSensitiveCardDetails.Response\n            The sensitive details of the card.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = RetrieveSensitiveCardDetails\n        path = endpoint.ROUTE.format(card_id=card_id)\n        params = endpoint.Params()\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def create_card(\n        self,\n        request_id: str,\n        holder_id: UUID,\n        label: str | None = None,\n        accounts: list[UUID] | None = None,\n        categories: list[EnumMerchantCategory] | None = None,\n        single_limit_amount: float | None = None,\n        single_limit_currency: str | None = None,\n        day_limit_amount: float | None = None,\n        day_limit_currency: str | None = None,\n        week_limit_amount: float | None = None,\n        week_limit_currency: str | None = None,\n        month_limit_amount: float | None = None,\n        month_limit_currency: str | None = None,\n        quarter_limit_amount: float | None = None,\n        quarter_limit_currency: str | None = None,\n        year_limit_amount: float | None = None,\n        year_limit_currency: str | None = None,\n        all_time_limit_amount: float | None = None,\n        all_time_limit_currency: str | None = None,\n        **kwargs,\n    ) -&gt; dict | CreateCard.Response:\n        \"\"\"\n        Create a new card for an existing member of your Revolut Business team.\n\n        When using the API, you can create only virtual cards.\n        To create a physical card, use the Revolut Business app.\n\n        Parameters\n        ----------\n        request_id : str\n            A unique ID of the request that you provide.\n            This ID is used to prevent duplicate card creation requests in case\n            of a lost connection or client error, so make sure you use the same\n            request_id for requests related to the same card.\n            The deduplication is limited to 24 hours counting from the first request\n            using a given ID.\n        holder_id : UUID\n            The ID of the team member who will be the holder of the card.\n        label : str | None\n            The label for the issued card, displayed in the UI to help distinguish between cards.\n            If not specified, no label will be added.\n        accounts : list[UUID] | None\n            The list of accounts to link to the card. If not specified, all accounts will be linked.\n        categories : list[EnumMerchantCategory] | None\n            The list of merchant categories to link to the card. If not specified, all categories will be linked.\n        single_limit_amount : float | None\n            The maximum amount for a single transaction.\n        single_limit_currency : str | None\n            The currency of the single transaction limit.\n        day_limit_amount : float | None\n            The maximum amount for transactions in a day.\n        day_limit_currency : str | None\n            The currency of the day limit.\n        week_limit_amount : float | None\n            The maximum amount for transactions in a week.\n        week_limit_currency : str | None\n            The currency of the week limit.\n        month_limit_amount : float | None\n            The maximum amount for transactions in a month.\n        month_limit_currency : str | None\n            The currency of the month limit.\n        quarter_limit_amount : float | None\n            The maximum amount for transactions in a quarter.\n        quarter_limit_currency : str | None\n            The currency of the quarter limit.\n        year_limit_amount : float | None\n            The maximum amount for transactions in a year.\n        year_limit_currency : str | None\n            The currency of the year limit.\n        all_time_limit_amount : float | None\n            The maximum amount for transactions in the card's lifetime.\n        all_time_limit_currency : str | None\n            The currency of the all-time limit.\n\n        Returns\n        -------\n        dict | CreateCard.Response\n            The details of the created card.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = CreateCard\n        path = endpoint.ROUTE\n\n        # Create the SpendingLimits model (if applicable)\n        spending_limits = endpoint.Body.ModelSpendingLimits(\n            single=(\n                endpoint.Body.ModelSpendingLimits.ModelSingle(\n                    amount=single_limit_amount,\n                    currency=single_limit_currency,\n                )\n                if single_limit_amount is not None and single_limit_currency is not None\n                else None\n            ),\n            day=(\n                endpoint.Body.ModelSpendingLimits.ModelDay(\n                    amount=day_limit_amount,\n                    currency=day_limit_currency,\n                )\n                if day_limit_amount is not None and day_limit_currency is not None\n                else None\n            ),\n            week=(\n                endpoint.Body.ModelSpendingLimits.ModelWeek(\n                    amount=week_limit_amount,\n                    currency=week_limit_currency,\n                )\n                if week_limit_amount is not None and week_limit_currency is not None\n                else None\n            ),\n            month=(\n                endpoint.Body.ModelSpendingLimits.ModelMonth(\n                    amount=month_limit_amount,\n                    currency=month_limit_currency,\n                )\n                if month_limit_amount is not None and month_limit_currency is not None\n                else None\n            ),\n            quarter=(\n                endpoint.Body.ModelSpendingLimits.ModelQuarter(\n                    amount=quarter_limit_amount,\n                    currency=quarter_limit_currency,\n                )\n                if quarter_limit_amount is not None\n                and quarter_limit_currency is not None\n                else None\n            ),\n            year=(\n                endpoint.Body.ModelSpendingLimits.ModelYear(\n                    amount=year_limit_amount,\n                    currency=year_limit_currency,\n                )\n                if year_limit_amount is not None and year_limit_currency is not None\n                else None\n            ),\n            all_time=(\n                endpoint.Body.ModelSpendingLimits.ModelAllTime(\n                    amount=all_time_limit_amount,\n                    currency=all_time_limit_currency,\n                )\n                if all_time_limit_amount is not None\n                and all_time_limit_currency is not None\n                else None\n            ),\n        )\n        if not any(\n            [\n                spending_limits.single is not None,\n                spending_limits.day is not None,\n                spending_limits.week is not None,\n                spending_limits.month is not None,\n                spending_limits.quarter is not None,\n                spending_limits.year is not None,\n                spending_limits.all_time is not None,\n            ]\n        ):\n            spending_limits = None\n\n        body = endpoint.Body(\n            request_id=request_id,\n            virtual=True,\n            holder_id=holder_id,\n            label=label,\n            accounts=accounts,\n            categories=categories,\n            spending_limits=spending_limits,\n        )\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    async def freeze_card(\n        self,\n        card_id: UUID,\n        **kwargs,\n    ) -&gt; dict | FreezeCard.Response:\n        \"\"\"\n        Freeze a card to make it temporarily unavailable for spending.\n        You can only freeze a card that is in the state active.\n\n        A successful freeze changes the card's state to frozen,\n        and no content is returned in the response.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n\n        Returns\n        -------\n        dict | FreezeCard.Response\n            An empty dictionary.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = FreezeCard\n        path = endpoint.ROUTE.format(card_id=card_id)\n        body = endpoint.Body()\n\n        await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    async def unfreeze_card(\n        self,\n        card_id: UUID,\n        **kwargs,\n    ) -&gt; dict | UnfreezeCard.Response:\n        \"\"\"\n        Unfreeze a card to make it available for spending again.\n        You can only unfreeze a card that is in the state frozen.\n\n        A successful unfreeze changes the card's state to active,\n        and no content is returned in the response.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n\n        Returns\n        -------\n        dict | UnfreezeCard.Response\n            An empty dictionary.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = UnfreezeCard\n        path = endpoint.ROUTE.format(card_id=card_id)\n        body = endpoint.Body()\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    async def update_card(\n        self,\n        card_id: UUID,\n        label: str | None = None,\n        categories: list[EnumMerchantCategory] | Literal[\"null\"] | None = None,\n        single_limit_amount: float | Literal[\"null\"] | None = None,\n        single_limit_currency: str | Literal[\"null\"] | None = None,\n        day_limit_amount: float | Literal[\"null\"] | None = None,\n        day_limit_currency: str | Literal[\"null\"] | None = None,\n        week_limit_amount: float | Literal[\"null\"] | None = None,\n        week_limit_currency: str | Literal[\"null\"] | None = None,\n        month_limit_amount: float | Literal[\"null\"] | None = None,\n        month_limit_currency: str | Literal[\"null\"] | None = None,\n        quarter_limit_amount: float | Literal[\"null\"] | None = None,\n        quarter_limit_currency: str | Literal[\"null\"] | None = None,\n        year_limit_amount: float | Literal[\"null\"] | None = None,\n        year_limit_currency: str | Literal[\"null\"] | None = None,\n        all_time_limit_amount: float | Literal[\"null\"] | None = None,\n        all_time_limit_currency: str | Literal[\"null\"] | None = None,\n        **kwargs,\n    ) -&gt; dict | UpdateCardDetails.Response:\n        \"\"\"\n        Update details of a specific card, based on its ID.\n        Updating a spending limit does not reset the spending counter.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n        label : str | None\n            The label of the card.\n        categories : list[EnumMerchantCategory] | Literal[\"null\"] | None\n            The list of merchant categories to link to the card.\n            If set to 'null', all categories will be linked.\n        single_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for a single transaction.\n            If set to 'null', the limit will be removed.\n        single_limit_currency : str | Literal[\"null\"] | None\n            The currency of the single transaction limit.\n            If set to 'null', the limit will be removed.\n        day_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in a day.\n            If set to 'null', the limit will be removed.\n        day_limit_currency : str | Literal[\"null\"] | None\n            The currency of the day limit.\n            If set to 'null', the limit will be removed.\n        week_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in a week.\n            If set to 'null', the limit will be removed.\n        week_limit_currency : str | Literal[\"null\"] | None\n            The currency of the week limit.\n            If set to 'null', the limit will be removed.\n        month_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in a month.\n            If set to 'null', the limit will be removed.\n        month_limit_currency : str | Literal[\"null\"] | None\n            The currency of the month limit.\n            If set to 'null', the limit will be removed.\n        quarter_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in a quarter.\n            If set to 'null', the limit will be removed.\n        quarter_limit_currency : str | Literal[\"null\"] | None\n            The currency of the quarter limit.\n            If set to 'null', the limit will be removed.\n        year_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in a year.\n            If set to 'null', the limit will be removed.\n        year_limit_currency : str | Literal[\"null\"] | None\n            The currency of the year limit.\n            If set to 'null', the limit will be removed.\n        all_time_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in the card's lifetime.\n            If set to 'null', the limit will be removed.\n        all_time_limit_currency : str | Literal[\"null\"] | None\n            The currency of the all-time limit.\n            If set to 'null', the limit will be removed.\n\n        Returns\n        -------\n        dict | UpdateCardDetails.Response\n            The updated details of the card.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = UpdateCardDetails\n        path = endpoint.ROUTE.format(card_id=card_id)\n\n        # Create the SpendingLimits model (if applicable)\n        spending_limits = endpoint.Body.ModelSpendingLimits(\n            single=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelSingle,\n                amount=single_limit_amount,\n                currency=single_limit_currency,\n            ),\n            day=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelDay,\n                amount=day_limit_amount,\n                currency=day_limit_currency,\n            ),\n            week=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelWeek,\n                amount=week_limit_amount,\n                currency=week_limit_currency,\n            ),\n            month=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelMonth,\n                amount=month_limit_amount,\n                currency=month_limit_currency,\n            ),\n            quarter=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelQuarter,\n                amount=quarter_limit_amount,\n                currency=quarter_limit_currency,\n            ),\n            year=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelYear,\n                amount=year_limit_amount,\n                currency=year_limit_currency,\n            ),\n            all_time=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelAllTime,\n                amount=all_time_limit_amount,\n                currency=all_time_limit_currency,\n            ),\n        )\n        if not any(\n            [\n                spending_limits.single is not None,\n                spending_limits.day is not None,\n                spending_limits.week is not None,\n                spending_limits.month is not None,\n                spending_limits.quarter is not None,\n                spending_limits.year is not None,\n                spending_limits.all_time is not None,\n            ]\n        ):\n            spending_limits = None\n        elif all(\n            [\n                spending_limits.single == \"null\",\n                spending_limits.day == \"null\",\n                spending_limits.week == \"null\",\n                spending_limits.month == \"null\",\n                spending_limits.quarter == \"null\",\n                spending_limits.year == \"null\",\n                spending_limits.all_time == \"null\",\n            ]\n        ):\n            spending_limits = \"null\"\n\n        body = endpoint.Body(\n            label=label,\n            categories=categories,\n            spending_limits=spending_limits,\n        )\n\n        return await self.client.patch(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    async def delete_card(\n        self,\n        card_id: UUID,\n        **kwargs,\n    ) -&gt; dict | TerminateCard.Response:\n        \"\"\"\n        Terminate a specific card, based on its ID.\n\n        Once the card is terminated, it will not be returned by the API.\n\n        A successful response does not get any content in return.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n\n        Returns\n        -------\n        dict | TerminateCard.Response\n            An empty dictionary.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = TerminateCard\n        path = endpoint.ROUTE.format(card_id=card_id)\n        params = endpoint.Params()\n\n        return await self.client.delete(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def __process_limit_model(\n        self,\n        model: Type[BaseModel],\n        amount: float | None,\n        currency: str | None,\n    ):\n        \"\"\"\n        Process the limit model.\n        \"\"\"\n        if amount is not None and currency is not None:\n            return model(\n                amount=amount,\n                currency=currency,\n            )\n        elif amount == \"null\" and currency == \"null\":\n            return \"null\"\n        return None\n\n    def __check_sandbox(self):\n        \"\"\"\n        Check if the sandbox is enabled.\n\n        Raises\n        ------\n        PyRevolutInvalidEnvironment\n            If the sandbox is enabled.\n        \"\"\"\n        if self.client.sandbox:\n            raise PyRevolutInvalidEnvironment(\n                \"This feature is not available in Sandbox.\"\n            )\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync.__check_sandbox","title":"<code>__check_sandbox()</code>","text":"<p>Check if the sandbox is enabled.</p> <p>Raises:</p> Type Description <code>PyRevolutInvalidEnvironment</code> <p>If the sandbox is enabled.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>def __check_sandbox(self):\n    \"\"\"\n    Check if the sandbox is enabled.\n\n    Raises\n    ------\n    PyRevolutInvalidEnvironment\n        If the sandbox is enabled.\n    \"\"\"\n    if self.client.sandbox:\n        raise PyRevolutInvalidEnvironment(\n            \"This feature is not available in Sandbox.\"\n        )\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync.__process_limit_model","title":"<code>__process_limit_model(model, amount, currency)</code>","text":"<p>Process the limit model.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>def __process_limit_model(\n    self,\n    model: Type[BaseModel],\n    amount: float | None,\n    currency: str | None,\n):\n    \"\"\"\n    Process the limit model.\n    \"\"\"\n    if amount is not None and currency is not None:\n        return model(\n            amount=amount,\n            currency=currency,\n        )\n    elif amount == \"null\" and currency == \"null\":\n        return \"null\"\n    return None\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync.create_card","title":"<code>create_card(request_id, holder_id, label=None, accounts=None, categories=None, single_limit_amount=None, single_limit_currency=None, day_limit_amount=None, day_limit_currency=None, week_limit_amount=None, week_limit_currency=None, month_limit_amount=None, month_limit_currency=None, quarter_limit_amount=None, quarter_limit_currency=None, year_limit_amount=None, year_limit_currency=None, all_time_limit_amount=None, all_time_limit_currency=None, **kwargs)</code>  <code>async</code>","text":"<p>Create a new card for an existing member of your Revolut Business team.</p> <p>When using the API, you can create only virtual cards. To create a physical card, use the Revolut Business app.</p> <p>Parameters:</p> Name Type Description Default <code>request_id</code> <code>str</code> <p>A unique ID of the request that you provide. This ID is used to prevent duplicate card creation requests in case of a lost connection or client error, so make sure you use the same request_id for requests related to the same card. The deduplication is limited to 24 hours counting from the first request using a given ID.</p> required <code>holder_id</code> <code>UUID</code> <p>The ID of the team member who will be the holder of the card.</p> required <code>label</code> <code>str | None</code> <p>The label for the issued card, displayed in the UI to help distinguish between cards. If not specified, no label will be added.</p> <code>None</code> <code>accounts</code> <code>list[UUID] | None</code> <p>The list of accounts to link to the card. If not specified, all accounts will be linked.</p> <code>None</code> <code>categories</code> <code>list[EnumMerchantCategory] | None</code> <p>The list of merchant categories to link to the card. If not specified, all categories will be linked.</p> <code>None</code> <code>single_limit_amount</code> <code>float | None</code> <p>The maximum amount for a single transaction.</p> <code>None</code> <code>single_limit_currency</code> <code>str | None</code> <p>The currency of the single transaction limit.</p> <code>None</code> <code>day_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in a day.</p> <code>None</code> <code>day_limit_currency</code> <code>str | None</code> <p>The currency of the day limit.</p> <code>None</code> <code>week_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in a week.</p> <code>None</code> <code>week_limit_currency</code> <code>str | None</code> <p>The currency of the week limit.</p> <code>None</code> <code>month_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in a month.</p> <code>None</code> <code>month_limit_currency</code> <code>str | None</code> <p>The currency of the month limit.</p> <code>None</code> <code>quarter_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in a quarter.</p> <code>None</code> <code>quarter_limit_currency</code> <code>str | None</code> <p>The currency of the quarter limit.</p> <code>None</code> <code>year_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in a year.</p> <code>None</code> <code>year_limit_currency</code> <code>str | None</code> <p>The currency of the year limit.</p> <code>None</code> <code>all_time_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in the card's lifetime.</p> <code>None</code> <code>all_time_limit_currency</code> <code>str | None</code> <p>The currency of the all-time limit.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The details of the created card.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>async def create_card(\n    self,\n    request_id: str,\n    holder_id: UUID,\n    label: str | None = None,\n    accounts: list[UUID] | None = None,\n    categories: list[EnumMerchantCategory] | None = None,\n    single_limit_amount: float | None = None,\n    single_limit_currency: str | None = None,\n    day_limit_amount: float | None = None,\n    day_limit_currency: str | None = None,\n    week_limit_amount: float | None = None,\n    week_limit_currency: str | None = None,\n    month_limit_amount: float | None = None,\n    month_limit_currency: str | None = None,\n    quarter_limit_amount: float | None = None,\n    quarter_limit_currency: str | None = None,\n    year_limit_amount: float | None = None,\n    year_limit_currency: str | None = None,\n    all_time_limit_amount: float | None = None,\n    all_time_limit_currency: str | None = None,\n    **kwargs,\n) -&gt; dict | CreateCard.Response:\n    \"\"\"\n    Create a new card for an existing member of your Revolut Business team.\n\n    When using the API, you can create only virtual cards.\n    To create a physical card, use the Revolut Business app.\n\n    Parameters\n    ----------\n    request_id : str\n        A unique ID of the request that you provide.\n        This ID is used to prevent duplicate card creation requests in case\n        of a lost connection or client error, so make sure you use the same\n        request_id for requests related to the same card.\n        The deduplication is limited to 24 hours counting from the first request\n        using a given ID.\n    holder_id : UUID\n        The ID of the team member who will be the holder of the card.\n    label : str | None\n        The label for the issued card, displayed in the UI to help distinguish between cards.\n        If not specified, no label will be added.\n    accounts : list[UUID] | None\n        The list of accounts to link to the card. If not specified, all accounts will be linked.\n    categories : list[EnumMerchantCategory] | None\n        The list of merchant categories to link to the card. If not specified, all categories will be linked.\n    single_limit_amount : float | None\n        The maximum amount for a single transaction.\n    single_limit_currency : str | None\n        The currency of the single transaction limit.\n    day_limit_amount : float | None\n        The maximum amount for transactions in a day.\n    day_limit_currency : str | None\n        The currency of the day limit.\n    week_limit_amount : float | None\n        The maximum amount for transactions in a week.\n    week_limit_currency : str | None\n        The currency of the week limit.\n    month_limit_amount : float | None\n        The maximum amount for transactions in a month.\n    month_limit_currency : str | None\n        The currency of the month limit.\n    quarter_limit_amount : float | None\n        The maximum amount for transactions in a quarter.\n    quarter_limit_currency : str | None\n        The currency of the quarter limit.\n    year_limit_amount : float | None\n        The maximum amount for transactions in a year.\n    year_limit_currency : str | None\n        The currency of the year limit.\n    all_time_limit_amount : float | None\n        The maximum amount for transactions in the card's lifetime.\n    all_time_limit_currency : str | None\n        The currency of the all-time limit.\n\n    Returns\n    -------\n    dict | CreateCard.Response\n        The details of the created card.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = CreateCard\n    path = endpoint.ROUTE\n\n    # Create the SpendingLimits model (if applicable)\n    spending_limits = endpoint.Body.ModelSpendingLimits(\n        single=(\n            endpoint.Body.ModelSpendingLimits.ModelSingle(\n                amount=single_limit_amount,\n                currency=single_limit_currency,\n            )\n            if single_limit_amount is not None and single_limit_currency is not None\n            else None\n        ),\n        day=(\n            endpoint.Body.ModelSpendingLimits.ModelDay(\n                amount=day_limit_amount,\n                currency=day_limit_currency,\n            )\n            if day_limit_amount is not None and day_limit_currency is not None\n            else None\n        ),\n        week=(\n            endpoint.Body.ModelSpendingLimits.ModelWeek(\n                amount=week_limit_amount,\n                currency=week_limit_currency,\n            )\n            if week_limit_amount is not None and week_limit_currency is not None\n            else None\n        ),\n        month=(\n            endpoint.Body.ModelSpendingLimits.ModelMonth(\n                amount=month_limit_amount,\n                currency=month_limit_currency,\n            )\n            if month_limit_amount is not None and month_limit_currency is not None\n            else None\n        ),\n        quarter=(\n            endpoint.Body.ModelSpendingLimits.ModelQuarter(\n                amount=quarter_limit_amount,\n                currency=quarter_limit_currency,\n            )\n            if quarter_limit_amount is not None\n            and quarter_limit_currency is not None\n            else None\n        ),\n        year=(\n            endpoint.Body.ModelSpendingLimits.ModelYear(\n                amount=year_limit_amount,\n                currency=year_limit_currency,\n            )\n            if year_limit_amount is not None and year_limit_currency is not None\n            else None\n        ),\n        all_time=(\n            endpoint.Body.ModelSpendingLimits.ModelAllTime(\n                amount=all_time_limit_amount,\n                currency=all_time_limit_currency,\n            )\n            if all_time_limit_amount is not None\n            and all_time_limit_currency is not None\n            else None\n        ),\n    )\n    if not any(\n        [\n            spending_limits.single is not None,\n            spending_limits.day is not None,\n            spending_limits.week is not None,\n            spending_limits.month is not None,\n            spending_limits.quarter is not None,\n            spending_limits.year is not None,\n            spending_limits.all_time is not None,\n        ]\n    ):\n        spending_limits = None\n\n    body = endpoint.Body(\n        request_id=request_id,\n        virtual=True,\n        holder_id=holder_id,\n        label=label,\n        accounts=accounts,\n        categories=categories,\n        spending_limits=spending_limits,\n    )\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync.delete_card","title":"<code>delete_card(card_id, **kwargs)</code>  <code>async</code>","text":"<p>Terminate a specific card, based on its ID.</p> <p>Once the card is terminated, it will not be returned by the API.</p> <p>A successful response does not get any content in return.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dictionary.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>async def delete_card(\n    self,\n    card_id: UUID,\n    **kwargs,\n) -&gt; dict | TerminateCard.Response:\n    \"\"\"\n    Terminate a specific card, based on its ID.\n\n    Once the card is terminated, it will not be returned by the API.\n\n    A successful response does not get any content in return.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n\n    Returns\n    -------\n    dict | TerminateCard.Response\n        An empty dictionary.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = TerminateCard\n    path = endpoint.ROUTE.format(card_id=card_id)\n    params = endpoint.Params()\n\n    return await self.client.delete(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync.freeze_card","title":"<code>freeze_card(card_id, **kwargs)</code>  <code>async</code>","text":"<p>Freeze a card to make it temporarily unavailable for spending. You can only freeze a card that is in the state active.</p> <p>A successful freeze changes the card's state to frozen, and no content is returned in the response.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dictionary.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>async def freeze_card(\n    self,\n    card_id: UUID,\n    **kwargs,\n) -&gt; dict | FreezeCard.Response:\n    \"\"\"\n    Freeze a card to make it temporarily unavailable for spending.\n    You can only freeze a card that is in the state active.\n\n    A successful freeze changes the card's state to frozen,\n    and no content is returned in the response.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n\n    Returns\n    -------\n    dict | FreezeCard.Response\n        An empty dictionary.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = FreezeCard\n    path = endpoint.ROUTE.format(card_id=card_id)\n    body = endpoint.Body()\n\n    await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync.get_all_cards","title":"<code>get_all_cards(created_before=None, limit=None, **kwargs)</code>  <code>async</code>","text":"<p>Get the list of all cards in your organisation. The results are paginated and sorted by the created_at date in reverse chronological order.</p> <p>Parameters:</p> Name Type Description Default <code>created_before</code> <code>datetime | DateTime | str | int | float | None</code> <p>Retrieves cards with created_at &lt; created_before. The default value is the current date and time at which you are calling the endpoint. Provided in ISO 8601 format.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>The maximum number of cards returned per page. To get to the next page, make a new request and use the created_at date of the last card returned in the previous response as the value for created_before.</p> <p>If not provided, the default value is 100.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all cards in your organisation.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>async def get_all_cards(\n    self,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    limit: int | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfCards.Response]:\n    \"\"\"\n    Get the list of all cards in your organisation.\n    The results are paginated and sorted by the created_at date in reverse chronological order.\n\n    Parameters\n    ----------\n    created_before : datetime | DateTime | str | int | float | None\n        Retrieves cards with created_at &lt; created_before.\n        The default value is the current date and time at which you are calling the endpoint.\n        Provided in ISO 8601 format.\n    limit : int | None\n        The maximum number of cards returned per page.\n        To get to the next page, make a new request and use the\n        created_at date of the last card returned in the previous\n        response as the value for created_before.\n\n        If not provided, the default value is 100.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfCards.Response]\n        The list of all cards in your organisation.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = RetrieveListOfCards\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        created_before=created_before,\n        limit=limit,\n    )\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync.get_card","title":"<code>get_card(card_id, **kwargs)</code>  <code>async</code>","text":"<p>Get the details of a specific card, based on its ID.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The details of the card.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>async def get_card(\n    self,\n    card_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveCardDetails.Response:\n    \"\"\"\n    Get the details of a specific card, based on its ID.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n\n    Returns\n    -------\n    dict | RetrieveCardDetails.Response\n        The details of the card.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = RetrieveCardDetails\n    path = endpoint.ROUTE.format(card_id=card_id)\n    params = endpoint.Params()\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync.get_card_sensitive_details","title":"<code>get_card_sensitive_details(card_id, **kwargs)</code>  <code>async</code>","text":"<p>Get sensitive details of a specific card, based on its ID. Requires the READ_SENSITIVE_CARD_DATA token scope.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The sensitive details of the card.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>async def get_card_sensitive_details(\n    self,\n    card_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveSensitiveCardDetails.Response:\n    \"\"\"\n    Get sensitive details of a specific card, based on its ID.\n    Requires the READ_SENSITIVE_CARD_DATA token scope.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n\n    Returns\n    -------\n    dict | RetrieveSensitiveCardDetails.Response\n        The sensitive details of the card.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = RetrieveSensitiveCardDetails\n    path = endpoint.ROUTE.format(card_id=card_id)\n    params = endpoint.Params()\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync.unfreeze_card","title":"<code>unfreeze_card(card_id, **kwargs)</code>  <code>async</code>","text":"<p>Unfreeze a card to make it available for spending again. You can only unfreeze a card that is in the state frozen.</p> <p>A successful unfreeze changes the card's state to active, and no content is returned in the response.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dictionary.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>async def unfreeze_card(\n    self,\n    card_id: UUID,\n    **kwargs,\n) -&gt; dict | UnfreezeCard.Response:\n    \"\"\"\n    Unfreeze a card to make it available for spending again.\n    You can only unfreeze a card that is in the state frozen.\n\n    A successful unfreeze changes the card's state to active,\n    and no content is returned in the response.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n\n    Returns\n    -------\n    dict | UnfreezeCard.Response\n        An empty dictionary.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = UnfreezeCard\n    path = endpoint.ROUTE.format(card_id=card_id)\n    body = endpoint.Body()\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/asynchronous/#pyrevolut.api.cards.endpoint.EndpointCardsAsync.update_card","title":"<code>update_card(card_id, label=None, categories=None, single_limit_amount=None, single_limit_currency=None, day_limit_amount=None, day_limit_currency=None, week_limit_amount=None, week_limit_currency=None, month_limit_amount=None, month_limit_currency=None, quarter_limit_amount=None, quarter_limit_currency=None, year_limit_amount=None, year_limit_currency=None, all_time_limit_amount=None, all_time_limit_currency=None, **kwargs)</code>  <code>async</code>","text":"<p>Update details of a specific card, based on its ID. Updating a spending limit does not reset the spending counter.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <code>label</code> <code>str | None</code> <p>The label of the card.</p> <code>None</code> <code>categories</code> <code>list[EnumMerchantCategory] | Literal['null'] | None</code> <p>The list of merchant categories to link to the card. If set to 'null', all categories will be linked.</p> <code>None</code> <code>single_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for a single transaction. If set to 'null', the limit will be removed.</p> <code>None</code> <code>single_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the single transaction limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>day_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in a day. If set to 'null', the limit will be removed.</p> <code>None</code> <code>day_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the day limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>week_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in a week. If set to 'null', the limit will be removed.</p> <code>None</code> <code>week_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the week limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>month_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in a month. If set to 'null', the limit will be removed.</p> <code>None</code> <code>month_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the month limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>quarter_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in a quarter. If set to 'null', the limit will be removed.</p> <code>None</code> <code>quarter_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the quarter limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>year_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in a year. If set to 'null', the limit will be removed.</p> <code>None</code> <code>year_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the year limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>all_time_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in the card's lifetime. If set to 'null', the limit will be removed.</p> <code>None</code> <code>all_time_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the all-time limit. If set to 'null', the limit will be removed.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The updated details of the card.</p> Source code in <code>pyrevolut/api/cards/endpoint/asynchronous.py</code> <pre><code>async def update_card(\n    self,\n    card_id: UUID,\n    label: str | None = None,\n    categories: list[EnumMerchantCategory] | Literal[\"null\"] | None = None,\n    single_limit_amount: float | Literal[\"null\"] | None = None,\n    single_limit_currency: str | Literal[\"null\"] | None = None,\n    day_limit_amount: float | Literal[\"null\"] | None = None,\n    day_limit_currency: str | Literal[\"null\"] | None = None,\n    week_limit_amount: float | Literal[\"null\"] | None = None,\n    week_limit_currency: str | Literal[\"null\"] | None = None,\n    month_limit_amount: float | Literal[\"null\"] | None = None,\n    month_limit_currency: str | Literal[\"null\"] | None = None,\n    quarter_limit_amount: float | Literal[\"null\"] | None = None,\n    quarter_limit_currency: str | Literal[\"null\"] | None = None,\n    year_limit_amount: float | Literal[\"null\"] | None = None,\n    year_limit_currency: str | Literal[\"null\"] | None = None,\n    all_time_limit_amount: float | Literal[\"null\"] | None = None,\n    all_time_limit_currency: str | Literal[\"null\"] | None = None,\n    **kwargs,\n) -&gt; dict | UpdateCardDetails.Response:\n    \"\"\"\n    Update details of a specific card, based on its ID.\n    Updating a spending limit does not reset the spending counter.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n    label : str | None\n        The label of the card.\n    categories : list[EnumMerchantCategory] | Literal[\"null\"] | None\n        The list of merchant categories to link to the card.\n        If set to 'null', all categories will be linked.\n    single_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for a single transaction.\n        If set to 'null', the limit will be removed.\n    single_limit_currency : str | Literal[\"null\"] | None\n        The currency of the single transaction limit.\n        If set to 'null', the limit will be removed.\n    day_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in a day.\n        If set to 'null', the limit will be removed.\n    day_limit_currency : str | Literal[\"null\"] | None\n        The currency of the day limit.\n        If set to 'null', the limit will be removed.\n    week_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in a week.\n        If set to 'null', the limit will be removed.\n    week_limit_currency : str | Literal[\"null\"] | None\n        The currency of the week limit.\n        If set to 'null', the limit will be removed.\n    month_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in a month.\n        If set to 'null', the limit will be removed.\n    month_limit_currency : str | Literal[\"null\"] | None\n        The currency of the month limit.\n        If set to 'null', the limit will be removed.\n    quarter_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in a quarter.\n        If set to 'null', the limit will be removed.\n    quarter_limit_currency : str | Literal[\"null\"] | None\n        The currency of the quarter limit.\n        If set to 'null', the limit will be removed.\n    year_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in a year.\n        If set to 'null', the limit will be removed.\n    year_limit_currency : str | Literal[\"null\"] | None\n        The currency of the year limit.\n        If set to 'null', the limit will be removed.\n    all_time_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in the card's lifetime.\n        If set to 'null', the limit will be removed.\n    all_time_limit_currency : str | Literal[\"null\"] | None\n        The currency of the all-time limit.\n        If set to 'null', the limit will be removed.\n\n    Returns\n    -------\n    dict | UpdateCardDetails.Response\n        The updated details of the card.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = UpdateCardDetails\n    path = endpoint.ROUTE.format(card_id=card_id)\n\n    # Create the SpendingLimits model (if applicable)\n    spending_limits = endpoint.Body.ModelSpendingLimits(\n        single=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelSingle,\n            amount=single_limit_amount,\n            currency=single_limit_currency,\n        ),\n        day=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelDay,\n            amount=day_limit_amount,\n            currency=day_limit_currency,\n        ),\n        week=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelWeek,\n            amount=week_limit_amount,\n            currency=week_limit_currency,\n        ),\n        month=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelMonth,\n            amount=month_limit_amount,\n            currency=month_limit_currency,\n        ),\n        quarter=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelQuarter,\n            amount=quarter_limit_amount,\n            currency=quarter_limit_currency,\n        ),\n        year=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelYear,\n            amount=year_limit_amount,\n            currency=year_limit_currency,\n        ),\n        all_time=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelAllTime,\n            amount=all_time_limit_amount,\n            currency=all_time_limit_currency,\n        ),\n    )\n    if not any(\n        [\n            spending_limits.single is not None,\n            spending_limits.day is not None,\n            spending_limits.week is not None,\n            spending_limits.month is not None,\n            spending_limits.quarter is not None,\n            spending_limits.year is not None,\n            spending_limits.all_time is not None,\n        ]\n    ):\n        spending_limits = None\n    elif all(\n        [\n            spending_limits.single == \"null\",\n            spending_limits.day == \"null\",\n            spending_limits.week == \"null\",\n            spending_limits.month == \"null\",\n            spending_limits.quarter == \"null\",\n            spending_limits.year == \"null\",\n            spending_limits.all_time == \"null\",\n        ]\n    ):\n        spending_limits = \"null\"\n\n    body = endpoint.Body(\n        label=label,\n        categories=categories,\n        spending_limits=spending_limits,\n    )\n\n    return await self.client.patch(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/","title":"Cards Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Cards</code> endpoint.</p>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.resources.ResourceCard","title":"<code>ResourceCard</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Card resource model</p> Source code in <code>pyrevolut/api/cards/resources/card.py</code> <pre><code>class ResourceCard(BaseModel):\n    \"\"\"\n    Card resource model\n    \"\"\"\n\n    class ModelSpendingLimits(BaseModel):\n        \"\"\"All spending limits set for the card.\"\"\"\n\n        class ModelSingle(ModelBaseAmount):\n            \"\"\"The limit for a single transaction.\"\"\"\n\n            pass\n\n        class ModelDay(ModelBaseAmount):\n            \"\"\"The daily limit for transactions.\"\"\"\n\n            pass\n\n        class ModelWeek(ModelBaseAmount):\n            \"\"\"The weekly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelMonth(ModelBaseAmount):\n            \"\"\"The monthly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelQuarter(ModelBaseAmount):\n            \"\"\"The quarterly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelYear(ModelBaseAmount):\n            \"\"\"The yearly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelAllTime(ModelBaseAmount):\n            \"\"\"The all-time limit for transactions.\"\"\"\n\n            pass\n\n        single: Annotated[\n            ModelSingle | None,\n            Field(description=\"The limit for a single transaction.\"),\n        ]\n        day: Annotated[\n            ModelDay | None,\n            Field(description=\"The daily limit for transactions.\"),\n        ]\n        week: Annotated[\n            ModelWeek | None,\n            Field(description=\"The weekly limit for transactions.\"),\n        ]\n        month: Annotated[\n            ModelMonth | None,\n            Field(description=\"The monthly limit for transactions.\"),\n        ]\n        quarter: Annotated[\n            ModelQuarter | None,\n            Field(description=\"The quarterly limit for transactions.\"),\n        ]\n        year: Annotated[\n            ModelYear | None,\n            Field(description=\"The yearly limit for transactions.\"),\n        ]\n        all_time: Annotated[\n            ModelAllTime | None,\n            Field(description=\"The all-time limit for transactions.\"),\n        ]\n\n    id: Annotated[\n        UUID,\n        Field(description=\"The ID of the card.\"),\n    ]\n    last_digits: Annotated[\n        str,\n        Field(description=\"The last 4 digits of the card's PAN.\"),\n    ]\n    expiry: Annotated[\n        Date,\n        Field(description=\"The card expiration date.\"),\n    ]\n    state: Annotated[\n        EnumCardState,\n        Field(description=\"The state that the card is in.\"),\n    ]\n    label: Annotated[\n        str | None,\n        Field(description=\"The label of the card.\"),\n    ]\n    virtual: Annotated[\n        bool,\n        Field(\n            description=\"Specifies whether the card is virtual (true) or physical (false).\"\n        ),\n    ]\n    accounts: Annotated[\n        list[UUID],\n        Field(description=\"The list of linked accounts.\"),\n    ]\n    categories: Annotated[\n        list[EnumMerchantCategory] | None,\n        Field(\n            description=\"\"\"\n            The list of merchant categories that are available for card spending. \n            If not specified, all categories will be allowed.  \n            \"\"\"\n        ),\n    ]\n    spending_limits: Annotated[\n        ModelSpendingLimits | None,\n        Field(description=\"All spending limits set for the card.\"),\n    ]\n    holder_id: Annotated[\n        UUID | None,\n        Field(\n            description=\"\"\"\n            The ID of the team member who is the holder of the card. \n            If the card belongs to the business, this will be empty.\n            \"\"\"\n        ),\n    ]\n    created_at: Annotated[\n        DateTime,\n        Field(description=\"The date and time the card was created in ISO 8601 format.\"),\n    ]\n    updated_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the card was last updated in ISO 8601 format.\"\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.resources.ResourceCard.ModelSpendingLimits","title":"<code>ModelSpendingLimits</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>All spending limits set for the card.</p> Source code in <code>pyrevolut/api/cards/resources/card.py</code> <pre><code>class ModelSpendingLimits(BaseModel):\n    \"\"\"All spending limits set for the card.\"\"\"\n\n    class ModelSingle(ModelBaseAmount):\n        \"\"\"The limit for a single transaction.\"\"\"\n\n        pass\n\n    class ModelDay(ModelBaseAmount):\n        \"\"\"The daily limit for transactions.\"\"\"\n\n        pass\n\n    class ModelWeek(ModelBaseAmount):\n        \"\"\"The weekly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelMonth(ModelBaseAmount):\n        \"\"\"The monthly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelQuarter(ModelBaseAmount):\n        \"\"\"The quarterly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelYear(ModelBaseAmount):\n        \"\"\"The yearly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelAllTime(ModelBaseAmount):\n        \"\"\"The all-time limit for transactions.\"\"\"\n\n        pass\n\n    single: Annotated[\n        ModelSingle | None,\n        Field(description=\"The limit for a single transaction.\"),\n    ]\n    day: Annotated[\n        ModelDay | None,\n        Field(description=\"The daily limit for transactions.\"),\n    ]\n    week: Annotated[\n        ModelWeek | None,\n        Field(description=\"The weekly limit for transactions.\"),\n    ]\n    month: Annotated[\n        ModelMonth | None,\n        Field(description=\"The monthly limit for transactions.\"),\n    ]\n    quarter: Annotated[\n        ModelQuarter | None,\n        Field(description=\"The quarterly limit for transactions.\"),\n    ]\n    year: Annotated[\n        ModelYear | None,\n        Field(description=\"The yearly limit for transactions.\"),\n    ]\n    all_time: Annotated[\n        ModelAllTime | None,\n        Field(description=\"The all-time limit for transactions.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.resources.ResourceCard.ModelSpendingLimits.ModelAllTime","title":"<code>ModelAllTime</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The all-time limit for transactions.</p> Source code in <code>pyrevolut/api/cards/resources/card.py</code> <pre><code>class ModelAllTime(ModelBaseAmount):\n    \"\"\"The all-time limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.resources.ResourceCard.ModelSpendingLimits.ModelDay","title":"<code>ModelDay</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The daily limit for transactions.</p> Source code in <code>pyrevolut/api/cards/resources/card.py</code> <pre><code>class ModelDay(ModelBaseAmount):\n    \"\"\"The daily limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.resources.ResourceCard.ModelSpendingLimits.ModelMonth","title":"<code>ModelMonth</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The monthly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/resources/card.py</code> <pre><code>class ModelMonth(ModelBaseAmount):\n    \"\"\"The monthly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.resources.ResourceCard.ModelSpendingLimits.ModelQuarter","title":"<code>ModelQuarter</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The quarterly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/resources/card.py</code> <pre><code>class ModelQuarter(ModelBaseAmount):\n    \"\"\"The quarterly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.resources.ResourceCard.ModelSpendingLimits.ModelSingle","title":"<code>ModelSingle</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The limit for a single transaction.</p> Source code in <code>pyrevolut/api/cards/resources/card.py</code> <pre><code>class ModelSingle(ModelBaseAmount):\n    \"\"\"The limit for a single transaction.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.resources.ResourceCard.ModelSpendingLimits.ModelWeek","title":"<code>ModelWeek</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The weekly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/resources/card.py</code> <pre><code>class ModelWeek(ModelBaseAmount):\n    \"\"\"The weekly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.resources.ResourceCard.ModelSpendingLimits.ModelYear","title":"<code>ModelYear</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The yearly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/resources/card.py</code> <pre><code>class ModelYear(ModelBaseAmount):\n    \"\"\"The yearly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.get.RetrieveListOfCards","title":"<code>RetrieveListOfCards</code>","text":"<p>Get the list of all cards in your organisation. The results are paginated and sorted by the created_at date in reverse chronological order.</p> Source code in <code>pyrevolut/api/cards/get/retrieve_list_of_cards.py</code> <pre><code>class RetrieveListOfCards:\n    \"\"\"\n    Get the list of all cards in your organisation.\n    The results are paginated and sorted by the created_at date in reverse chronological order.\n    \"\"\"\n\n    ROUTE = \"/1.0/cards\"\n\n    class Params(BaseModel):\n        \"\"\"\n        Query parameters for the endpoint.\n        \"\"\"\n\n        created_before: Annotated[\n            DateTime | None,\n            Field(\n                description=\"\"\"\n                Retrieves cards with created_at &lt; created_before. \n                The default value is the current date and time at which you are calling the endpoint.\n                Provided in ISO 8601 format.\n                \"\"\"\n            ),\n        ] = None\n        limit: Annotated[\n            int | None,\n            Field(\n                description=\"\"\"\n                The maximum number of cards returned per page.\n                To get to the next page, make a new request and use the \n                created_at date of the last card returned in the previous \n                response as the value for created_before.              \n\n                If not provided, the default value is 100.  \n                \"\"\",\n                ge=1,\n                le=100,\n            ),\n        ] = None\n\n    class Response(ResourceCard):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.get.RetrieveListOfCards.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/cards/get/retrieve_list_of_cards.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    Query parameters for the endpoint.\n    \"\"\"\n\n    created_before: Annotated[\n        DateTime | None,\n        Field(\n            description=\"\"\"\n            Retrieves cards with created_at &lt; created_before. \n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n            \"\"\"\n        ),\n    ] = None\n    limit: Annotated[\n        int | None,\n        Field(\n            description=\"\"\"\n            The maximum number of cards returned per page.\n            To get to the next page, make a new request and use the \n            created_at date of the last card returned in the previous \n            response as the value for created_before.              \n\n            If not provided, the default value is 100.  \n            \"\"\",\n            ge=1,\n            le=100,\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.get.RetrieveListOfCards.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceCard</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/cards/get/retrieve_list_of_cards.py</code> <pre><code>class Response(ResourceCard):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.get.RetrieveCardDetails","title":"<code>RetrieveCardDetails</code>","text":"<p>Get the details of a specific card, based on its ID.</p> Source code in <code>pyrevolut/api/cards/get/retrieve_card_details.py</code> <pre><code>class RetrieveCardDetails:\n    \"\"\"\n    Get the details of a specific card, based on its ID.\n    \"\"\"\n\n    ROUTE = \"/1.0/cards/{card_id}\"\n\n    class Params(BaseModel):\n        \"\"\"\n        Query parameters for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(ResourceCard):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.get.RetrieveCardDetails.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/cards/get/retrieve_card_details.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    Query parameters for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.get.RetrieveCardDetails.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceCard</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/cards/get/retrieve_card_details.py</code> <pre><code>class Response(ResourceCard):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.get.RetrieveSensitiveCardDetails","title":"<code>RetrieveSensitiveCardDetails</code>","text":"<p>Get sensitive details of a specific card, based on its ID. Requires the READ_SENSITIVE_CARD_DATA token scope.</p> Source code in <code>pyrevolut/api/cards/get/retrieve_sensitive_card_details.py</code> <pre><code>class RetrieveSensitiveCardDetails:\n    \"\"\"\n    Get sensitive details of a specific card, based on its ID.\n    Requires the READ_SENSITIVE_CARD_DATA token scope.\n    \"\"\"\n\n    ROUTE = \"/1.0/cards/{card_id}/sensitive-details\"\n\n    class Params(BaseModel):\n        \"\"\"\n        Query parameters for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pan: Annotated[\n            str, Field(description=\"The PAN (Primary Account Number) of the card.\")\n        ]\n        cvv: Annotated[\n            str, Field(description=\"The CVV (Card Verification Value) of the card.\")\n        ]\n        expiry: Annotated[Date, Field(description=\"The card expiration date.\")]\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.get.RetrieveSensitiveCardDetails.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/cards/get/retrieve_sensitive_card_details.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    Query parameters for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.get.RetrieveSensitiveCardDetails.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/cards/get/retrieve_sensitive_card_details.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pan: Annotated[\n        str, Field(description=\"The PAN (Primary Account Number) of the card.\")\n    ]\n    cvv: Annotated[\n        str, Field(description=\"The CVV (Card Verification Value) of the card.\")\n    ]\n    expiry: Annotated[Date, Field(description=\"The card expiration date.\")]\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard","title":"<code>CreateCard</code>","text":"<p>Create a new card for an existing member of your Revolut Business team.</p> <p>When using the API, you can create only virtual cards. To create a physical card, use the Revolut Business app.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class CreateCard:\n    \"\"\"\n    Create a new card for an existing member of your Revolut Business team.\n\n    When using the API, you can create only virtual cards.\n    To create a physical card, use the Revolut Business app.\n    \"\"\"\n\n    ROUTE = \"/1.0/cards\"\n\n    class Body(BaseModel):\n        \"\"\"\n        Body model for the endpoint.\n        \"\"\"\n\n        class ModelSpendingLimits(BaseModel):\n            \"\"\"All spending limits set for the card.\"\"\"\n\n            class ModelSingle(ModelBaseAmount):\n                \"\"\"The limit for a single transaction.\"\"\"\n\n                pass\n\n            class ModelDay(ModelBaseAmount):\n                \"\"\"The daily limit for transactions.\"\"\"\n\n                pass\n\n            class ModelWeek(ModelBaseAmount):\n                \"\"\"The weekly limit for transactions.\"\"\"\n\n                pass\n\n            class ModelMonth(ModelBaseAmount):\n                \"\"\"The monthly limit for transactions.\"\"\"\n\n                pass\n\n            class ModelQuarter(ModelBaseAmount):\n                \"\"\"The quarterly limit for transactions.\"\"\"\n\n                pass\n\n            class ModelYear(ModelBaseAmount):\n                \"\"\"The yearly limit for transactions.\"\"\"\n\n                pass\n\n            class ModelAllTime(ModelBaseAmount):\n                \"\"\"The all-time limit for transactions.\"\"\"\n\n                pass\n\n            single: Annotated[\n                ModelSingle | None,\n                Field(description=\"The limit for a single transaction.\"),\n            ]\n            day: Annotated[\n                ModelDay | None,\n                Field(description=\"The daily limit for transactions.\"),\n            ]\n            week: Annotated[\n                ModelWeek | None,\n                Field(description=\"The weekly limit for transactions.\"),\n            ]\n            month: Annotated[\n                ModelMonth | None,\n                Field(description=\"The monthly limit for transactions.\"),\n            ]\n            quarter: Annotated[\n                ModelQuarter | None,\n                Field(description=\"The quarterly limit for transactions.\"),\n            ]\n            year: Annotated[\n                ModelYear | None,\n                Field(description=\"The yearly limit for transactions.\"),\n            ]\n            all_time: Annotated[\n                ModelAllTime | None,\n                Field(description=\"The all-time limit for transactions.\"),\n            ]\n\n        request_id: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                A unique ID of the request that you provide.\n                This ID is used to prevent duplicate card creation requests in case \n                of a lost connection or client error, so make sure you use the same \n                request_id for requests related to the same card.\n                The deduplication is limited to 24 hours counting from the first request \n                using a given ID. \n                \"\"\",\n                max_length=40,\n            ),\n        ]\n        virtual: Annotated[\n            bool,\n            Field(\n                description=\"\"\"\n                Specifies the type of the card. Must be set to true, as with the API, you can create only virtual cards.\n                \"\"\",\n            ),\n        ] = True\n        holder_id: Annotated[\n            UUID,\n            Field(\n                description=\"\"\"\n                The ID of the team member who will be the holder of the card.\n                \"\"\"\n            ),\n        ]\n        label: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The label for the issued card, displayed in the UI to help distinguish between cards. \n                If not specified, no label will be added.\n                \"\"\",\n                max_length=30,\n            ),\n        ] = None\n        accounts: Annotated[\n            list[UUID] | None,\n            Field(\n                description=\"\"\"\n                The list of accounts to link to the card. If not specified, all accounts will be linked.\n                \"\"\",\n            ),\n        ] = None\n        categories: Annotated[\n            list[EnumMerchantCategory] | None,\n            Field(\n                description=\"\"\"\n                The list of merchant categories to be available for card spending. \n                If not specified, all categories will be allowed.\n                \"\"\",\n            ),\n        ] = None\n        spending_limits: Annotated[\n            ModelSpendingLimits | None,\n            Field(\n                description=\"\"\"\n                All spending limits set for the card.\n                You can have at most 1 periodic (day/week/month/quarter/all-time) and \n                1 non-periodic (single transaction) limit at a time. \n                If you try to specify 2 periodic limits at a time, it will result in an error.\n\n                Spending limit currency must match the default business currency. \n                The default currency was assigned to your business during onboarding.\n                \"\"\",\n            ),\n        ] = None\n\n        @model_validator(mode=\"after\")\n        def check_inputs(self) -&gt; \"CreateCard.Body\":\n            \"\"\"Check the inputs.\"\"\"\n            if not self.virtual:\n                raise ValueError(\"You can only create virtual cards via the API.\")\n            if self.spending_limits is not None:\n                if (\n                    sum(\n                        [\n                            self.spending_limits.day is not None,\n                            self.spending_limits.week is not None,\n                            self.spending_limits.month is not None,\n                            self.spending_limits.quarter is not None,\n                            self.spending_limits.year is not None,\n                            self.spending_limits.all_time is not None,\n                        ]\n                    )\n                    &gt; 1\n                ):\n                    raise ValueError(\n                        \"You can have at most 1 periodic (day/week/month/quarter/all-time) limit at a time.\"\n                    )\n            return self\n\n    class Response(ResourceCard):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Body model for the endpoint.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    Body model for the endpoint.\n    \"\"\"\n\n    class ModelSpendingLimits(BaseModel):\n        \"\"\"All spending limits set for the card.\"\"\"\n\n        class ModelSingle(ModelBaseAmount):\n            \"\"\"The limit for a single transaction.\"\"\"\n\n            pass\n\n        class ModelDay(ModelBaseAmount):\n            \"\"\"The daily limit for transactions.\"\"\"\n\n            pass\n\n        class ModelWeek(ModelBaseAmount):\n            \"\"\"The weekly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelMonth(ModelBaseAmount):\n            \"\"\"The monthly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelQuarter(ModelBaseAmount):\n            \"\"\"The quarterly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelYear(ModelBaseAmount):\n            \"\"\"The yearly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelAllTime(ModelBaseAmount):\n            \"\"\"The all-time limit for transactions.\"\"\"\n\n            pass\n\n        single: Annotated[\n            ModelSingle | None,\n            Field(description=\"The limit for a single transaction.\"),\n        ]\n        day: Annotated[\n            ModelDay | None,\n            Field(description=\"The daily limit for transactions.\"),\n        ]\n        week: Annotated[\n            ModelWeek | None,\n            Field(description=\"The weekly limit for transactions.\"),\n        ]\n        month: Annotated[\n            ModelMonth | None,\n            Field(description=\"The monthly limit for transactions.\"),\n        ]\n        quarter: Annotated[\n            ModelQuarter | None,\n            Field(description=\"The quarterly limit for transactions.\"),\n        ]\n        year: Annotated[\n            ModelYear | None,\n            Field(description=\"The yearly limit for transactions.\"),\n        ]\n        all_time: Annotated[\n            ModelAllTime | None,\n            Field(description=\"The all-time limit for transactions.\"),\n        ]\n\n    request_id: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            A unique ID of the request that you provide.\n            This ID is used to prevent duplicate card creation requests in case \n            of a lost connection or client error, so make sure you use the same \n            request_id for requests related to the same card.\n            The deduplication is limited to 24 hours counting from the first request \n            using a given ID. \n            \"\"\",\n            max_length=40,\n        ),\n    ]\n    virtual: Annotated[\n        bool,\n        Field(\n            description=\"\"\"\n            Specifies the type of the card. Must be set to true, as with the API, you can create only virtual cards.\n            \"\"\",\n        ),\n    ] = True\n    holder_id: Annotated[\n        UUID,\n        Field(\n            description=\"\"\"\n            The ID of the team member who will be the holder of the card.\n            \"\"\"\n        ),\n    ]\n    label: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The label for the issued card, displayed in the UI to help distinguish between cards. \n            If not specified, no label will be added.\n            \"\"\",\n            max_length=30,\n        ),\n    ] = None\n    accounts: Annotated[\n        list[UUID] | None,\n        Field(\n            description=\"\"\"\n            The list of accounts to link to the card. If not specified, all accounts will be linked.\n            \"\"\",\n        ),\n    ] = None\n    categories: Annotated[\n        list[EnumMerchantCategory] | None,\n        Field(\n            description=\"\"\"\n            The list of merchant categories to be available for card spending. \n            If not specified, all categories will be allowed.\n            \"\"\",\n        ),\n    ] = None\n    spending_limits: Annotated[\n        ModelSpendingLimits | None,\n        Field(\n            description=\"\"\"\n            All spending limits set for the card.\n            You can have at most 1 periodic (day/week/month/quarter/all-time) and \n            1 non-periodic (single transaction) limit at a time. \n            If you try to specify 2 periodic limits at a time, it will result in an error.\n\n            Spending limit currency must match the default business currency. \n            The default currency was assigned to your business during onboarding.\n            \"\"\",\n        ),\n    ] = None\n\n    @model_validator(mode=\"after\")\n    def check_inputs(self) -&gt; \"CreateCard.Body\":\n        \"\"\"Check the inputs.\"\"\"\n        if not self.virtual:\n            raise ValueError(\"You can only create virtual cards via the API.\")\n        if self.spending_limits is not None:\n            if (\n                sum(\n                    [\n                        self.spending_limits.day is not None,\n                        self.spending_limits.week is not None,\n                        self.spending_limits.month is not None,\n                        self.spending_limits.quarter is not None,\n                        self.spending_limits.year is not None,\n                        self.spending_limits.all_time is not None,\n                    ]\n                )\n                &gt; 1\n            ):\n                raise ValueError(\n                    \"You can have at most 1 periodic (day/week/month/quarter/all-time) limit at a time.\"\n                )\n        return self\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Body.ModelSpendingLimits","title":"<code>ModelSpendingLimits</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>All spending limits set for the card.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class ModelSpendingLimits(BaseModel):\n    \"\"\"All spending limits set for the card.\"\"\"\n\n    class ModelSingle(ModelBaseAmount):\n        \"\"\"The limit for a single transaction.\"\"\"\n\n        pass\n\n    class ModelDay(ModelBaseAmount):\n        \"\"\"The daily limit for transactions.\"\"\"\n\n        pass\n\n    class ModelWeek(ModelBaseAmount):\n        \"\"\"The weekly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelMonth(ModelBaseAmount):\n        \"\"\"The monthly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelQuarter(ModelBaseAmount):\n        \"\"\"The quarterly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelYear(ModelBaseAmount):\n        \"\"\"The yearly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelAllTime(ModelBaseAmount):\n        \"\"\"The all-time limit for transactions.\"\"\"\n\n        pass\n\n    single: Annotated[\n        ModelSingle | None,\n        Field(description=\"The limit for a single transaction.\"),\n    ]\n    day: Annotated[\n        ModelDay | None,\n        Field(description=\"The daily limit for transactions.\"),\n    ]\n    week: Annotated[\n        ModelWeek | None,\n        Field(description=\"The weekly limit for transactions.\"),\n    ]\n    month: Annotated[\n        ModelMonth | None,\n        Field(description=\"The monthly limit for transactions.\"),\n    ]\n    quarter: Annotated[\n        ModelQuarter | None,\n        Field(description=\"The quarterly limit for transactions.\"),\n    ]\n    year: Annotated[\n        ModelYear | None,\n        Field(description=\"The yearly limit for transactions.\"),\n    ]\n    all_time: Annotated[\n        ModelAllTime | None,\n        Field(description=\"The all-time limit for transactions.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Body.ModelSpendingLimits.ModelAllTime","title":"<code>ModelAllTime</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The all-time limit for transactions.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class ModelAllTime(ModelBaseAmount):\n    \"\"\"The all-time limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Body.ModelSpendingLimits.ModelDay","title":"<code>ModelDay</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The daily limit for transactions.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class ModelDay(ModelBaseAmount):\n    \"\"\"The daily limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Body.ModelSpendingLimits.ModelMonth","title":"<code>ModelMonth</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The monthly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class ModelMonth(ModelBaseAmount):\n    \"\"\"The monthly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Body.ModelSpendingLimits.ModelQuarter","title":"<code>ModelQuarter</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The quarterly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class ModelQuarter(ModelBaseAmount):\n    \"\"\"The quarterly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Body.ModelSpendingLimits.ModelSingle","title":"<code>ModelSingle</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The limit for a single transaction.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class ModelSingle(ModelBaseAmount):\n    \"\"\"The limit for a single transaction.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Body.ModelSpendingLimits.ModelWeek","title":"<code>ModelWeek</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The weekly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class ModelWeek(ModelBaseAmount):\n    \"\"\"The weekly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Body.ModelSpendingLimits.ModelYear","title":"<code>ModelYear</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The yearly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class ModelYear(ModelBaseAmount):\n    \"\"\"The yearly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Body.check_inputs","title":"<code>check_inputs()</code>","text":"<p>Check the inputs.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_inputs(self) -&gt; \"CreateCard.Body\":\n    \"\"\"Check the inputs.\"\"\"\n    if not self.virtual:\n        raise ValueError(\"You can only create virtual cards via the API.\")\n    if self.spending_limits is not None:\n        if (\n            sum(\n                [\n                    self.spending_limits.day is not None,\n                    self.spending_limits.week is not None,\n                    self.spending_limits.month is not None,\n                    self.spending_limits.quarter is not None,\n                    self.spending_limits.year is not None,\n                    self.spending_limits.all_time is not None,\n                ]\n            )\n            &gt; 1\n        ):\n            raise ValueError(\n                \"You can have at most 1 periodic (day/week/month/quarter/all-time) limit at a time.\"\n            )\n    return self\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.CreateCard.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceCard</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/cards/post/create_card.py</code> <pre><code>class Response(ResourceCard):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.FreezeCard","title":"<code>FreezeCard</code>","text":"<p>Freeze a card to make it temporarily unavailable for spending. You can only freeze a card that is in the state active.</p> <p>A successful freeze changes the card's state to frozen, and no content is returned in the response.</p> Source code in <code>pyrevolut/api/cards/post/freeze_card.py</code> <pre><code>class FreezeCard:\n    \"\"\"\n    Freeze a card to make it temporarily unavailable for spending.\n    You can only freeze a card that is in the state active.\n\n    A successful freeze changes the card's state to frozen,\n    and no content is returned in the response.\n    \"\"\"\n\n    ROUTE = \"/1.0/cards/{card_id}/freeze\"\n\n    class Body(BaseModel):\n        \"\"\"\n        Request body for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.FreezeCard.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request body for the endpoint.</p> Source code in <code>pyrevolut/api/cards/post/freeze_card.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    Request body for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.FreezeCard.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/cards/post/freeze_card.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.UnfreezeCard","title":"<code>UnfreezeCard</code>","text":"<p>Unfreeze a card to re-enable spending for that card. You can only unfreeze a card that is in the state frozen.</p> <p>A successful unfreeze changes the card's state back to active, and no content is returned in the response.</p> Source code in <code>pyrevolut/api/cards/post/unfreeze_card.py</code> <pre><code>class UnfreezeCard:\n    \"\"\"\n    Unfreeze a card to re-enable spending for that card.\n    You can only unfreeze a card that is in the state frozen.\n\n    A successful unfreeze changes the card's state back to active,\n    and no content is returned in the response.\n    \"\"\"\n\n    ROUTE = \"/1.0/cards/{card_id}/unfreeze\"\n\n    class Body(BaseModel):\n        \"\"\"\n        Request body for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.UnfreezeCard.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request body for the endpoint.</p> Source code in <code>pyrevolut/api/cards/post/unfreeze_card.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    Request body for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.post.UnfreezeCard.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/cards/post/unfreeze_card.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails","title":"<code>UpdateCardDetails</code>","text":"<p>Update details of a specific card, based on its ID. Updating a spending limit does not reset the spending counter.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class UpdateCardDetails:\n    \"\"\"\n    Update details of a specific card, based on its ID.\n    Updating a spending limit does not reset the spending counter.\n    \"\"\"\n\n    ROUTE = \"/1.0/cards/{card_id}\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The body of the request.\n        \"\"\"\n\n        class ModelSpendingLimits(BaseModel):\n            \"\"\"All spending limits set for the card.\"\"\"\n\n            class ModelSingle(ModelBaseAmount):\n                \"\"\"The limit for a single transaction.\"\"\"\n\n                pass\n\n            class ModelDay(ModelBaseAmount):\n                \"\"\"The daily limit for transactions.\"\"\"\n\n                pass\n\n            class ModelWeek(ModelBaseAmount):\n                \"\"\"The weekly limit for transactions.\"\"\"\n\n                pass\n\n            class ModelMonth(ModelBaseAmount):\n                \"\"\"The monthly limit for transactions.\"\"\"\n\n                pass\n\n            class ModelQuarter(ModelBaseAmount):\n                \"\"\"The quarterly limit for transactions.\"\"\"\n\n                pass\n\n            class ModelYear(ModelBaseAmount):\n                \"\"\"The yearly limit for transactions.\"\"\"\n\n                pass\n\n            class ModelAllTime(ModelBaseAmount):\n                \"\"\"The all-time limit for transactions.\"\"\"\n\n                pass\n\n            single: Annotated[\n                ModelSingle | Literal[\"null\"] | None,\n                Field(description=\"The limit for a single transaction.\"),\n            ]\n            day: Annotated[\n                ModelDay | Literal[\"null\"] | None,\n                Field(description=\"The daily limit for transactions.\"),\n            ]\n            week: Annotated[\n                ModelWeek | Literal[\"null\"] | None,\n                Field(description=\"The weekly limit for transactions.\"),\n            ]\n            month: Annotated[\n                ModelMonth | Literal[\"null\"] | None,\n                Field(description=\"The monthly limit for transactions.\"),\n            ]\n            quarter: Annotated[\n                ModelQuarter | Literal[\"null\"] | None,\n                Field(description=\"The quarterly limit for transactions.\"),\n            ]\n            year: Annotated[\n                ModelYear | Literal[\"null\"] | None,\n                Field(description=\"The yearly limit for transactions.\"),\n            ]\n            all_time: Annotated[\n                ModelAllTime | Literal[\"null\"] | None,\n                Field(description=\"The all-time limit for transactions.\"),\n            ]\n\n        label: Annotated[\n            str | None,\n            Field(description=\"The label of the card.\", max_length=30),\n        ] = None\n        categories: Annotated[\n            EnumMerchantCategory | Literal[\"null\"] | None,\n            Field(\n                description=\"\"\"\n                List of merchant categories that will be available for card spending. \n                Use null to erase the value and reset to empty (all categories will be allowed).\n                \"\"\"\n            ),\n        ] = None\n        spending_limits: Annotated[\n            ModelSpendingLimits | Literal[\"null\"] | None,\n            Field(\n                description=\"\"\"\n                All spending limits set for the card.\n\n                You can have at most 1 periodic (day/week/month/quarter/all-time) and 1 non-periodic (single transaction) \n                limit at a time. If you try to specify 2 periodic limits at a time, it will result in an error.\n\n                Spending limit currency must match the default business currency. \n                The default currency was assigned to your business during onboarding.\n\n                Use null as the value for a specific limit to erase that limit. \n                Use null as the value for the spending_limits object to erase all limits.\n                \"\"\"\n            ),\n        ] = None\n\n        @model_validator(mode=\"after\")\n        def check_inputs(self) -&gt; \"UpdateCardDetails.Body\":\n            \"\"\"Check the inputs.\"\"\"\n            if self.spending_limits is not None and self.spending_limits != \"null\":\n                if (\n                    sum(\n                        [\n                            self.spending_limits.day is not None\n                            and self.spending_limits.day != \"null\",\n                            self.spending_limits.week is not None\n                            and self.spending_limits.week != \"null\",\n                            self.spending_limits.month is not None\n                            and self.spending_limits.month != \"null\",\n                            self.spending_limits.quarter is not None\n                            and self.spending_limits.quarter != \"null\",\n                            self.spending_limits.year is not None\n                            and self.spending_limits.year != \"null\",\n                            self.spending_limits.all_time is not None\n                            and self.spending_limits.all_time != \"null\",\n                        ]\n                    )\n                    &gt; 1\n                ):\n                    raise ValueError(\n                        \"You can have at most 1 periodic (day/week/month/quarter/all-time) limit at a time.\"\n                    )\n            return self\n\n    class Response(ResourceCard):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The body of the request.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The body of the request.\n    \"\"\"\n\n    class ModelSpendingLimits(BaseModel):\n        \"\"\"All spending limits set for the card.\"\"\"\n\n        class ModelSingle(ModelBaseAmount):\n            \"\"\"The limit for a single transaction.\"\"\"\n\n            pass\n\n        class ModelDay(ModelBaseAmount):\n            \"\"\"The daily limit for transactions.\"\"\"\n\n            pass\n\n        class ModelWeek(ModelBaseAmount):\n            \"\"\"The weekly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelMonth(ModelBaseAmount):\n            \"\"\"The monthly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelQuarter(ModelBaseAmount):\n            \"\"\"The quarterly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelYear(ModelBaseAmount):\n            \"\"\"The yearly limit for transactions.\"\"\"\n\n            pass\n\n        class ModelAllTime(ModelBaseAmount):\n            \"\"\"The all-time limit for transactions.\"\"\"\n\n            pass\n\n        single: Annotated[\n            ModelSingle | Literal[\"null\"] | None,\n            Field(description=\"The limit for a single transaction.\"),\n        ]\n        day: Annotated[\n            ModelDay | Literal[\"null\"] | None,\n            Field(description=\"The daily limit for transactions.\"),\n        ]\n        week: Annotated[\n            ModelWeek | Literal[\"null\"] | None,\n            Field(description=\"The weekly limit for transactions.\"),\n        ]\n        month: Annotated[\n            ModelMonth | Literal[\"null\"] | None,\n            Field(description=\"The monthly limit for transactions.\"),\n        ]\n        quarter: Annotated[\n            ModelQuarter | Literal[\"null\"] | None,\n            Field(description=\"The quarterly limit for transactions.\"),\n        ]\n        year: Annotated[\n            ModelYear | Literal[\"null\"] | None,\n            Field(description=\"The yearly limit for transactions.\"),\n        ]\n        all_time: Annotated[\n            ModelAllTime | Literal[\"null\"] | None,\n            Field(description=\"The all-time limit for transactions.\"),\n        ]\n\n    label: Annotated[\n        str | None,\n        Field(description=\"The label of the card.\", max_length=30),\n    ] = None\n    categories: Annotated[\n        EnumMerchantCategory | Literal[\"null\"] | None,\n        Field(\n            description=\"\"\"\n            List of merchant categories that will be available for card spending. \n            Use null to erase the value and reset to empty (all categories will be allowed).\n            \"\"\"\n        ),\n    ] = None\n    spending_limits: Annotated[\n        ModelSpendingLimits | Literal[\"null\"] | None,\n        Field(\n            description=\"\"\"\n            All spending limits set for the card.\n\n            You can have at most 1 periodic (day/week/month/quarter/all-time) and 1 non-periodic (single transaction) \n            limit at a time. If you try to specify 2 periodic limits at a time, it will result in an error.\n\n            Spending limit currency must match the default business currency. \n            The default currency was assigned to your business during onboarding.\n\n            Use null as the value for a specific limit to erase that limit. \n            Use null as the value for the spending_limits object to erase all limits.\n            \"\"\"\n        ),\n    ] = None\n\n    @model_validator(mode=\"after\")\n    def check_inputs(self) -&gt; \"UpdateCardDetails.Body\":\n        \"\"\"Check the inputs.\"\"\"\n        if self.spending_limits is not None and self.spending_limits != \"null\":\n            if (\n                sum(\n                    [\n                        self.spending_limits.day is not None\n                        and self.spending_limits.day != \"null\",\n                        self.spending_limits.week is not None\n                        and self.spending_limits.week != \"null\",\n                        self.spending_limits.month is not None\n                        and self.spending_limits.month != \"null\",\n                        self.spending_limits.quarter is not None\n                        and self.spending_limits.quarter != \"null\",\n                        self.spending_limits.year is not None\n                        and self.spending_limits.year != \"null\",\n                        self.spending_limits.all_time is not None\n                        and self.spending_limits.all_time != \"null\",\n                    ]\n                )\n                &gt; 1\n            ):\n                raise ValueError(\n                    \"You can have at most 1 periodic (day/week/month/quarter/all-time) limit at a time.\"\n                )\n        return self\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Body.ModelSpendingLimits","title":"<code>ModelSpendingLimits</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>All spending limits set for the card.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class ModelSpendingLimits(BaseModel):\n    \"\"\"All spending limits set for the card.\"\"\"\n\n    class ModelSingle(ModelBaseAmount):\n        \"\"\"The limit for a single transaction.\"\"\"\n\n        pass\n\n    class ModelDay(ModelBaseAmount):\n        \"\"\"The daily limit for transactions.\"\"\"\n\n        pass\n\n    class ModelWeek(ModelBaseAmount):\n        \"\"\"The weekly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelMonth(ModelBaseAmount):\n        \"\"\"The monthly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelQuarter(ModelBaseAmount):\n        \"\"\"The quarterly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelYear(ModelBaseAmount):\n        \"\"\"The yearly limit for transactions.\"\"\"\n\n        pass\n\n    class ModelAllTime(ModelBaseAmount):\n        \"\"\"The all-time limit for transactions.\"\"\"\n\n        pass\n\n    single: Annotated[\n        ModelSingle | Literal[\"null\"] | None,\n        Field(description=\"The limit for a single transaction.\"),\n    ]\n    day: Annotated[\n        ModelDay | Literal[\"null\"] | None,\n        Field(description=\"The daily limit for transactions.\"),\n    ]\n    week: Annotated[\n        ModelWeek | Literal[\"null\"] | None,\n        Field(description=\"The weekly limit for transactions.\"),\n    ]\n    month: Annotated[\n        ModelMonth | Literal[\"null\"] | None,\n        Field(description=\"The monthly limit for transactions.\"),\n    ]\n    quarter: Annotated[\n        ModelQuarter | Literal[\"null\"] | None,\n        Field(description=\"The quarterly limit for transactions.\"),\n    ]\n    year: Annotated[\n        ModelYear | Literal[\"null\"] | None,\n        Field(description=\"The yearly limit for transactions.\"),\n    ]\n    all_time: Annotated[\n        ModelAllTime | Literal[\"null\"] | None,\n        Field(description=\"The all-time limit for transactions.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Body.ModelSpendingLimits.ModelAllTime","title":"<code>ModelAllTime</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The all-time limit for transactions.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class ModelAllTime(ModelBaseAmount):\n    \"\"\"The all-time limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Body.ModelSpendingLimits.ModelDay","title":"<code>ModelDay</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The daily limit for transactions.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class ModelDay(ModelBaseAmount):\n    \"\"\"The daily limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Body.ModelSpendingLimits.ModelMonth","title":"<code>ModelMonth</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The monthly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class ModelMonth(ModelBaseAmount):\n    \"\"\"The monthly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Body.ModelSpendingLimits.ModelQuarter","title":"<code>ModelQuarter</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The quarterly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class ModelQuarter(ModelBaseAmount):\n    \"\"\"The quarterly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Body.ModelSpendingLimits.ModelSingle","title":"<code>ModelSingle</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The limit for a single transaction.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class ModelSingle(ModelBaseAmount):\n    \"\"\"The limit for a single transaction.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Body.ModelSpendingLimits.ModelWeek","title":"<code>ModelWeek</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The weekly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class ModelWeek(ModelBaseAmount):\n    \"\"\"The weekly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Body.ModelSpendingLimits.ModelYear","title":"<code>ModelYear</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The yearly limit for transactions.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class ModelYear(ModelBaseAmount):\n    \"\"\"The yearly limit for transactions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Body.check_inputs","title":"<code>check_inputs()</code>","text":"<p>Check the inputs.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_inputs(self) -&gt; \"UpdateCardDetails.Body\":\n    \"\"\"Check the inputs.\"\"\"\n    if self.spending_limits is not None and self.spending_limits != \"null\":\n        if (\n            sum(\n                [\n                    self.spending_limits.day is not None\n                    and self.spending_limits.day != \"null\",\n                    self.spending_limits.week is not None\n                    and self.spending_limits.week != \"null\",\n                    self.spending_limits.month is not None\n                    and self.spending_limits.month != \"null\",\n                    self.spending_limits.quarter is not None\n                    and self.spending_limits.quarter != \"null\",\n                    self.spending_limits.year is not None\n                    and self.spending_limits.year != \"null\",\n                    self.spending_limits.all_time is not None\n                    and self.spending_limits.all_time != \"null\",\n                ]\n            )\n            &gt; 1\n        ):\n            raise ValueError(\n                \"You can have at most 1 periodic (day/week/month/quarter/all-time) limit at a time.\"\n            )\n    return self\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.patch.UpdateCardDetails.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceCard</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/cards/patch/update_card_details.py</code> <pre><code>class Response(ResourceCard):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.delete.TerminateCard","title":"<code>TerminateCard</code>","text":"<p>Terminate a specific card, based on its ID.</p> <p>Once the card is terminated, it will not be returned by the API.</p> <p>A successful response does not get any content in return.</p> Source code in <code>pyrevolut/api/cards/delete/terminate_card.py</code> <pre><code>class TerminateCard:\n    \"\"\"\n    Terminate a specific card, based on its ID.\n\n    Once the card is terminated, it will not be returned by the API.\n\n    A successful response does not get any content in return.\n    \"\"\"\n\n    ROUTE = \"cards/{card_id}\"\n\n    class Params(BaseModel):\n        \"\"\"Query parameters for the endpoint.\"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"Response model for the endpoint.\"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.delete.TerminateCard.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/cards/delete/terminate_card.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"Query parameters for the endpoint.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/pydantic/#pyrevolut.api.cards.delete.TerminateCard.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/cards/delete/terminate_card.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"Response model for the endpoint.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/","title":"Cards Synchronous Endpoints","text":"<p>This <code>Cards</code> endpoint provides methods to interact with the cards of the authenticated user.</p> <p>Example usage of the Cards endpoint object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    cards = client.Cards.get_all_cards()\n    print(cards)\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync","title":"<code>EndpointCardsSync</code>","text":"<p>               Bases: <code>BaseEndpointSync</code></p> <p>The Cards API Manage cards for the business team members, freeze, unfreeze, terminate and update card settings, such as transaction limits.</p> <p>This feature is available in the UK, US and the EEA. This feature is not available in Sandbox.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>class EndpointCardsSync(BaseEndpointSync):\n    \"\"\"The Cards API\n    Manage cards for the business team members, freeze, unfreeze,\n    terminate and update card settings, such as transaction limits.\n\n    This feature is available in the UK, US and the EEA.\n    This feature is not available in Sandbox.\n    \"\"\"\n\n    def get_all_cards(\n        self,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        limit: int | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfCards.Response]:\n        \"\"\"\n        Get the list of all cards in your organisation.\n        The results are paginated and sorted by the created_at date in reverse chronological order.\n\n        Parameters\n        ----------\n        created_before : datetime | DateTime | str | int | float | None\n            Retrieves cards with created_at &lt; created_before.\n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n        limit : int | None\n            The maximum number of cards returned per page.\n            To get to the next page, make a new request and use the\n            created_at date of the last card returned in the previous\n            response as the value for created_before.\n\n            If not provided, the default value is 100.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfCards.Response]\n            The list of all cards in your organisation.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = RetrieveListOfCards\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            created_before=created_before,\n            limit=limit,\n        )\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_card(\n        self,\n        card_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveCardDetails.Response:\n        \"\"\"\n        Get the details of a specific card, based on its ID.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n\n        Returns\n        -------\n        dict | RetrieveCardDetails.Response\n            The details of the card.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = RetrieveCardDetails\n        path = endpoint.ROUTE.format(card_id=card_id)\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_card_sensitive_details(\n        self,\n        card_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveSensitiveCardDetails.Response:\n        \"\"\"\n        Get sensitive details of a specific card, based on its ID.\n        Requires the READ_SENSITIVE_CARD_DATA token scope.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n\n        Returns\n        -------\n        dict | RetrieveSensitiveCardDetails.Response\n            The sensitive details of the card.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = RetrieveSensitiveCardDetails\n        path = endpoint.ROUTE.format(card_id=card_id)\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def create_card(\n        self,\n        request_id: str,\n        holder_id: UUID,\n        label: str | None = None,\n        accounts: list[UUID] | None = None,\n        categories: list[EnumMerchantCategory] | None = None,\n        single_limit_amount: float | None = None,\n        single_limit_currency: str | None = None,\n        day_limit_amount: float | None = None,\n        day_limit_currency: str | None = None,\n        week_limit_amount: float | None = None,\n        week_limit_currency: str | None = None,\n        month_limit_amount: float | None = None,\n        month_limit_currency: str | None = None,\n        quarter_limit_amount: float | None = None,\n        quarter_limit_currency: str | None = None,\n        year_limit_amount: float | None = None,\n        year_limit_currency: str | None = None,\n        all_time_limit_amount: float | None = None,\n        all_time_limit_currency: str | None = None,\n        **kwargs,\n    ) -&gt; dict | CreateCard.Response:\n        \"\"\"\n        Create a new card for an existing member of your Revolut Business team.\n\n        When using the API, you can create only virtual cards.\n        To create a physical card, use the Revolut Business app.\n\n        Parameters\n        ----------\n        request_id : str\n            A unique ID of the request that you provide.\n            This ID is used to prevent duplicate card creation requests in case\n            of a lost connection or client error, so make sure you use the same\n            request_id for requests related to the same card.\n            The deduplication is limited to 24 hours counting from the first request\n            using a given ID.\n        holder_id : UUID\n            The ID of the team member who will be the holder of the card.\n        label : str | None\n            The label for the issued card, displayed in the UI to help distinguish between cards.\n            If not specified, no label will be added.\n        accounts : list[UUID] | None\n            The list of accounts to link to the card. If not specified, all accounts will be linked.\n        categories : list[EnumMerchantCategory] | None\n            The list of merchant categories to link to the card. If not specified, all categories will be linked.\n        single_limit_amount : float | None\n            The maximum amount for a single transaction.\n        single_limit_currency : str | None\n            The currency of the single transaction limit.\n        day_limit_amount : float | None\n            The maximum amount for transactions in a day.\n        day_limit_currency : str | None\n            The currency of the day limit.\n        week_limit_amount : float | None\n            The maximum amount for transactions in a week.\n        week_limit_currency : str | None\n            The currency of the week limit.\n        month_limit_amount : float | None\n            The maximum amount for transactions in a month.\n        month_limit_currency : str | None\n            The currency of the month limit.\n        quarter_limit_amount : float | None\n            The maximum amount for transactions in a quarter.\n        quarter_limit_currency : str | None\n            The currency of the quarter limit.\n        year_limit_amount : float | None\n            The maximum amount for transactions in a year.\n        year_limit_currency : str | None\n            The currency of the year limit.\n        all_time_limit_amount : float | None\n            The maximum amount for transactions in the card's lifetime.\n        all_time_limit_currency : str | None\n            The currency of the all-time limit.\n\n        Returns\n        -------\n        dict | CreateCard.Response\n            The details of the created card.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = CreateCard\n        path = endpoint.ROUTE\n\n        # Create the SpendingLimits model (if applicable)\n        spending_limits = endpoint.Body.ModelSpendingLimits(\n            single=(\n                endpoint.Body.ModelSpendingLimits.ModelSingle(\n                    amount=single_limit_amount,\n                    currency=single_limit_currency,\n                )\n                if single_limit_amount is not None and single_limit_currency is not None\n                else None\n            ),\n            day=(\n                endpoint.Body.ModelSpendingLimits.ModelDay(\n                    amount=day_limit_amount,\n                    currency=day_limit_currency,\n                )\n                if day_limit_amount is not None and day_limit_currency is not None\n                else None\n            ),\n            week=(\n                endpoint.Body.ModelSpendingLimits.ModelWeek(\n                    amount=week_limit_amount,\n                    currency=week_limit_currency,\n                )\n                if week_limit_amount is not None and week_limit_currency is not None\n                else None\n            ),\n            month=(\n                endpoint.Body.ModelSpendingLimits.ModelMonth(\n                    amount=month_limit_amount,\n                    currency=month_limit_currency,\n                )\n                if month_limit_amount is not None and month_limit_currency is not None\n                else None\n            ),\n            quarter=(\n                endpoint.Body.ModelSpendingLimits.ModelQuarter(\n                    amount=quarter_limit_amount,\n                    currency=quarter_limit_currency,\n                )\n                if quarter_limit_amount is not None\n                and quarter_limit_currency is not None\n                else None\n            ),\n            year=(\n                endpoint.Body.ModelSpendingLimits.ModelYear(\n                    amount=year_limit_amount,\n                    currency=year_limit_currency,\n                )\n                if year_limit_amount is not None and year_limit_currency is not None\n                else None\n            ),\n            all_time=(\n                endpoint.Body.ModelSpendingLimits.ModelAllTime(\n                    amount=all_time_limit_amount,\n                    currency=all_time_limit_currency,\n                )\n                if all_time_limit_amount is not None\n                and all_time_limit_currency is not None\n                else None\n            ),\n        )\n        if not any(\n            [\n                spending_limits.single is not None,\n                spending_limits.day is not None,\n                spending_limits.week is not None,\n                spending_limits.month is not None,\n                spending_limits.quarter is not None,\n                spending_limits.year is not None,\n                spending_limits.all_time is not None,\n            ]\n        ):\n            spending_limits = None\n\n        body = endpoint.Body(\n            request_id=request_id,\n            virtual=True,\n            holder_id=holder_id,\n            label=label,\n            accounts=accounts,\n            categories=categories,\n            spending_limits=spending_limits,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def freeze_card(\n        self,\n        card_id: UUID,\n        **kwargs,\n    ) -&gt; dict | FreezeCard.Response:\n        \"\"\"\n        Freeze a card to make it temporarily unavailable for spending.\n        You can only freeze a card that is in the state active.\n\n        A successful freeze changes the card's state to frozen,\n        and no content is returned in the response.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n\n        Returns\n        -------\n        dict | FreezeCard.Response\n            An empty dictionary.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = FreezeCard\n        path = endpoint.ROUTE.format(card_id=card_id)\n        body = endpoint.Body()\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def unfreeze_card(\n        self,\n        card_id: UUID,\n        **kwargs,\n    ) -&gt; dict | UnfreezeCard.Response:\n        \"\"\"\n        Unfreeze a card to make it available for spending again.\n        You can only unfreeze a card that is in the state frozen.\n\n        A successful unfreeze changes the card's state to active,\n        and no content is returned in the response.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n\n        Returns\n        -------\n        dict | UnfreezeCard.Response\n            An empty dictionary.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = UnfreezeCard\n        path = endpoint.ROUTE.format(card_id=card_id)\n        body = endpoint.Body()\n\n        self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def update_card(\n        self,\n        card_id: UUID,\n        label: str | None = None,\n        categories: list[EnumMerchantCategory] | Literal[\"null\"] | None = None,\n        single_limit_amount: float | Literal[\"null\"] | None = None,\n        single_limit_currency: str | Literal[\"null\"] | None = None,\n        day_limit_amount: float | Literal[\"null\"] | None = None,\n        day_limit_currency: str | Literal[\"null\"] | None = None,\n        week_limit_amount: float | Literal[\"null\"] | None = None,\n        week_limit_currency: str | Literal[\"null\"] | None = None,\n        month_limit_amount: float | Literal[\"null\"] | None = None,\n        month_limit_currency: str | Literal[\"null\"] | None = None,\n        quarter_limit_amount: float | Literal[\"null\"] | None = None,\n        quarter_limit_currency: str | Literal[\"null\"] | None = None,\n        year_limit_amount: float | Literal[\"null\"] | None = None,\n        year_limit_currency: str | Literal[\"null\"] | None = None,\n        all_time_limit_amount: float | Literal[\"null\"] | None = None,\n        all_time_limit_currency: str | Literal[\"null\"] | None = None,\n        **kwargs,\n    ) -&gt; dict | UpdateCardDetails.Response:\n        \"\"\"\n        Update details of a specific card, based on its ID.\n        Updating a spending limit does not reset the spending counter.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n        label : str | None\n            The label of the card.\n        categories : list[EnumMerchantCategory] | Literal[\"null\"] | None\n            The list of merchant categories to link to the card.\n            If set to 'null', all categories will be linked.\n        single_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for a single transaction.\n            If set to 'null', the limit will be removed.\n        single_limit_currency : str | Literal[\"null\"] | None\n            The currency of the single transaction limit.\n            If set to 'null', the limit will be removed.\n        day_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in a day.\n            If set to 'null', the limit will be removed.\n        day_limit_currency : str | Literal[\"null\"] | None\n            The currency of the day limit.\n            If set to 'null', the limit will be removed.\n        week_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in a week.\n            If set to 'null', the limit will be removed.\n        week_limit_currency : str | Literal[\"null\"] | None\n            The currency of the week limit.\n            If set to 'null', the limit will be removed.\n        month_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in a month.\n            If set to 'null', the limit will be removed.\n        month_limit_currency : str | Literal[\"null\"] | None\n            The currency of the month limit.\n            If set to 'null', the limit will be removed.\n        quarter_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in a quarter.\n            If set to 'null', the limit will be removed.\n        quarter_limit_currency : str | Literal[\"null\"] | None\n            The currency of the quarter limit.\n            If set to 'null', the limit will be removed.\n        year_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in a year.\n            If set to 'null', the limit will be removed.\n        year_limit_currency : str | Literal[\"null\"] | None\n            The currency of the year limit.\n            If set to 'null', the limit will be removed.\n        all_time_limit_amount : float | Literal[\"null\"] | None\n            The maximum amount for transactions in the card's lifetime.\n            If set to 'null', the limit will be removed.\n        all_time_limit_currency : str | Literal[\"null\"] | None\n            The currency of the all-time limit.\n            If set to 'null', the limit will be removed.\n\n        Returns\n        -------\n        dict | UpdateCardDetails.Response\n            The updated details of the card.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = UpdateCardDetails\n        path = endpoint.ROUTE.format(card_id=card_id)\n\n        # Create the SpendingLimits model (if applicable)\n        spending_limits = endpoint.Body.ModelSpendingLimits(\n            single=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelSingle,\n                amount=single_limit_amount,\n                currency=single_limit_currency,\n            ),\n            day=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelDay,\n                amount=day_limit_amount,\n                currency=day_limit_currency,\n            ),\n            week=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelWeek,\n                amount=week_limit_amount,\n                currency=week_limit_currency,\n            ),\n            month=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelMonth,\n                amount=month_limit_amount,\n                currency=month_limit_currency,\n            ),\n            quarter=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelQuarter,\n                amount=quarter_limit_amount,\n                currency=quarter_limit_currency,\n            ),\n            year=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelYear,\n                amount=year_limit_amount,\n                currency=year_limit_currency,\n            ),\n            all_time=self.__process_limit_model(\n                model=endpoint.Body.ModelSpendingLimits.ModelAllTime,\n                amount=all_time_limit_amount,\n                currency=all_time_limit_currency,\n            ),\n        )\n        if not any(\n            [\n                spending_limits.single is not None,\n                spending_limits.day is not None,\n                spending_limits.week is not None,\n                spending_limits.month is not None,\n                spending_limits.quarter is not None,\n                spending_limits.year is not None,\n                spending_limits.all_time is not None,\n            ]\n        ):\n            spending_limits = None\n        elif all(\n            [\n                spending_limits.single == \"null\",\n                spending_limits.day == \"null\",\n                spending_limits.week == \"null\",\n                spending_limits.month == \"null\",\n                spending_limits.quarter == \"null\",\n                spending_limits.year == \"null\",\n                spending_limits.all_time == \"null\",\n            ]\n        ):\n            spending_limits = \"null\"\n\n        body = endpoint.Body(\n            label=label,\n            categories=categories,\n            spending_limits=spending_limits,\n        )\n\n        return self.client.patch(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def delete_card(\n        self,\n        card_id: UUID,\n        **kwargs,\n    ) -&gt; dict | TerminateCard.Response:\n        \"\"\"\n        Terminate a specific card, based on its ID.\n\n        Once the card is terminated, it will not be returned by the API.\n\n        A successful response does not get any content in return.\n\n        Parameters\n        ----------\n        card_id : UUID\n            The card ID.\n\n        Returns\n        -------\n        dict | TerminateCard.Response\n            An empty dictionary.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = TerminateCard\n        path = endpoint.ROUTE.format(card_id=card_id)\n        params = endpoint.Params()\n\n        return self.client.delete(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def __process_limit_model(\n        self,\n        model: Type[BaseModel],\n        amount: float | None,\n        currency: str | None,\n    ):\n        \"\"\"\n        Process the limit model.\n        \"\"\"\n        if amount is not None and currency is not None:\n            return model(\n                amount=amount,\n                currency=currency,\n            )\n        elif amount == \"null\" and currency == \"null\":\n            return \"null\"\n        return None\n\n    def __check_sandbox(self):\n        \"\"\"\n        Check if the sandbox is enabled.\n\n        Raises\n        ------\n        PyRevolutInvalidEnvironment\n            If the sandbox is enabled.\n        \"\"\"\n        if self.client.sandbox:\n            raise PyRevolutInvalidEnvironment(\n                \"This feature is not available in Sandbox.\"\n            )\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync.__check_sandbox","title":"<code>__check_sandbox()</code>","text":"<p>Check if the sandbox is enabled.</p> <p>Raises:</p> Type Description <code>PyRevolutInvalidEnvironment</code> <p>If the sandbox is enabled.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>def __check_sandbox(self):\n    \"\"\"\n    Check if the sandbox is enabled.\n\n    Raises\n    ------\n    PyRevolutInvalidEnvironment\n        If the sandbox is enabled.\n    \"\"\"\n    if self.client.sandbox:\n        raise PyRevolutInvalidEnvironment(\n            \"This feature is not available in Sandbox.\"\n        )\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync.__process_limit_model","title":"<code>__process_limit_model(model, amount, currency)</code>","text":"<p>Process the limit model.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>def __process_limit_model(\n    self,\n    model: Type[BaseModel],\n    amount: float | None,\n    currency: str | None,\n):\n    \"\"\"\n    Process the limit model.\n    \"\"\"\n    if amount is not None and currency is not None:\n        return model(\n            amount=amount,\n            currency=currency,\n        )\n    elif amount == \"null\" and currency == \"null\":\n        return \"null\"\n    return None\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync.create_card","title":"<code>create_card(request_id, holder_id, label=None, accounts=None, categories=None, single_limit_amount=None, single_limit_currency=None, day_limit_amount=None, day_limit_currency=None, week_limit_amount=None, week_limit_currency=None, month_limit_amount=None, month_limit_currency=None, quarter_limit_amount=None, quarter_limit_currency=None, year_limit_amount=None, year_limit_currency=None, all_time_limit_amount=None, all_time_limit_currency=None, **kwargs)</code>","text":"<p>Create a new card for an existing member of your Revolut Business team.</p> <p>When using the API, you can create only virtual cards. To create a physical card, use the Revolut Business app.</p> <p>Parameters:</p> Name Type Description Default <code>request_id</code> <code>str</code> <p>A unique ID of the request that you provide. This ID is used to prevent duplicate card creation requests in case of a lost connection or client error, so make sure you use the same request_id for requests related to the same card. The deduplication is limited to 24 hours counting from the first request using a given ID.</p> required <code>holder_id</code> <code>UUID</code> <p>The ID of the team member who will be the holder of the card.</p> required <code>label</code> <code>str | None</code> <p>The label for the issued card, displayed in the UI to help distinguish between cards. If not specified, no label will be added.</p> <code>None</code> <code>accounts</code> <code>list[UUID] | None</code> <p>The list of accounts to link to the card. If not specified, all accounts will be linked.</p> <code>None</code> <code>categories</code> <code>list[EnumMerchantCategory] | None</code> <p>The list of merchant categories to link to the card. If not specified, all categories will be linked.</p> <code>None</code> <code>single_limit_amount</code> <code>float | None</code> <p>The maximum amount for a single transaction.</p> <code>None</code> <code>single_limit_currency</code> <code>str | None</code> <p>The currency of the single transaction limit.</p> <code>None</code> <code>day_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in a day.</p> <code>None</code> <code>day_limit_currency</code> <code>str | None</code> <p>The currency of the day limit.</p> <code>None</code> <code>week_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in a week.</p> <code>None</code> <code>week_limit_currency</code> <code>str | None</code> <p>The currency of the week limit.</p> <code>None</code> <code>month_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in a month.</p> <code>None</code> <code>month_limit_currency</code> <code>str | None</code> <p>The currency of the month limit.</p> <code>None</code> <code>quarter_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in a quarter.</p> <code>None</code> <code>quarter_limit_currency</code> <code>str | None</code> <p>The currency of the quarter limit.</p> <code>None</code> <code>year_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in a year.</p> <code>None</code> <code>year_limit_currency</code> <code>str | None</code> <p>The currency of the year limit.</p> <code>None</code> <code>all_time_limit_amount</code> <code>float | None</code> <p>The maximum amount for transactions in the card's lifetime.</p> <code>None</code> <code>all_time_limit_currency</code> <code>str | None</code> <p>The currency of the all-time limit.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The details of the created card.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>def create_card(\n    self,\n    request_id: str,\n    holder_id: UUID,\n    label: str | None = None,\n    accounts: list[UUID] | None = None,\n    categories: list[EnumMerchantCategory] | None = None,\n    single_limit_amount: float | None = None,\n    single_limit_currency: str | None = None,\n    day_limit_amount: float | None = None,\n    day_limit_currency: str | None = None,\n    week_limit_amount: float | None = None,\n    week_limit_currency: str | None = None,\n    month_limit_amount: float | None = None,\n    month_limit_currency: str | None = None,\n    quarter_limit_amount: float | None = None,\n    quarter_limit_currency: str | None = None,\n    year_limit_amount: float | None = None,\n    year_limit_currency: str | None = None,\n    all_time_limit_amount: float | None = None,\n    all_time_limit_currency: str | None = None,\n    **kwargs,\n) -&gt; dict | CreateCard.Response:\n    \"\"\"\n    Create a new card for an existing member of your Revolut Business team.\n\n    When using the API, you can create only virtual cards.\n    To create a physical card, use the Revolut Business app.\n\n    Parameters\n    ----------\n    request_id : str\n        A unique ID of the request that you provide.\n        This ID is used to prevent duplicate card creation requests in case\n        of a lost connection or client error, so make sure you use the same\n        request_id for requests related to the same card.\n        The deduplication is limited to 24 hours counting from the first request\n        using a given ID.\n    holder_id : UUID\n        The ID of the team member who will be the holder of the card.\n    label : str | None\n        The label for the issued card, displayed in the UI to help distinguish between cards.\n        If not specified, no label will be added.\n    accounts : list[UUID] | None\n        The list of accounts to link to the card. If not specified, all accounts will be linked.\n    categories : list[EnumMerchantCategory] | None\n        The list of merchant categories to link to the card. If not specified, all categories will be linked.\n    single_limit_amount : float | None\n        The maximum amount for a single transaction.\n    single_limit_currency : str | None\n        The currency of the single transaction limit.\n    day_limit_amount : float | None\n        The maximum amount for transactions in a day.\n    day_limit_currency : str | None\n        The currency of the day limit.\n    week_limit_amount : float | None\n        The maximum amount for transactions in a week.\n    week_limit_currency : str | None\n        The currency of the week limit.\n    month_limit_amount : float | None\n        The maximum amount for transactions in a month.\n    month_limit_currency : str | None\n        The currency of the month limit.\n    quarter_limit_amount : float | None\n        The maximum amount for transactions in a quarter.\n    quarter_limit_currency : str | None\n        The currency of the quarter limit.\n    year_limit_amount : float | None\n        The maximum amount for transactions in a year.\n    year_limit_currency : str | None\n        The currency of the year limit.\n    all_time_limit_amount : float | None\n        The maximum amount for transactions in the card's lifetime.\n    all_time_limit_currency : str | None\n        The currency of the all-time limit.\n\n    Returns\n    -------\n    dict | CreateCard.Response\n        The details of the created card.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = CreateCard\n    path = endpoint.ROUTE\n\n    # Create the SpendingLimits model (if applicable)\n    spending_limits = endpoint.Body.ModelSpendingLimits(\n        single=(\n            endpoint.Body.ModelSpendingLimits.ModelSingle(\n                amount=single_limit_amount,\n                currency=single_limit_currency,\n            )\n            if single_limit_amount is not None and single_limit_currency is not None\n            else None\n        ),\n        day=(\n            endpoint.Body.ModelSpendingLimits.ModelDay(\n                amount=day_limit_amount,\n                currency=day_limit_currency,\n            )\n            if day_limit_amount is not None and day_limit_currency is not None\n            else None\n        ),\n        week=(\n            endpoint.Body.ModelSpendingLimits.ModelWeek(\n                amount=week_limit_amount,\n                currency=week_limit_currency,\n            )\n            if week_limit_amount is not None and week_limit_currency is not None\n            else None\n        ),\n        month=(\n            endpoint.Body.ModelSpendingLimits.ModelMonth(\n                amount=month_limit_amount,\n                currency=month_limit_currency,\n            )\n            if month_limit_amount is not None and month_limit_currency is not None\n            else None\n        ),\n        quarter=(\n            endpoint.Body.ModelSpendingLimits.ModelQuarter(\n                amount=quarter_limit_amount,\n                currency=quarter_limit_currency,\n            )\n            if quarter_limit_amount is not None\n            and quarter_limit_currency is not None\n            else None\n        ),\n        year=(\n            endpoint.Body.ModelSpendingLimits.ModelYear(\n                amount=year_limit_amount,\n                currency=year_limit_currency,\n            )\n            if year_limit_amount is not None and year_limit_currency is not None\n            else None\n        ),\n        all_time=(\n            endpoint.Body.ModelSpendingLimits.ModelAllTime(\n                amount=all_time_limit_amount,\n                currency=all_time_limit_currency,\n            )\n            if all_time_limit_amount is not None\n            and all_time_limit_currency is not None\n            else None\n        ),\n    )\n    if not any(\n        [\n            spending_limits.single is not None,\n            spending_limits.day is not None,\n            spending_limits.week is not None,\n            spending_limits.month is not None,\n            spending_limits.quarter is not None,\n            spending_limits.year is not None,\n            spending_limits.all_time is not None,\n        ]\n    ):\n        spending_limits = None\n\n    body = endpoint.Body(\n        request_id=request_id,\n        virtual=True,\n        holder_id=holder_id,\n        label=label,\n        accounts=accounts,\n        categories=categories,\n        spending_limits=spending_limits,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync.delete_card","title":"<code>delete_card(card_id, **kwargs)</code>","text":"<p>Terminate a specific card, based on its ID.</p> <p>Once the card is terminated, it will not be returned by the API.</p> <p>A successful response does not get any content in return.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dictionary.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>def delete_card(\n    self,\n    card_id: UUID,\n    **kwargs,\n) -&gt; dict | TerminateCard.Response:\n    \"\"\"\n    Terminate a specific card, based on its ID.\n\n    Once the card is terminated, it will not be returned by the API.\n\n    A successful response does not get any content in return.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n\n    Returns\n    -------\n    dict | TerminateCard.Response\n        An empty dictionary.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = TerminateCard\n    path = endpoint.ROUTE.format(card_id=card_id)\n    params = endpoint.Params()\n\n    return self.client.delete(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync.freeze_card","title":"<code>freeze_card(card_id, **kwargs)</code>","text":"<p>Freeze a card to make it temporarily unavailable for spending. You can only freeze a card that is in the state active.</p> <p>A successful freeze changes the card's state to frozen, and no content is returned in the response.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dictionary.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>def freeze_card(\n    self,\n    card_id: UUID,\n    **kwargs,\n) -&gt; dict | FreezeCard.Response:\n    \"\"\"\n    Freeze a card to make it temporarily unavailable for spending.\n    You can only freeze a card that is in the state active.\n\n    A successful freeze changes the card's state to frozen,\n    and no content is returned in the response.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n\n    Returns\n    -------\n    dict | FreezeCard.Response\n        An empty dictionary.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = FreezeCard\n    path = endpoint.ROUTE.format(card_id=card_id)\n    body = endpoint.Body()\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync.get_all_cards","title":"<code>get_all_cards(created_before=None, limit=None, **kwargs)</code>","text":"<p>Get the list of all cards in your organisation. The results are paginated and sorted by the created_at date in reverse chronological order.</p> <p>Parameters:</p> Name Type Description Default <code>created_before</code> <code>datetime | DateTime | str | int | float | None</code> <p>Retrieves cards with created_at &lt; created_before. The default value is the current date and time at which you are calling the endpoint. Provided in ISO 8601 format.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>The maximum number of cards returned per page. To get to the next page, make a new request and use the created_at date of the last card returned in the previous response as the value for created_before.</p> <p>If not provided, the default value is 100.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all cards in your organisation.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>def get_all_cards(\n    self,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    limit: int | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfCards.Response]:\n    \"\"\"\n    Get the list of all cards in your organisation.\n    The results are paginated and sorted by the created_at date in reverse chronological order.\n\n    Parameters\n    ----------\n    created_before : datetime | DateTime | str | int | float | None\n        Retrieves cards with created_at &lt; created_before.\n        The default value is the current date and time at which you are calling the endpoint.\n        Provided in ISO 8601 format.\n    limit : int | None\n        The maximum number of cards returned per page.\n        To get to the next page, make a new request and use the\n        created_at date of the last card returned in the previous\n        response as the value for created_before.\n\n        If not provided, the default value is 100.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfCards.Response]\n        The list of all cards in your organisation.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = RetrieveListOfCards\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        created_before=created_before,\n        limit=limit,\n    )\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync.get_card","title":"<code>get_card(card_id, **kwargs)</code>","text":"<p>Get the details of a specific card, based on its ID.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The details of the card.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>def get_card(\n    self,\n    card_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveCardDetails.Response:\n    \"\"\"\n    Get the details of a specific card, based on its ID.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n\n    Returns\n    -------\n    dict | RetrieveCardDetails.Response\n        The details of the card.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = RetrieveCardDetails\n    path = endpoint.ROUTE.format(card_id=card_id)\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync.get_card_sensitive_details","title":"<code>get_card_sensitive_details(card_id, **kwargs)</code>","text":"<p>Get sensitive details of a specific card, based on its ID. Requires the READ_SENSITIVE_CARD_DATA token scope.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The sensitive details of the card.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>def get_card_sensitive_details(\n    self,\n    card_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveSensitiveCardDetails.Response:\n    \"\"\"\n    Get sensitive details of a specific card, based on its ID.\n    Requires the READ_SENSITIVE_CARD_DATA token scope.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n\n    Returns\n    -------\n    dict | RetrieveSensitiveCardDetails.Response\n        The sensitive details of the card.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = RetrieveSensitiveCardDetails\n    path = endpoint.ROUTE.format(card_id=card_id)\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync.unfreeze_card","title":"<code>unfreeze_card(card_id, **kwargs)</code>","text":"<p>Unfreeze a card to make it available for spending again. You can only unfreeze a card that is in the state frozen.</p> <p>A successful unfreeze changes the card's state to active, and no content is returned in the response.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dictionary.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>def unfreeze_card(\n    self,\n    card_id: UUID,\n    **kwargs,\n) -&gt; dict | UnfreezeCard.Response:\n    \"\"\"\n    Unfreeze a card to make it available for spending again.\n    You can only unfreeze a card that is in the state frozen.\n\n    A successful unfreeze changes the card's state to active,\n    and no content is returned in the response.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n\n    Returns\n    -------\n    dict | UnfreezeCard.Response\n        An empty dictionary.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = UnfreezeCard\n    path = endpoint.ROUTE.format(card_id=card_id)\n    body = endpoint.Body()\n\n    self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/cards/synchronous/#pyrevolut.api.cards.endpoint.EndpointCardsSync.update_card","title":"<code>update_card(card_id, label=None, categories=None, single_limit_amount=None, single_limit_currency=None, day_limit_amount=None, day_limit_currency=None, week_limit_amount=None, week_limit_currency=None, month_limit_amount=None, month_limit_currency=None, quarter_limit_amount=None, quarter_limit_currency=None, year_limit_amount=None, year_limit_currency=None, all_time_limit_amount=None, all_time_limit_currency=None, **kwargs)</code>","text":"<p>Update details of a specific card, based on its ID. Updating a spending limit does not reset the spending counter.</p> <p>Parameters:</p> Name Type Description Default <code>card_id</code> <code>UUID</code> <p>The card ID.</p> required <code>label</code> <code>str | None</code> <p>The label of the card.</p> <code>None</code> <code>categories</code> <code>list[EnumMerchantCategory] | Literal['null'] | None</code> <p>The list of merchant categories to link to the card. If set to 'null', all categories will be linked.</p> <code>None</code> <code>single_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for a single transaction. If set to 'null', the limit will be removed.</p> <code>None</code> <code>single_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the single transaction limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>day_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in a day. If set to 'null', the limit will be removed.</p> <code>None</code> <code>day_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the day limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>week_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in a week. If set to 'null', the limit will be removed.</p> <code>None</code> <code>week_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the week limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>month_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in a month. If set to 'null', the limit will be removed.</p> <code>None</code> <code>month_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the month limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>quarter_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in a quarter. If set to 'null', the limit will be removed.</p> <code>None</code> <code>quarter_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the quarter limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>year_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in a year. If set to 'null', the limit will be removed.</p> <code>None</code> <code>year_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the year limit. If set to 'null', the limit will be removed.</p> <code>None</code> <code>all_time_limit_amount</code> <code>float | Literal['null'] | None</code> <p>The maximum amount for transactions in the card's lifetime. If set to 'null', the limit will be removed.</p> <code>None</code> <code>all_time_limit_currency</code> <code>str | Literal['null'] | None</code> <p>The currency of the all-time limit. If set to 'null', the limit will be removed.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The updated details of the card.</p> Source code in <code>pyrevolut/api/cards/endpoint/synchronous.py</code> <pre><code>def update_card(\n    self,\n    card_id: UUID,\n    label: str | None = None,\n    categories: list[EnumMerchantCategory] | Literal[\"null\"] | None = None,\n    single_limit_amount: float | Literal[\"null\"] | None = None,\n    single_limit_currency: str | Literal[\"null\"] | None = None,\n    day_limit_amount: float | Literal[\"null\"] | None = None,\n    day_limit_currency: str | Literal[\"null\"] | None = None,\n    week_limit_amount: float | Literal[\"null\"] | None = None,\n    week_limit_currency: str | Literal[\"null\"] | None = None,\n    month_limit_amount: float | Literal[\"null\"] | None = None,\n    month_limit_currency: str | Literal[\"null\"] | None = None,\n    quarter_limit_amount: float | Literal[\"null\"] | None = None,\n    quarter_limit_currency: str | Literal[\"null\"] | None = None,\n    year_limit_amount: float | Literal[\"null\"] | None = None,\n    year_limit_currency: str | Literal[\"null\"] | None = None,\n    all_time_limit_amount: float | Literal[\"null\"] | None = None,\n    all_time_limit_currency: str | Literal[\"null\"] | None = None,\n    **kwargs,\n) -&gt; dict | UpdateCardDetails.Response:\n    \"\"\"\n    Update details of a specific card, based on its ID.\n    Updating a spending limit does not reset the spending counter.\n\n    Parameters\n    ----------\n    card_id : UUID\n        The card ID.\n    label : str | None\n        The label of the card.\n    categories : list[EnumMerchantCategory] | Literal[\"null\"] | None\n        The list of merchant categories to link to the card.\n        If set to 'null', all categories will be linked.\n    single_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for a single transaction.\n        If set to 'null', the limit will be removed.\n    single_limit_currency : str | Literal[\"null\"] | None\n        The currency of the single transaction limit.\n        If set to 'null', the limit will be removed.\n    day_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in a day.\n        If set to 'null', the limit will be removed.\n    day_limit_currency : str | Literal[\"null\"] | None\n        The currency of the day limit.\n        If set to 'null', the limit will be removed.\n    week_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in a week.\n        If set to 'null', the limit will be removed.\n    week_limit_currency : str | Literal[\"null\"] | None\n        The currency of the week limit.\n        If set to 'null', the limit will be removed.\n    month_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in a month.\n        If set to 'null', the limit will be removed.\n    month_limit_currency : str | Literal[\"null\"] | None\n        The currency of the month limit.\n        If set to 'null', the limit will be removed.\n    quarter_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in a quarter.\n        If set to 'null', the limit will be removed.\n    quarter_limit_currency : str | Literal[\"null\"] | None\n        The currency of the quarter limit.\n        If set to 'null', the limit will be removed.\n    year_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in a year.\n        If set to 'null', the limit will be removed.\n    year_limit_currency : str | Literal[\"null\"] | None\n        The currency of the year limit.\n        If set to 'null', the limit will be removed.\n    all_time_limit_amount : float | Literal[\"null\"] | None\n        The maximum amount for transactions in the card's lifetime.\n        If set to 'null', the limit will be removed.\n    all_time_limit_currency : str | Literal[\"null\"] | None\n        The currency of the all-time limit.\n        If set to 'null', the limit will be removed.\n\n    Returns\n    -------\n    dict | UpdateCardDetails.Response\n        The updated details of the card.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = UpdateCardDetails\n    path = endpoint.ROUTE.format(card_id=card_id)\n\n    # Create the SpendingLimits model (if applicable)\n    spending_limits = endpoint.Body.ModelSpendingLimits(\n        single=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelSingle,\n            amount=single_limit_amount,\n            currency=single_limit_currency,\n        ),\n        day=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelDay,\n            amount=day_limit_amount,\n            currency=day_limit_currency,\n        ),\n        week=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelWeek,\n            amount=week_limit_amount,\n            currency=week_limit_currency,\n        ),\n        month=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelMonth,\n            amount=month_limit_amount,\n            currency=month_limit_currency,\n        ),\n        quarter=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelQuarter,\n            amount=quarter_limit_amount,\n            currency=quarter_limit_currency,\n        ),\n        year=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelYear,\n            amount=year_limit_amount,\n            currency=year_limit_currency,\n        ),\n        all_time=self.__process_limit_model(\n            model=endpoint.Body.ModelSpendingLimits.ModelAllTime,\n            amount=all_time_limit_amount,\n            currency=all_time_limit_currency,\n        ),\n    )\n    if not any(\n        [\n            spending_limits.single is not None,\n            spending_limits.day is not None,\n            spending_limits.week is not None,\n            spending_limits.month is not None,\n            spending_limits.quarter is not None,\n            spending_limits.year is not None,\n            spending_limits.all_time is not None,\n        ]\n    ):\n        spending_limits = None\n    elif all(\n        [\n            spending_limits.single == \"null\",\n            spending_limits.day == \"null\",\n            spending_limits.week == \"null\",\n            spending_limits.month == \"null\",\n            spending_limits.quarter == \"null\",\n            spending_limits.year == \"null\",\n            spending_limits.all_time == \"null\",\n        ]\n    ):\n        spending_limits = \"null\"\n\n    body = endpoint.Body(\n        label=label,\n        categories=categories,\n        spending_limits=spending_limits,\n    )\n\n    return self.client.patch(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/counterparties/asynchronous/","title":"Counterparties Asynchronous Endpoints","text":"<p>This <code>Counterparties</code> endpoint provides asynchronous methods to interact with the counterparties of the authenticated user.</p> <p>Example usage of the Counterparties endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        counterparties = await client.Counterparties.get_all_counterparties()\n        print(counterparties)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/counterparties/asynchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesAsync","title":"<code>EndpointCounterpartiesAsync</code>","text":"<p>               Bases: <code>BaseEndpointAsync</code></p> <p>The async Counterparties API</p> <p>Manage counterparties that you intend to transact with.</p> <p>Request and response examples can vary based on the account provider's location and type of the counterparty.</p> <p>In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties. Therefore, to help you simulate Create a counterparty requests, we have created some test accounts for counterparties of profile type personal.</p> <p>To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:</p> <p>Test User 1 &amp; john1pvki Test User 2 &amp; john2pvki ... Test User 9 &amp; john9pvki</p> Source code in <code>pyrevolut/api/counterparties/endpoint/asynchronous.py</code> <pre><code>class EndpointCounterpartiesAsync(BaseEndpointAsync):\n    \"\"\"The async Counterparties API\n\n    Manage counterparties that you intend to transact with.\n\n    Request and response examples can vary based on the account provider's\n    location and type of the counterparty.\n\n    In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties.\n    Therefore, to help you simulate Create a counterparty requests, we have created some\n    test accounts for counterparties of profile type personal.\n\n    To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:\n\n    Test User 1 &amp; john1pvki\n    Test User 2 &amp; john2pvki\n    ...\n    Test User 9 &amp; john9pvki\n    \"\"\"\n\n    async def get_all_counterparties(\n        self,\n        name: str | None = None,\n        account_no: str | None = None,\n        sort_code: str | None = None,\n        iban: str | None = None,\n        bic: str | None = None,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        limit: int | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfCounterparties.Response]:\n        \"\"\"\n        Get all the counterparties that you have created, or use the query parameters to filter the results.\n\n        The counterparties are sorted by the created_at date in reverse chronological order.\n\n        The returned counterparties are paginated. The maximum number of counterparties returned per page\n        is specified by the limit parameter. To get to the next page, make a new request and use the\n        created_at date of the last counterparty returned in the previous response.\n\n        Parameters\n        ----------\n        name : str | None\n            The name of the counterparty to retrieve. It does not need to be an exact match,\n            partial match is also supported.\n        account_no : str | None\n            The exact account number of the counterparty to retrieve.\n        sort_code : str | None\n            The exact sort code of the counterparty to retrieve.\n            Only allowed in combination with the account_no parameter.\n        iban : str | None\n            The exact IBAN of the counterparty to retrieve.\n        bic : str | None\n            The exact BIC of the counterparty to retrieve. Only allowed in combination with the iban parameter.\n        created_before : datetime | DateTime | str | int | float | None\n            Retrieves counterparties with created_at &lt; created_before.\n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n        limit : int | None\n            The maximum number of counterparties returned per page.\n            To get to the next page, make a new request and use the\n            created_at date of the last card returned in the previous\n            response as the value for created_before.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfCounterparties.Response]\n            The list of all counterparties that you have created.\n        \"\"\"\n        endpoint = RetrieveListOfCounterparties\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            name=name,\n            account_no=account_no,\n            sort_code=sort_code,\n            iban=iban,\n            bic=bic,\n            created_before=created_before,\n            limit=limit,\n        )\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def get_counterparty(\n        self,\n        counterparty_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveCounterparty.Response:\n        \"\"\"Get the information about a specific counterparty by ID.\n\n        Parameters\n        ----------\n        counterparty_id : UUID\n            The ID of the counterparty to retrieve.\n\n        Returns\n        -------\n        dict | RetrieveCounterparty.Response\n            The information about the counterparty.\n\n        \"\"\"\n        endpoint = RetrieveCounterparty\n        path = endpoint.ROUTE.format(counterparty_id=counterparty_id)\n        params = endpoint.Params()\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def create_counterparty(\n        self,\n        company_name: str | None = None,\n        profile_type: EnumProfileType | None = None,\n        name: str | None = None,\n        individual_first_name: str | None = None,\n        individual_last_name: str | None = None,\n        bank_country: str | None = None,\n        currency: str | None = None,\n        revtag: str | None = None,\n        account_no: str | None = None,\n        iban: str | None = None,\n        sort_code: str | None = None,\n        routing_number: str | None = None,\n        bic: str | None = None,\n        clabe: str | None = None,\n        isfc: str | None = None,\n        bsb_code: str | None = None,\n        address_street_line1: str | None = None,\n        address_street_line2: str | None = None,\n        address_region: str | None = None,\n        address_city: str | None = None,\n        address_country: str | None = None,\n        address_postcode: str | None = None,\n        **kwargs,\n    ) -&gt; dict | CreateCounterparty.Response:\n        \"\"\"\n        Create a new counterparty to transact with.\n\n        In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties.\n        To help you simulate Create a counterparty requests for counterparties of profile type personal,\n        we created some test accounts. Look inside for test Revtags.\n\n        To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:\n\n            Test User 1 &amp; john1pvki\n            Test User 2 &amp; john2pvki\n            ...\n            Test User 9 &amp; john9pvki\n\n        Parameters\n        ----------\n        company_name : str | None\n            The name of the company counterparty.\n            Use when individual_name or name isn't specified and profile_type is business.\n        profile_type : EnumProfileType | None\n            The type of the Revolut profile. Used when adding an existing Revolut user via Revtag.\n        name : str | None\n            The name of the counterparty that you create for an existing Revolut user via Revtag.\n            Provide the value only when you specify personal for profile_type.\n        individual_first_name : str | None\n            The first name of the individual counterparty.\n            Use when company_name isn't specified.\n        individual_last_name : str | None\n            The last name of the individual counterparty.\n            Use when company_name isn't specified.\n        bank_country : str | None\n            The country of the counterparty's bank as the 2-letter ISO 3166 code.\n        currency : str | None\n            ISO 4217 currency code in upper case.\n        revtag : str | None\n            The Revtag of the counterparty to add.\n        account_no : str | None\n            The bank account number of the counterparty.\n        iban : str | None\n            The IBAN number of the counterparty's account. This field is displayed for IBAN countries.\n        sort_code : str | None\n            The sort code of the counterparty's bank. This field is displayed for GBP accounts.\n        routing_number : str | None\n            The routing number of the counterparty's bank. This field is displayed for USD accounts.\n        bic : str | None\n            The BIC number of the counterparty's account. This field is required for non-SEPA IBAN/SWIFT.\n        clabe : str | None\n            The CLABE number of the counterparty's account. This field is required for SWIFT MX.\n        isfc : str | None\n            The ISFC number of the counterparty's account. This field is required for INR accounts.\n        bsb_code : str | None\n            The BSB code of the counterparty's account. This field is required for AUD accounts.\n        address_street_line1 : str | None\n            Street line 1 information.\n        address_street_line2 : str | None\n            Street line 2 information.\n        address_region : str | None\n            The name of the region.\n        address_city : str | None\n            The name of the city.\n        address_country : str | None\n            The country of the counterparty's address as the 2-letter ISO 3166 code.\n        address_postcode : str | None\n            The postcode of the counterparty's address.\n\n        Returns\n        -------\n        dict | CreateCounterparty.Response\n            A dict with the information about the created counterparty.\n        \"\"\"\n        endpoint = CreateCounterparty\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            company_name=company_name,\n            profile_type=profile_type,\n            name=name,\n            individual_name=(\n                endpoint.Body.ModelIndividualName(\n                    first_name=individual_first_name,\n                    last_name=individual_last_name,\n                )\n                if individual_first_name is not None or individual_last_name is not None\n                else None\n            ),\n            bank_country=bank_country,\n            currency=currency,\n            revtag=revtag,\n            account_no=account_no,\n            iban=iban,\n            sort_code=sort_code,\n            routing_number=routing_number,\n            bic=bic,\n            clabe=clabe,\n            isfc=isfc,\n            bsb_code=bsb_code,\n            address=(\n                endpoint.Body.ModelAddress(\n                    street_line1=address_street_line1,\n                    street_line2=address_street_line2,\n                    region=address_region,\n                    city=address_city,\n                    country=address_country,\n                    postcode=address_postcode,\n                )\n                if address_country is not None and address_postcode is not None\n                else None\n            ),\n        )\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    async def validate_account_name(\n        self,\n        account_no: str,\n        sort_code: str,\n        company_name: str | None = None,\n        individual_first_name: str | None = None,\n        individual_last_name: str | None = None,\n        **kwargs,\n    ) -&gt; dict | ValidateAccountName.Response:\n        \"\"\"\n        Use Confirmation of Payee (CoP) to validate a UK counterparty's account name\n        against their account number and sort code when adding a counterparty or making a\n        transfer to a new or existing counterparty.\n\n        Note\n        ----\n        Confirmation of Payee is an account name checking system in the UK that helps clients\n        to make sure payments aren't sent to the wrong bank or building society account.\n\n        When performing the check, you must specify the account type by providing the name for either\n        an individual (personal account) or a company (business account).\n\n        Caution\n        -------\n        The CoP check does not protect you against all kinds of fraud. It only checks if the name you provided for an account matches that account's details.\n        Even if the counterparty's details match, you should still exercise due caution when transferring funds.\n\n        This functionality is only available to UK-based businesses.\n\n        Parameters\n        ----------\n        account_no : str\n            The account number of the counterparty.\n        sort_code : str\n            The sort code of the counterparty's account.\n        company_name : str | None\n            The name of the business counterparty. Use when individual_name is not specified.\n        individual_first_name : str | None\n            The first name of the individual counterparty.\n            Use when company_name isn't specified.\n        individual_last_name : str | None\n            The last name of the individual counterparty.\n            Use when company_name isn't specified.\n\n        Returns\n        -------\n        dict | ValidateAccountName.Response\n            A dict with the information about the validated account name.\n        \"\"\"\n        endpoint = ValidateAccountName\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            account_no=account_no,\n            sort_code=sort_code,\n            company_name=company_name,\n            individual_name=(\n                endpoint.Body.ModelIndividualName(\n                    first_name=individual_first_name,\n                    last_name=individual_last_name,\n                )\n                if individual_first_name is not None or individual_last_name is not None\n                else None\n            ),\n        )\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    async def delete_counterparty(\n        self,\n        counterparty_id: UUID,\n        **kwargs,\n    ) -&gt; dict | DeleteCounterparty.Response:\n        \"\"\"Delete a counterparty with the given ID.\n        When a counterparty is deleted, you cannot make any payments to the counterparty.\n\n        Parameters\n        ----------\n        counterparty_id : UUID\n            The ID of the counterparty to delete.\n\n        Returns\n        -------\n        dict | DeleteCounterparty.Response\n            An empty dict.\n        \"\"\"\n        endpoint = DeleteCounterparty\n        path = endpoint.ROUTE.format(counterparty_id=counterparty_id)\n        params = endpoint.Params()\n\n        return await self.client.delete(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/counterparties/asynchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesAsync.create_counterparty","title":"<code>create_counterparty(company_name=None, profile_type=None, name=None, individual_first_name=None, individual_last_name=None, bank_country=None, currency=None, revtag=None, account_no=None, iban=None, sort_code=None, routing_number=None, bic=None, clabe=None, isfc=None, bsb_code=None, address_street_line1=None, address_street_line2=None, address_region=None, address_city=None, address_country=None, address_postcode=None, **kwargs)</code>  <code>async</code>","text":"<p>Create a new counterparty to transact with.</p> <p>In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties. To help you simulate Create a counterparty requests for counterparties of profile type personal, we created some test accounts. Look inside for test Revtags.</p> <p>To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:</p> <pre><code>Test User 1 &amp; john1pvki\nTest User 2 &amp; john2pvki\n...\nTest User 9 &amp; john9pvki\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>company_name</code> <code>str | None</code> <p>The name of the company counterparty. Use when individual_name or name isn't specified and profile_type is business.</p> <code>None</code> <code>profile_type</code> <code>EnumProfileType | None</code> <p>The type of the Revolut profile. Used when adding an existing Revolut user via Revtag.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>The name of the counterparty that you create for an existing Revolut user via Revtag. Provide the value only when you specify personal for profile_type.</p> <code>None</code> <code>individual_first_name</code> <code>str | None</code> <p>The first name of the individual counterparty. Use when company_name isn't specified.</p> <code>None</code> <code>individual_last_name</code> <code>str | None</code> <p>The last name of the individual counterparty. Use when company_name isn't specified.</p> <code>None</code> <code>bank_country</code> <code>str | None</code> <p>The country of the counterparty's bank as the 2-letter ISO 3166 code.</p> <code>None</code> <code>currency</code> <code>str | None</code> <p>ISO 4217 currency code in upper case.</p> <code>None</code> <code>revtag</code> <code>str | None</code> <p>The Revtag of the counterparty to add.</p> <code>None</code> <code>account_no</code> <code>str | None</code> <p>The bank account number of the counterparty.</p> <code>None</code> <code>iban</code> <code>str | None</code> <p>The IBAN number of the counterparty's account. This field is displayed for IBAN countries.</p> <code>None</code> <code>sort_code</code> <code>str | None</code> <p>The sort code of the counterparty's bank. This field is displayed for GBP accounts.</p> <code>None</code> <code>routing_number</code> <code>str | None</code> <p>The routing number of the counterparty's bank. This field is displayed for USD accounts.</p> <code>None</code> <code>bic</code> <code>str | None</code> <p>The BIC number of the counterparty's account. This field is required for non-SEPA IBAN/SWIFT.</p> <code>None</code> <code>clabe</code> <code>str | None</code> <p>The CLABE number of the counterparty's account. This field is required for SWIFT MX.</p> <code>None</code> <code>isfc</code> <code>str | None</code> <p>The ISFC number of the counterparty's account. This field is required for INR accounts.</p> <code>None</code> <code>bsb_code</code> <code>str | None</code> <p>The BSB code of the counterparty's account. This field is required for AUD accounts.</p> <code>None</code> <code>address_street_line1</code> <code>str | None</code> <p>Street line 1 information.</p> <code>None</code> <code>address_street_line2</code> <code>str | None</code> <p>Street line 2 information.</p> <code>None</code> <code>address_region</code> <code>str | None</code> <p>The name of the region.</p> <code>None</code> <code>address_city</code> <code>str | None</code> <p>The name of the city.</p> <code>None</code> <code>address_country</code> <code>str | None</code> <p>The country of the counterparty's address as the 2-letter ISO 3166 code.</p> <code>None</code> <code>address_postcode</code> <code>str | None</code> <p>The postcode of the counterparty's address.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the created counterparty.</p> Source code in <code>pyrevolut/api/counterparties/endpoint/asynchronous.py</code> <pre><code>async def create_counterparty(\n    self,\n    company_name: str | None = None,\n    profile_type: EnumProfileType | None = None,\n    name: str | None = None,\n    individual_first_name: str | None = None,\n    individual_last_name: str | None = None,\n    bank_country: str | None = None,\n    currency: str | None = None,\n    revtag: str | None = None,\n    account_no: str | None = None,\n    iban: str | None = None,\n    sort_code: str | None = None,\n    routing_number: str | None = None,\n    bic: str | None = None,\n    clabe: str | None = None,\n    isfc: str | None = None,\n    bsb_code: str | None = None,\n    address_street_line1: str | None = None,\n    address_street_line2: str | None = None,\n    address_region: str | None = None,\n    address_city: str | None = None,\n    address_country: str | None = None,\n    address_postcode: str | None = None,\n    **kwargs,\n) -&gt; dict | CreateCounterparty.Response:\n    \"\"\"\n    Create a new counterparty to transact with.\n\n    In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties.\n    To help you simulate Create a counterparty requests for counterparties of profile type personal,\n    we created some test accounts. Look inside for test Revtags.\n\n    To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:\n\n        Test User 1 &amp; john1pvki\n        Test User 2 &amp; john2pvki\n        ...\n        Test User 9 &amp; john9pvki\n\n    Parameters\n    ----------\n    company_name : str | None\n        The name of the company counterparty.\n        Use when individual_name or name isn't specified and profile_type is business.\n    profile_type : EnumProfileType | None\n        The type of the Revolut profile. Used when adding an existing Revolut user via Revtag.\n    name : str | None\n        The name of the counterparty that you create for an existing Revolut user via Revtag.\n        Provide the value only when you specify personal for profile_type.\n    individual_first_name : str | None\n        The first name of the individual counterparty.\n        Use when company_name isn't specified.\n    individual_last_name : str | None\n        The last name of the individual counterparty.\n        Use when company_name isn't specified.\n    bank_country : str | None\n        The country of the counterparty's bank as the 2-letter ISO 3166 code.\n    currency : str | None\n        ISO 4217 currency code in upper case.\n    revtag : str | None\n        The Revtag of the counterparty to add.\n    account_no : str | None\n        The bank account number of the counterparty.\n    iban : str | None\n        The IBAN number of the counterparty's account. This field is displayed for IBAN countries.\n    sort_code : str | None\n        The sort code of the counterparty's bank. This field is displayed for GBP accounts.\n    routing_number : str | None\n        The routing number of the counterparty's bank. This field is displayed for USD accounts.\n    bic : str | None\n        The BIC number of the counterparty's account. This field is required for non-SEPA IBAN/SWIFT.\n    clabe : str | None\n        The CLABE number of the counterparty's account. This field is required for SWIFT MX.\n    isfc : str | None\n        The ISFC number of the counterparty's account. This field is required for INR accounts.\n    bsb_code : str | None\n        The BSB code of the counterparty's account. This field is required for AUD accounts.\n    address_street_line1 : str | None\n        Street line 1 information.\n    address_street_line2 : str | None\n        Street line 2 information.\n    address_region : str | None\n        The name of the region.\n    address_city : str | None\n        The name of the city.\n    address_country : str | None\n        The country of the counterparty's address as the 2-letter ISO 3166 code.\n    address_postcode : str | None\n        The postcode of the counterparty's address.\n\n    Returns\n    -------\n    dict | CreateCounterparty.Response\n        A dict with the information about the created counterparty.\n    \"\"\"\n    endpoint = CreateCounterparty\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        company_name=company_name,\n        profile_type=profile_type,\n        name=name,\n        individual_name=(\n            endpoint.Body.ModelIndividualName(\n                first_name=individual_first_name,\n                last_name=individual_last_name,\n            )\n            if individual_first_name is not None or individual_last_name is not None\n            else None\n        ),\n        bank_country=bank_country,\n        currency=currency,\n        revtag=revtag,\n        account_no=account_no,\n        iban=iban,\n        sort_code=sort_code,\n        routing_number=routing_number,\n        bic=bic,\n        clabe=clabe,\n        isfc=isfc,\n        bsb_code=bsb_code,\n        address=(\n            endpoint.Body.ModelAddress(\n                street_line1=address_street_line1,\n                street_line2=address_street_line2,\n                region=address_region,\n                city=address_city,\n                country=address_country,\n                postcode=address_postcode,\n            )\n            if address_country is not None and address_postcode is not None\n            else None\n        ),\n    )\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/counterparties/asynchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesAsync.delete_counterparty","title":"<code>delete_counterparty(counterparty_id, **kwargs)</code>  <code>async</code>","text":"<p>Delete a counterparty with the given ID. When a counterparty is deleted, you cannot make any payments to the counterparty.</p> <p>Parameters:</p> Name Type Description Default <code>counterparty_id</code> <code>UUID</code> <p>The ID of the counterparty to delete.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dict.</p> Source code in <code>pyrevolut/api/counterparties/endpoint/asynchronous.py</code> <pre><code>async def delete_counterparty(\n    self,\n    counterparty_id: UUID,\n    **kwargs,\n) -&gt; dict | DeleteCounterparty.Response:\n    \"\"\"Delete a counterparty with the given ID.\n    When a counterparty is deleted, you cannot make any payments to the counterparty.\n\n    Parameters\n    ----------\n    counterparty_id : UUID\n        The ID of the counterparty to delete.\n\n    Returns\n    -------\n    dict | DeleteCounterparty.Response\n        An empty dict.\n    \"\"\"\n    endpoint = DeleteCounterparty\n    path = endpoint.ROUTE.format(counterparty_id=counterparty_id)\n    params = endpoint.Params()\n\n    return await self.client.delete(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/counterparties/asynchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesAsync.get_all_counterparties","title":"<code>get_all_counterparties(name=None, account_no=None, sort_code=None, iban=None, bic=None, created_before=None, limit=None, **kwargs)</code>  <code>async</code>","text":"<p>Get all the counterparties that you have created, or use the query parameters to filter the results.</p> <p>The counterparties are sorted by the created_at date in reverse chronological order.</p> <p>The returned counterparties are paginated. The maximum number of counterparties returned per page is specified by the limit parameter. To get to the next page, make a new request and use the created_at date of the last counterparty returned in the previous response.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the counterparty to retrieve. It does not need to be an exact match, partial match is also supported.</p> <code>None</code> <code>account_no</code> <code>str | None</code> <p>The exact account number of the counterparty to retrieve.</p> <code>None</code> <code>sort_code</code> <code>str | None</code> <p>The exact sort code of the counterparty to retrieve. Only allowed in combination with the account_no parameter.</p> <code>None</code> <code>iban</code> <code>str | None</code> <p>The exact IBAN of the counterparty to retrieve.</p> <code>None</code> <code>bic</code> <code>str | None</code> <p>The exact BIC of the counterparty to retrieve. Only allowed in combination with the iban parameter.</p> <code>None</code> <code>created_before</code> <code>datetime | DateTime | str | int | float | None</code> <p>Retrieves counterparties with created_at &lt; created_before. The default value is the current date and time at which you are calling the endpoint. Provided in ISO 8601 format.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>The maximum number of counterparties returned per page. To get to the next page, make a new request and use the created_at date of the last card returned in the previous response as the value for created_before.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all counterparties that you have created.</p> Source code in <code>pyrevolut/api/counterparties/endpoint/asynchronous.py</code> <pre><code>async def get_all_counterparties(\n    self,\n    name: str | None = None,\n    account_no: str | None = None,\n    sort_code: str | None = None,\n    iban: str | None = None,\n    bic: str | None = None,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    limit: int | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfCounterparties.Response]:\n    \"\"\"\n    Get all the counterparties that you have created, or use the query parameters to filter the results.\n\n    The counterparties are sorted by the created_at date in reverse chronological order.\n\n    The returned counterparties are paginated. The maximum number of counterparties returned per page\n    is specified by the limit parameter. To get to the next page, make a new request and use the\n    created_at date of the last counterparty returned in the previous response.\n\n    Parameters\n    ----------\n    name : str | None\n        The name of the counterparty to retrieve. It does not need to be an exact match,\n        partial match is also supported.\n    account_no : str | None\n        The exact account number of the counterparty to retrieve.\n    sort_code : str | None\n        The exact sort code of the counterparty to retrieve.\n        Only allowed in combination with the account_no parameter.\n    iban : str | None\n        The exact IBAN of the counterparty to retrieve.\n    bic : str | None\n        The exact BIC of the counterparty to retrieve. Only allowed in combination with the iban parameter.\n    created_before : datetime | DateTime | str | int | float | None\n        Retrieves counterparties with created_at &lt; created_before.\n        The default value is the current date and time at which you are calling the endpoint.\n        Provided in ISO 8601 format.\n    limit : int | None\n        The maximum number of counterparties returned per page.\n        To get to the next page, make a new request and use the\n        created_at date of the last card returned in the previous\n        response as the value for created_before.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfCounterparties.Response]\n        The list of all counterparties that you have created.\n    \"\"\"\n    endpoint = RetrieveListOfCounterparties\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        name=name,\n        account_no=account_no,\n        sort_code=sort_code,\n        iban=iban,\n        bic=bic,\n        created_before=created_before,\n        limit=limit,\n    )\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/counterparties/asynchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesAsync.get_counterparty","title":"<code>get_counterparty(counterparty_id, **kwargs)</code>  <code>async</code>","text":"<p>Get the information about a specific counterparty by ID.</p> <p>Parameters:</p> Name Type Description Default <code>counterparty_id</code> <code>UUID</code> <p>The ID of the counterparty to retrieve.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The information about the counterparty.</p> Source code in <code>pyrevolut/api/counterparties/endpoint/asynchronous.py</code> <pre><code>async def get_counterparty(\n    self,\n    counterparty_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveCounterparty.Response:\n    \"\"\"Get the information about a specific counterparty by ID.\n\n    Parameters\n    ----------\n    counterparty_id : UUID\n        The ID of the counterparty to retrieve.\n\n    Returns\n    -------\n    dict | RetrieveCounterparty.Response\n        The information about the counterparty.\n\n    \"\"\"\n    endpoint = RetrieveCounterparty\n    path = endpoint.ROUTE.format(counterparty_id=counterparty_id)\n    params = endpoint.Params()\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/counterparties/asynchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesAsync.validate_account_name","title":"<code>validate_account_name(account_no, sort_code, company_name=None, individual_first_name=None, individual_last_name=None, **kwargs)</code>  <code>async</code>","text":"<p>Use Confirmation of Payee (CoP) to validate a UK counterparty's account name against their account number and sort code when adding a counterparty or making a transfer to a new or existing counterparty.</p> Note <p>Confirmation of Payee is an account name checking system in the UK that helps clients to make sure payments aren't sent to the wrong bank or building society account.</p> <p>When performing the check, you must specify the account type by providing the name for either an individual (personal account) or a company (business account).</p> Caution <p>The CoP check does not protect you against all kinds of fraud. It only checks if the name you provided for an account matches that account's details. Even if the counterparty's details match, you should still exercise due caution when transferring funds.</p> <p>This functionality is only available to UK-based businesses.</p> <p>Parameters:</p> Name Type Description Default <code>account_no</code> <code>str</code> <p>The account number of the counterparty.</p> required <code>sort_code</code> <code>str</code> <p>The sort code of the counterparty's account.</p> required <code>company_name</code> <code>str | None</code> <p>The name of the business counterparty. Use when individual_name is not specified.</p> <code>None</code> <code>individual_first_name</code> <code>str | None</code> <p>The first name of the individual counterparty. Use when company_name isn't specified.</p> <code>None</code> <code>individual_last_name</code> <code>str | None</code> <p>The last name of the individual counterparty. Use when company_name isn't specified.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the validated account name.</p> Source code in <code>pyrevolut/api/counterparties/endpoint/asynchronous.py</code> <pre><code>async def validate_account_name(\n    self,\n    account_no: str,\n    sort_code: str,\n    company_name: str | None = None,\n    individual_first_name: str | None = None,\n    individual_last_name: str | None = None,\n    **kwargs,\n) -&gt; dict | ValidateAccountName.Response:\n    \"\"\"\n    Use Confirmation of Payee (CoP) to validate a UK counterparty's account name\n    against their account number and sort code when adding a counterparty or making a\n    transfer to a new or existing counterparty.\n\n    Note\n    ----\n    Confirmation of Payee is an account name checking system in the UK that helps clients\n    to make sure payments aren't sent to the wrong bank or building society account.\n\n    When performing the check, you must specify the account type by providing the name for either\n    an individual (personal account) or a company (business account).\n\n    Caution\n    -------\n    The CoP check does not protect you against all kinds of fraud. It only checks if the name you provided for an account matches that account's details.\n    Even if the counterparty's details match, you should still exercise due caution when transferring funds.\n\n    This functionality is only available to UK-based businesses.\n\n    Parameters\n    ----------\n    account_no : str\n        The account number of the counterparty.\n    sort_code : str\n        The sort code of the counterparty's account.\n    company_name : str | None\n        The name of the business counterparty. Use when individual_name is not specified.\n    individual_first_name : str | None\n        The first name of the individual counterparty.\n        Use when company_name isn't specified.\n    individual_last_name : str | None\n        The last name of the individual counterparty.\n        Use when company_name isn't specified.\n\n    Returns\n    -------\n    dict | ValidateAccountName.Response\n        A dict with the information about the validated account name.\n    \"\"\"\n    endpoint = ValidateAccountName\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        account_no=account_no,\n        sort_code=sort_code,\n        company_name=company_name,\n        individual_name=(\n            endpoint.Body.ModelIndividualName(\n                first_name=individual_first_name,\n                last_name=individual_last_name,\n            )\n            if individual_first_name is not None or individual_last_name is not None\n            else None\n        ),\n    )\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/","title":"Counterparties Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Counterparties</code> endpoint.</p>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.resources.ResourceCounterparty","title":"<code>ResourceCounterparty</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Counterparty resource model.</p> Source code in <code>pyrevolut/api/counterparties/resources/counterparty.py</code> <pre><code>class ResourceCounterparty(BaseModel):\n    \"\"\"\n    Counterparty resource model.\n    \"\"\"\n\n    class ModelAccount(BaseModel):\n        \"\"\"A public account associated with this counterparty.\"\"\"\n\n        id: Annotated[\n            UUID,\n            Field(description=\"The ID of the counterparty's account.\"),\n        ]\n        name: Annotated[\n            str | None,\n            Field(description=\"The name of the counterparty.\"),\n        ] = None\n        bank_country: Annotated[\n            CountryAlpha2 | None,\n            Field(description=\"The country of the bank as the 2-letter ISO 3166 code.\"),\n        ]\n        currency: Annotated[\n            Currency,\n            Field(description=\"ISO 4217 currency code in upper case.\"),\n        ]\n        type: Annotated[\n            EnumAccountType,\n            Field(description=\"Indicates the type of account.\"),\n        ]\n        account_no: Annotated[\n            str | None,\n            Field(description=\"The bank account number of the counterparty.\"),\n        ] = None\n        iban: Annotated[\n            str | None,\n            Field(\n                description=\"The IBAN number of the counterparty's account if applicable.\"\n            ),\n        ] = None\n        sort_code: Annotated[\n            str | None,\n            Field(\n                description=\"The sort code of the counterparty's account if applicable.\"\n            ),\n        ] = None\n        routing_number: Annotated[\n            str | None,\n            Field(\n                description=\"The routing number of the counterparty's account if applicable.\"\n            ),\n        ] = None\n        bic: Annotated[\n            str | None,\n            Field(\n                description=\"The BIC number of the counterparty's account if applicable.\"\n            ),\n        ] = None\n        clabe: Annotated[\n            str | None,\n            Field(\n                description=\"The CLABE number of the counterparty's account if applicable.\"\n            ),\n        ] = None\n        ifsc: Annotated[\n            str | None,\n            Field(\n                description=\"The IFSC number of the counterparty's account if applicable.\"\n            ),\n        ] = None\n        bsb_code: Annotated[\n            str | None,\n            Field(\n                description=\"The BSB code of the counterparty's account if applicable.\"\n            ),\n        ] = None\n        recipient_charges: Annotated[\n            EnumRecipientCharges | None,\n            Field(description=\"Indicates the possibility of the recipient charges.\"),\n        ] = None\n\n    class ModelCard(BaseModel):\n        \"\"\"The list of cards associated with this counterparty.\"\"\"\n\n        id: Annotated[\n            UUID,\n            Field(description=\"The ID of the counterparty's card.\"),\n        ]\n        name: Annotated[\n            str,\n            Field(description=\"The name of the counterparty.\"),\n        ]\n        last_digits: Annotated[\n            str,\n            Field(description=\"The last four digits of the card number.\"),\n        ]\n        scheme: Annotated[\n            EnumCardScheme,\n            Field(description=\"The card brand.\"),\n        ]\n        country: Annotated[\n            CountryAlpha2,\n            Field(\n                description=\"The country of the card issuer as the 2-letter ISO 3166 code.\"\n            ),\n        ]\n        currency: Annotated[\n            Currency,\n            Field(description=\"ISO 4217 currency code in upper case.\"),\n        ]\n\n    id: Annotated[\n        UUID,\n        Field(description=\"The ID of the counterparty.\"),\n    ]\n    name: Annotated[\n        str,\n        Field(description=\"The name of the counterparty.\"),\n    ]\n    revtag: Annotated[\n        str | None,\n        Field(description=\"The Revtag of the counterparty.\"),\n    ] = None\n    profile_type: Annotated[\n        EnumProfileType | None,\n        Field(\n            description=\"The type of the Revolut profile. Used when adding an existing Revolut user via Revtag.\"\n        ),\n    ] = None\n    country: Annotated[\n        CountryAlpha2 | None,\n        Field(\n            description=\"The bank country of the counterparty as the 2-letter ISO 3166 code.\"\n        ),\n    ] = None\n    state: Annotated[\n        EnumProfileState,\n        Field(description=\"Indicates the state of the counterparty.\"),\n    ]\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the counterparty was created in ISO 8601 format.\"\n        ),\n    ]\n    updated_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the counterparty was last updated in ISO 8601 format.\"\n        ),\n    ]\n    accounts: Annotated[\n        list[ModelAccount] | None,\n        Field(\n            description=\"The list of public accounts associated with this counterparty.\"\n        ),\n    ] = None\n    cards: Annotated[\n        list[ModelCard] | None,\n        Field(description=\"The list of cards associated with this counterparty.\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.resources.ResourceCounterparty.ModelAccount","title":"<code>ModelAccount</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A public account associated with this counterparty.</p> Source code in <code>pyrevolut/api/counterparties/resources/counterparty.py</code> <pre><code>class ModelAccount(BaseModel):\n    \"\"\"A public account associated with this counterparty.\"\"\"\n\n    id: Annotated[\n        UUID,\n        Field(description=\"The ID of the counterparty's account.\"),\n    ]\n    name: Annotated[\n        str | None,\n        Field(description=\"The name of the counterparty.\"),\n    ] = None\n    bank_country: Annotated[\n        CountryAlpha2 | None,\n        Field(description=\"The country of the bank as the 2-letter ISO 3166 code.\"),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(description=\"ISO 4217 currency code in upper case.\"),\n    ]\n    type: Annotated[\n        EnumAccountType,\n        Field(description=\"Indicates the type of account.\"),\n    ]\n    account_no: Annotated[\n        str | None,\n        Field(description=\"The bank account number of the counterparty.\"),\n    ] = None\n    iban: Annotated[\n        str | None,\n        Field(\n            description=\"The IBAN number of the counterparty's account if applicable.\"\n        ),\n    ] = None\n    sort_code: Annotated[\n        str | None,\n        Field(\n            description=\"The sort code of the counterparty's account if applicable.\"\n        ),\n    ] = None\n    routing_number: Annotated[\n        str | None,\n        Field(\n            description=\"The routing number of the counterparty's account if applicable.\"\n        ),\n    ] = None\n    bic: Annotated[\n        str | None,\n        Field(\n            description=\"The BIC number of the counterparty's account if applicable.\"\n        ),\n    ] = None\n    clabe: Annotated[\n        str | None,\n        Field(\n            description=\"The CLABE number of the counterparty's account if applicable.\"\n        ),\n    ] = None\n    ifsc: Annotated[\n        str | None,\n        Field(\n            description=\"The IFSC number of the counterparty's account if applicable.\"\n        ),\n    ] = None\n    bsb_code: Annotated[\n        str | None,\n        Field(\n            description=\"The BSB code of the counterparty's account if applicable.\"\n        ),\n    ] = None\n    recipient_charges: Annotated[\n        EnumRecipientCharges | None,\n        Field(description=\"Indicates the possibility of the recipient charges.\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.resources.ResourceCounterparty.ModelCard","title":"<code>ModelCard</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The list of cards associated with this counterparty.</p> Source code in <code>pyrevolut/api/counterparties/resources/counterparty.py</code> <pre><code>class ModelCard(BaseModel):\n    \"\"\"The list of cards associated with this counterparty.\"\"\"\n\n    id: Annotated[\n        UUID,\n        Field(description=\"The ID of the counterparty's card.\"),\n    ]\n    name: Annotated[\n        str,\n        Field(description=\"The name of the counterparty.\"),\n    ]\n    last_digits: Annotated[\n        str,\n        Field(description=\"The last four digits of the card number.\"),\n    ]\n    scheme: Annotated[\n        EnumCardScheme,\n        Field(description=\"The card brand.\"),\n    ]\n    country: Annotated[\n        CountryAlpha2,\n        Field(\n            description=\"The country of the card issuer as the 2-letter ISO 3166 code.\"\n        ),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(description=\"ISO 4217 currency code in upper case.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.get.RetrieveListOfCounterparties","title":"<code>RetrieveListOfCounterparties</code>","text":"<p>Get all the counterparties that you have created, or use the query parameters to filter the results.</p> <p>The counterparties are sorted by the created_at date in reverse chronological order.</p> <p>The returned counterparties are paginated. The maximum number of counterparties returned per page is specified by the limit parameter. To get to the next page, make a new request and use the created_at date of the last counterparty returned in the previous response.</p> Source code in <code>pyrevolut/api/counterparties/get/retrieve_list_of_counterparties.py</code> <pre><code>class RetrieveListOfCounterparties:\n    \"\"\"\n    Get all the counterparties that you have created, or use the query parameters to filter the results.\n\n    The counterparties are sorted by the created_at date in reverse chronological order.\n\n    The returned counterparties are paginated. The maximum number of counterparties returned per page\n    is specified by the limit parameter. To get to the next page, make a new request and use the\n    created_at date of the last counterparty returned in the previous response.\n    \"\"\"\n\n    ROUTE = \"/1.0/counterparties\"\n\n    class Params(BaseModel):\n        \"\"\"\n        Query parameters for the endpoint.\n        \"\"\"\n\n        name: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The name of the counterparty to retrieve. It does not need to be an exact match, \n                partial match is also supported.\n                \"\"\"\n            ),\n        ] = None\n        account_no: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The exact account number of the counterparty to retrieve.\n                \"\"\"\n            ),\n        ] = None\n        sort_code: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The exact sort code of the counterparty to retrieve.\n                Only allowed in combination with the account_no parameter.                \n                \"\"\"\n            ),\n        ] = None\n        iban: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The exact IBAN of the counterparty to retrieve.\n                \"\"\"\n            ),\n        ] = None\n        bic: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The exact BIC of the counterparty to retrieve. Only allowed in combination with the iban parameter.\n                \"\"\"\n            ),\n        ] = None\n        created_before: Annotated[\n            DateTime | None,\n            Field(\n                description=\"\"\"\n                Retrieves counterparties with created_at &lt; created_before. \n                The default value is the current date and time at which you are calling the endpoint.\n                Provided in ISO 8601 format.\n                \"\"\"\n            ),\n        ] = None\n        limit: Annotated[\n            int | None,\n            Field(\n                description=\"\"\"\n                The maximum number of counterparties returned per page.\n                To get to the next page, make a new request and use the \n                created_at date of the last card returned in the previous \n                response as the value for created_before.              \n\n                If not provided, the default value is 100.  \n                \"\"\",\n                ge=1,\n                le=100,\n            ),\n        ] = None\n\n        @model_validator(mode=\"after\")\n        def check_inputs(self) -&gt; \"RetrieveListOfCounterparties.Params\":\n            \"\"\"\n            Validate the input parameters.\n            \"\"\"\n            if self.sort_code and not self.account_no:\n                raise ValueError(\n                    \"The sort_code parameter is only allowed in combination with the account_no parameter.\"\n                )\n            if self.bic and not self.iban:\n                raise ValueError(\n                    \"The bic parameter is only allowed in combination with the iban parameter.\"\n                )\n            return self\n\n    class Response(ResourceCounterparty):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.get.RetrieveListOfCounterparties.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/counterparties/get/retrieve_list_of_counterparties.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    Query parameters for the endpoint.\n    \"\"\"\n\n    name: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The name of the counterparty to retrieve. It does not need to be an exact match, \n            partial match is also supported.\n            \"\"\"\n        ),\n    ] = None\n    account_no: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The exact account number of the counterparty to retrieve.\n            \"\"\"\n        ),\n    ] = None\n    sort_code: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The exact sort code of the counterparty to retrieve.\n            Only allowed in combination with the account_no parameter.                \n            \"\"\"\n        ),\n    ] = None\n    iban: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The exact IBAN of the counterparty to retrieve.\n            \"\"\"\n        ),\n    ] = None\n    bic: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The exact BIC of the counterparty to retrieve. Only allowed in combination with the iban parameter.\n            \"\"\"\n        ),\n    ] = None\n    created_before: Annotated[\n        DateTime | None,\n        Field(\n            description=\"\"\"\n            Retrieves counterparties with created_at &lt; created_before. \n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n            \"\"\"\n        ),\n    ] = None\n    limit: Annotated[\n        int | None,\n        Field(\n            description=\"\"\"\n            The maximum number of counterparties returned per page.\n            To get to the next page, make a new request and use the \n            created_at date of the last card returned in the previous \n            response as the value for created_before.              \n\n            If not provided, the default value is 100.  \n            \"\"\",\n            ge=1,\n            le=100,\n        ),\n    ] = None\n\n    @model_validator(mode=\"after\")\n    def check_inputs(self) -&gt; \"RetrieveListOfCounterparties.Params\":\n        \"\"\"\n        Validate the input parameters.\n        \"\"\"\n        if self.sort_code and not self.account_no:\n            raise ValueError(\n                \"The sort_code parameter is only allowed in combination with the account_no parameter.\"\n            )\n        if self.bic and not self.iban:\n            raise ValueError(\n                \"The bic parameter is only allowed in combination with the iban parameter.\"\n            )\n        return self\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.get.RetrieveListOfCounterparties.Params.check_inputs","title":"<code>check_inputs()</code>","text":"<p>Validate the input parameters.</p> Source code in <code>pyrevolut/api/counterparties/get/retrieve_list_of_counterparties.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_inputs(self) -&gt; \"RetrieveListOfCounterparties.Params\":\n    \"\"\"\n    Validate the input parameters.\n    \"\"\"\n    if self.sort_code and not self.account_no:\n        raise ValueError(\n            \"The sort_code parameter is only allowed in combination with the account_no parameter.\"\n        )\n    if self.bic and not self.iban:\n        raise ValueError(\n            \"The bic parameter is only allowed in combination with the iban parameter.\"\n        )\n    return self\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.get.RetrieveListOfCounterparties.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceCounterparty</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/counterparties/get/retrieve_list_of_counterparties.py</code> <pre><code>class Response(ResourceCounterparty):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.get.RetrieveCounterparty","title":"<code>RetrieveCounterparty</code>","text":"<p>Get the information about a specific counterparty by ID.</p> Source code in <code>pyrevolut/api/counterparties/get/retrieve_counterparty.py</code> <pre><code>class RetrieveCounterparty:\n    \"\"\"Get the information about a specific counterparty by ID.\"\"\"\n\n    ROUTE = \"/1.0/counterparty/{counterparty_id}\"\n\n    class Params(BaseModel):\n        \"\"\"\n        Query parameters for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(ResourceCounterparty):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.get.RetrieveCounterparty.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/counterparties/get/retrieve_counterparty.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    Query parameters for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.get.RetrieveCounterparty.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceCounterparty</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/counterparties/get/retrieve_counterparty.py</code> <pre><code>class Response(ResourceCounterparty):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.CreateCounterparty","title":"<code>CreateCounterparty</code>","text":"<p>Create a new counterparty to transact with.</p> <p>In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties. To help you simulate Create a counterparty requests for counterparties of profile type personal, we created some test accounts. Look inside for test Revtags.</p> <p>To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:</p> <pre><code>Test User 1 &amp; john1pvki\nTest User 2 &amp; john2pvki\n...\nTest User 9 &amp; john9pvki\n</code></pre> Source code in <code>pyrevolut/api/counterparties/post/create_counterparty.py</code> <pre><code>class CreateCounterparty:\n    \"\"\"\n    Create a new counterparty to transact with.\n\n    In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties. To help you simulate Create a counterparty requests for counterparties of profile type personal, we created some test accounts. Look inside for test Revtags.\n\n    To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:\n\n        Test User 1 &amp; john1pvki\n        Test User 2 &amp; john2pvki\n        ...\n        Test User 9 &amp; john9pvki\n    \"\"\"\n\n    ROUTE = \"/1.0/counterparty\"\n\n    class Body(BaseModel):\n        \"\"\"Request body for the endpoint.\"\"\"\n\n        class ModelIndividualName(BaseModel):\n            \"\"\"\n            The name of the individual counterparty.\n            Use when company_name isn't specified.\n            \"\"\"\n\n            first_name: Annotated[\n                str | None,\n                Field(description=\"The first name of the individual counterparty.\"),\n            ] = None\n            last_name: Annotated[\n                str | None,\n                Field(description=\"The last name of the individual counterparty.\"),\n            ] = None\n\n        class ModelAddress(BaseModel):\n            \"\"\"\n            The address of the counterparty.\n            \"\"\"\n\n            street_line1: Annotated[\n                str | None,\n                Field(description=\"Street line 1 information.\"),\n            ] = None\n            street_line2: Annotated[\n                str | None,\n                Field(description=\"Street line 2 information.\"),\n            ] = None\n            region: Annotated[\n                str | None,\n                Field(description=\"The name of the region.\"),\n            ] = None\n            city: Annotated[\n                str | None,\n                Field(description=\"The name of the city.\"),\n            ] = None\n            country: Annotated[\n                CountryAlpha2,\n                Field(\n                    description=\"The country of the counterparty as the 2-letter ISO 3166 code.\"\n                ),\n            ]\n            postcode: Annotated[\n                str,\n                Field(description=\"The postcode of the counterparty address.\"),\n            ]\n\n        company_name: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The name of the company counterparty. \n                Use when individual_name or name isn't specified and profile_type is business.\n                \"\"\"\n            ),\n        ] = None\n        profile_type: Annotated[\n            EnumProfileType | None,\n            Field(\n                description=\"\"\"\n                The type of the Revolut profile. Used when adding an existing Revolut user via Revtag.\n                \"\"\"\n            ),\n        ] = None\n        name: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The name of the counterparty that you create for an existing Revolut user via Revtag. \n                Provide the value only when you specify personal for profile_type.                \n                \"\"\"\n            ),\n        ] = None\n        individual_name: Annotated[\n            ModelIndividualName | None,\n            Field(\n                description=\"\"\"\n                The name of the individual counterparty. \n                Use when company_name isn't specified.\n                \"\"\"\n            ),\n        ] = None\n        bank_country: Annotated[\n            CountryAlpha2 | None,\n            Field(description=\"The country of the bank as the 2-letter ISO 3166 code.\"),\n        ] = None\n        currency: Annotated[\n            Currency | None,\n            Field(description=\"ISO 4217 currency code in upper case.\"),\n        ] = None\n        revtag: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The Revtag of the counterparty to add.                \n                \"\"\"\n            ),\n        ] = None\n        account_no: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The bank account number of the counterparty.               \n                \"\"\"\n            ),\n        ] = None\n        iban: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The IBAN number of the counterparty's account. This field is displayed for IBAN countries.               \n                \"\"\"\n            ),\n        ] = None\n        sort_code: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The sort code of the counterparty's account. This field is required for GBP accounts.           \n                \"\"\"\n            ),\n        ] = None\n        routing_number: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The routing number of the counterparty's account. This field is required for USD accounts.               \n                \"\"\"\n            ),\n        ] = None\n        bic: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The BIC number of the counterparty's account. This field is required for non-SEPA IBAN/SWIFT.             \n                \"\"\"\n            ),\n        ] = None\n        clabe: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The CLABE number of the counterparty's account. This field is required for SWIFT MX.               \n                \"\"\"\n            ),\n        ] = None\n        isfc: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The ISFC number of the counterparty's account. This field is required for INR accounts.               \n                \"\"\"\n            ),\n        ] = None\n        bsb_code: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The BSB code of the counterparty's account. This field is required for AUD accounts.               \n                \"\"\"\n            ),\n        ] = None\n        address: Annotated[\n            ModelAddress | None,\n            Field(description=\"The address of the counterparty.\"),\n        ] = None\n\n        @model_validator(mode=\"after\")\n        def check_inputs(self) -&gt; \"CreateCounterparty.Body\":\n            \"\"\"Validate the input data.\"\"\"\n\n            # Company name check\n            if self.profile_type == EnumProfileType.BUSINESS and (\n                self.individual_name is None or self.name is None\n            ):\n                assert (\n                    self.company_name is not None\n                ), \"company_name is required for business profile type.\"\n\n            # Name check\n            if self.profile_type == EnumProfileType.PERSONAL:\n                assert (\n                    self.name is not None\n                ), \"name is required for personal profile type.\"\n\n            # Profile type check\n            if self.profile_type is not None:\n                assert (\n                    self.revtag is not None\n                ), \"revtag is required when profile_type is specified.\"\n            else:\n                assert (\n                    self.revtag is None\n                ), \"revtag is not required when profile_type is not specified.\"\n\n            # Individual name check\n            # if self.company_name is None:\n            #     assert (\n            #         self.individual_name is not None\n            #     ), \"individual_name is required when company_name is not specified.\"\n\n            # Sort code check\n            if self.currency == \"GBP\":\n                assert (\n                    self.sort_code is not None\n                ), \"sort_code is required for GBP accounts.\"\n\n            # Routing number check\n            if self.currency == \"USD\":\n                assert (\n                    self.routing_number is not None\n                ), \"routing_number is required for USD accounts.\"\n\n            # IFSC check\n            if self.currency == \"INR\":\n                assert self.isfc is not None, \"isfc is required for INR accounts.\"\n\n            # BSB code check\n            if self.currency == \"AUD\":\n                assert (\n                    self.bsb_code is not None\n                ), \"bsb_code is required for AUD accounts.\"\n\n            return self\n\n    class Response(ResourceCounterparty):\n        \"\"\"Response model for the endpoint.\"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.CreateCounterparty.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request body for the endpoint.</p> Source code in <code>pyrevolut/api/counterparties/post/create_counterparty.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"Request body for the endpoint.\"\"\"\n\n    class ModelIndividualName(BaseModel):\n        \"\"\"\n        The name of the individual counterparty.\n        Use when company_name isn't specified.\n        \"\"\"\n\n        first_name: Annotated[\n            str | None,\n            Field(description=\"The first name of the individual counterparty.\"),\n        ] = None\n        last_name: Annotated[\n            str | None,\n            Field(description=\"The last name of the individual counterparty.\"),\n        ] = None\n\n    class ModelAddress(BaseModel):\n        \"\"\"\n        The address of the counterparty.\n        \"\"\"\n\n        street_line1: Annotated[\n            str | None,\n            Field(description=\"Street line 1 information.\"),\n        ] = None\n        street_line2: Annotated[\n            str | None,\n            Field(description=\"Street line 2 information.\"),\n        ] = None\n        region: Annotated[\n            str | None,\n            Field(description=\"The name of the region.\"),\n        ] = None\n        city: Annotated[\n            str | None,\n            Field(description=\"The name of the city.\"),\n        ] = None\n        country: Annotated[\n            CountryAlpha2,\n            Field(\n                description=\"The country of the counterparty as the 2-letter ISO 3166 code.\"\n            ),\n        ]\n        postcode: Annotated[\n            str,\n            Field(description=\"The postcode of the counterparty address.\"),\n        ]\n\n    company_name: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The name of the company counterparty. \n            Use when individual_name or name isn't specified and profile_type is business.\n            \"\"\"\n        ),\n    ] = None\n    profile_type: Annotated[\n        EnumProfileType | None,\n        Field(\n            description=\"\"\"\n            The type of the Revolut profile. Used when adding an existing Revolut user via Revtag.\n            \"\"\"\n        ),\n    ] = None\n    name: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The name of the counterparty that you create for an existing Revolut user via Revtag. \n            Provide the value only when you specify personal for profile_type.                \n            \"\"\"\n        ),\n    ] = None\n    individual_name: Annotated[\n        ModelIndividualName | None,\n        Field(\n            description=\"\"\"\n            The name of the individual counterparty. \n            Use when company_name isn't specified.\n            \"\"\"\n        ),\n    ] = None\n    bank_country: Annotated[\n        CountryAlpha2 | None,\n        Field(description=\"The country of the bank as the 2-letter ISO 3166 code.\"),\n    ] = None\n    currency: Annotated[\n        Currency | None,\n        Field(description=\"ISO 4217 currency code in upper case.\"),\n    ] = None\n    revtag: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The Revtag of the counterparty to add.                \n            \"\"\"\n        ),\n    ] = None\n    account_no: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The bank account number of the counterparty.               \n            \"\"\"\n        ),\n    ] = None\n    iban: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The IBAN number of the counterparty's account. This field is displayed for IBAN countries.               \n            \"\"\"\n        ),\n    ] = None\n    sort_code: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The sort code of the counterparty's account. This field is required for GBP accounts.           \n            \"\"\"\n        ),\n    ] = None\n    routing_number: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The routing number of the counterparty's account. This field is required for USD accounts.               \n            \"\"\"\n        ),\n    ] = None\n    bic: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The BIC number of the counterparty's account. This field is required for non-SEPA IBAN/SWIFT.             \n            \"\"\"\n        ),\n    ] = None\n    clabe: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The CLABE number of the counterparty's account. This field is required for SWIFT MX.               \n            \"\"\"\n        ),\n    ] = None\n    isfc: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The ISFC number of the counterparty's account. This field is required for INR accounts.               \n            \"\"\"\n        ),\n    ] = None\n    bsb_code: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The BSB code of the counterparty's account. This field is required for AUD accounts.               \n            \"\"\"\n        ),\n    ] = None\n    address: Annotated[\n        ModelAddress | None,\n        Field(description=\"The address of the counterparty.\"),\n    ] = None\n\n    @model_validator(mode=\"after\")\n    def check_inputs(self) -&gt; \"CreateCounterparty.Body\":\n        \"\"\"Validate the input data.\"\"\"\n\n        # Company name check\n        if self.profile_type == EnumProfileType.BUSINESS and (\n            self.individual_name is None or self.name is None\n        ):\n            assert (\n                self.company_name is not None\n            ), \"company_name is required for business profile type.\"\n\n        # Name check\n        if self.profile_type == EnumProfileType.PERSONAL:\n            assert (\n                self.name is not None\n            ), \"name is required for personal profile type.\"\n\n        # Profile type check\n        if self.profile_type is not None:\n            assert (\n                self.revtag is not None\n            ), \"revtag is required when profile_type is specified.\"\n        else:\n            assert (\n                self.revtag is None\n            ), \"revtag is not required when profile_type is not specified.\"\n\n        # Individual name check\n        # if self.company_name is None:\n        #     assert (\n        #         self.individual_name is not None\n        #     ), \"individual_name is required when company_name is not specified.\"\n\n        # Sort code check\n        if self.currency == \"GBP\":\n            assert (\n                self.sort_code is not None\n            ), \"sort_code is required for GBP accounts.\"\n\n        # Routing number check\n        if self.currency == \"USD\":\n            assert (\n                self.routing_number is not None\n            ), \"routing_number is required for USD accounts.\"\n\n        # IFSC check\n        if self.currency == \"INR\":\n            assert self.isfc is not None, \"isfc is required for INR accounts.\"\n\n        # BSB code check\n        if self.currency == \"AUD\":\n            assert (\n                self.bsb_code is not None\n            ), \"bsb_code is required for AUD accounts.\"\n\n        return self\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.CreateCounterparty.Body.ModelAddress","title":"<code>ModelAddress</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The address of the counterparty.</p> Source code in <code>pyrevolut/api/counterparties/post/create_counterparty.py</code> <pre><code>class ModelAddress(BaseModel):\n    \"\"\"\n    The address of the counterparty.\n    \"\"\"\n\n    street_line1: Annotated[\n        str | None,\n        Field(description=\"Street line 1 information.\"),\n    ] = None\n    street_line2: Annotated[\n        str | None,\n        Field(description=\"Street line 2 information.\"),\n    ] = None\n    region: Annotated[\n        str | None,\n        Field(description=\"The name of the region.\"),\n    ] = None\n    city: Annotated[\n        str | None,\n        Field(description=\"The name of the city.\"),\n    ] = None\n    country: Annotated[\n        CountryAlpha2,\n        Field(\n            description=\"The country of the counterparty as the 2-letter ISO 3166 code.\"\n        ),\n    ]\n    postcode: Annotated[\n        str,\n        Field(description=\"The postcode of the counterparty address.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.CreateCounterparty.Body.ModelIndividualName","title":"<code>ModelIndividualName</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The name of the individual counterparty. Use when company_name isn't specified.</p> Source code in <code>pyrevolut/api/counterparties/post/create_counterparty.py</code> <pre><code>class ModelIndividualName(BaseModel):\n    \"\"\"\n    The name of the individual counterparty.\n    Use when company_name isn't specified.\n    \"\"\"\n\n    first_name: Annotated[\n        str | None,\n        Field(description=\"The first name of the individual counterparty.\"),\n    ] = None\n    last_name: Annotated[\n        str | None,\n        Field(description=\"The last name of the individual counterparty.\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.CreateCounterparty.Body.check_inputs","title":"<code>check_inputs()</code>","text":"<p>Validate the input data.</p> Source code in <code>pyrevolut/api/counterparties/post/create_counterparty.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_inputs(self) -&gt; \"CreateCounterparty.Body\":\n    \"\"\"Validate the input data.\"\"\"\n\n    # Company name check\n    if self.profile_type == EnumProfileType.BUSINESS and (\n        self.individual_name is None or self.name is None\n    ):\n        assert (\n            self.company_name is not None\n        ), \"company_name is required for business profile type.\"\n\n    # Name check\n    if self.profile_type == EnumProfileType.PERSONAL:\n        assert (\n            self.name is not None\n        ), \"name is required for personal profile type.\"\n\n    # Profile type check\n    if self.profile_type is not None:\n        assert (\n            self.revtag is not None\n        ), \"revtag is required when profile_type is specified.\"\n    else:\n        assert (\n            self.revtag is None\n        ), \"revtag is not required when profile_type is not specified.\"\n\n    # Individual name check\n    # if self.company_name is None:\n    #     assert (\n    #         self.individual_name is not None\n    #     ), \"individual_name is required when company_name is not specified.\"\n\n    # Sort code check\n    if self.currency == \"GBP\":\n        assert (\n            self.sort_code is not None\n        ), \"sort_code is required for GBP accounts.\"\n\n    # Routing number check\n    if self.currency == \"USD\":\n        assert (\n            self.routing_number is not None\n        ), \"routing_number is required for USD accounts.\"\n\n    # IFSC check\n    if self.currency == \"INR\":\n        assert self.isfc is not None, \"isfc is required for INR accounts.\"\n\n    # BSB code check\n    if self.currency == \"AUD\":\n        assert (\n            self.bsb_code is not None\n        ), \"bsb_code is required for AUD accounts.\"\n\n    return self\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.CreateCounterparty.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceCounterparty</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/counterparties/post/create_counterparty.py</code> <pre><code>class Response(ResourceCounterparty):\n    \"\"\"Response model for the endpoint.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.ValidateAccountName","title":"<code>ValidateAccountName</code>","text":"<p>Use Confirmation of Payee (CoP) to validate a UK counterparty's account name against their account number and sort code when adding a counterparty or making a transfer to a new or existing counterparty.</p> Note <p>Confirmation of Payee is an account name checking system in the UK that helps clients to make sure payments aren't sent to the wrong bank or building society account.</p> <p>When performing the check, you must specify the account type by providing the name for either an individual (personal account) or a company (business account).</p> Caution <p>The CoP check does not protect you against all kinds of fraud. It only checks if the name you provided for an account matches that account's details. Even if the counterparty's details match, you should still exercise due caution when transferring funds.</p> <p>This functionality is only available to UK-based businesses.</p> Source code in <code>pyrevolut/api/counterparties/post/validate_account_name.py</code> <pre><code>class ValidateAccountName:\n    \"\"\"\n    Use Confirmation of Payee (CoP) to validate a UK counterparty's account name\n    against their account number and sort code when adding a counterparty or making a\n    transfer to a new or existing counterparty.\n\n    Note\n    ----\n    Confirmation of Payee is an account name checking system in the UK that helps clients\n    to make sure payments aren't sent to the wrong bank or building society account.\n\n    When performing the check, you must specify the account type by providing the name for either\n    an individual (personal account) or a company (business account).\n\n    Caution\n    -------\n    The CoP check does not protect you against all kinds of fraud. It only checks if the name you provided for an account matches that account's details.\n    Even if the counterparty's details match, you should still exercise due caution when transferring funds.\n\n    This functionality is only available to UK-based businesses.\n    \"\"\"\n\n    ROUTE = \"/1.0/account-name-validation\"\n\n    class Body(BaseModel):\n        \"\"\"\n        Request body for the endpoint.\n        \"\"\"\n\n        class ModelIndividualName(BaseModel):\n            \"\"\"The name of the individual counterparty. Use when company_name isn't specified.\"\"\"\n\n            first_name: Annotated[\n                str | None,\n                Field(description=\"The first name of the individual counterparty.\"),\n            ] = None\n            last_name: Annotated[\n                str | None,\n                Field(description=\"The last name of the individual counterparty.\"),\n            ] = None\n\n        account_no: Annotated[\n            str,\n            Field(\n                description=\"The account number of the counterparty.\",\n            ),\n        ]\n        sort_code: Annotated[\n            str,\n            Field(\n                description=\"The sort code of the counterparty's account.\",\n            ),\n        ]\n        company_name: Annotated[\n            str | None,\n            Field(\n                description=\"The name of the business counterparty. Use when individual_name is not specified.\",\n            ),\n        ] = None\n        individual_name: Annotated[\n            ModelIndividualName | None,\n            Field(\n                description=\"The name of the individual counterparty. Use when company_name is not specified.\",\n            ),\n        ] = None\n\n        @model_validator(mode=\"after\")\n        def check_inputs(self) -&gt; \"ValidateAccountName.Body\":\n            \"\"\"\n            Ensure that either the individual_name or company_name is provided.\n            \"\"\"\n            if not self.company_name and not self.individual_name:\n                raise ValueError(\n                    \"You must provide either the company_name or individual_name.\"\n                )\n            if self.company_name and self.individual_name:\n                raise ValueError(\n                    \"You must provide either the company_name or individual_name, not both.\"\n                )\n            return self\n\n    class Response(BaseModel):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        class ModelIndividualName(BaseModel):\n            \"\"\"The name of the individual counterparty. Use when company_name isn't specified.\"\"\"\n\n            first_name: Annotated[\n                str | None,\n                Field(description=\"The first name of the individual counterparty.\"),\n            ] = None\n            last_name: Annotated[\n                str | None,\n                Field(description=\"The last name of the individual counterparty.\"),\n            ] = None\n\n        class ModelReason(BaseModel):\n            \"\"\"\n            A code which explains why a given result was returned.\n            For example, it might happen that the details you provided match the account details,\n            but you specified the counterparty as an individual, and the account type is business.\n            \"\"\"\n\n            type: Annotated[\n                EnumAccountNameMatchReasonType | None,\n                Field(\n                    description=\"\"\"\n                    The reason type. Possible values:\n\n                        uk_cop:\n                            The CoP reason\n                    \"\"\",\n                ),\n            ] = None\n            code: Annotated[\n                EnumAccountNameMatchReasonCode | None,\n                Field(\n                    description=\"\"\"\n                    The reason code. Possible values:\n\n                        close_match:\n                            The provided name is similar to the account name, the account type is correct.\n                            The actual name is returned.\n                        individual_account_name_matched:\n                            The names match but the counterparty is an individual, not a business.\n                        company_account_name_matched:\n                            The names match but the counterparty is a business, not an individual.\n                        individual_account_close_match:\n                            The provided name is similar to the account name, and the account type is incorrect\n                            - the counterparty is an individual, not a business. The actual name is returned.\n                        company_account_close_match:\n                            The provided name is similar to the account name, and the account type is incorrect\n                            - the counterparty is a business, not an individual. The actual name is returned.\n                        not_matched:\n                            The account details don't match the provided values.\n                        account_does_not_exist:\n                            The account does not exist.\n                        account_switched:\n                            The account has been switched using the Current Account Switching Service.\n                            Please contact the recipient for updated account details.\n                        cannot_be_checked:\n                            The account cannot be checked.\n                    \"\"\",\n                ),\n            ] = None\n\n        result_code: Annotated[\n            EnumAccountNameMatchCode,\n            Field(\n                description=\"\"\"\n                The result of the account name check. Possible values:\n\n                    matched:\n                        The name and account type match the provided values.\n                    close_match:\n                        The name and account type are similar to the provided values.\n                        The actual values are returned.\n                    not_matched:\n                        The name and account type don't match the provided values.\n                    cannot_be_checked:\n                        The check cannot be performed and retries won't help.\n                        For example, the recipient's bank doesn't support CoP.\n                    temporarily_unavailable:\n                        The check cannot be performed right now.\n                        For example, the recipient's bank didn't respond to our request.\n                        You should retry the request later.\n                \"\"\"\n            ),\n        ]\n        reason: Annotated[\n            ModelReason | None,\n            Field(\n                description=\"\"\"\n                A code which explains why a given result was returned.\n                For example, it might happen that the details you provided match the account details,\n                but you specified the counterparty as an individual, and the account type is business.\n                \"\"\",\n            ),\n        ] = None\n        company_name: Annotated[\n            str | None,\n            Field(\n                description=\"The name of the business counterparty. Use when individual_name is not specified.\",\n            ),\n        ] = None\n        individual_name: Annotated[\n            ModelIndividualName | None,\n            Field(\n                description=\"The name of the individual counterparty. Use when company_name is not specified.\",\n            ),\n        ] = None\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.ValidateAccountName.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request body for the endpoint.</p> Source code in <code>pyrevolut/api/counterparties/post/validate_account_name.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    Request body for the endpoint.\n    \"\"\"\n\n    class ModelIndividualName(BaseModel):\n        \"\"\"The name of the individual counterparty. Use when company_name isn't specified.\"\"\"\n\n        first_name: Annotated[\n            str | None,\n            Field(description=\"The first name of the individual counterparty.\"),\n        ] = None\n        last_name: Annotated[\n            str | None,\n            Field(description=\"The last name of the individual counterparty.\"),\n        ] = None\n\n    account_no: Annotated[\n        str,\n        Field(\n            description=\"The account number of the counterparty.\",\n        ),\n    ]\n    sort_code: Annotated[\n        str,\n        Field(\n            description=\"The sort code of the counterparty's account.\",\n        ),\n    ]\n    company_name: Annotated[\n        str | None,\n        Field(\n            description=\"The name of the business counterparty. Use when individual_name is not specified.\",\n        ),\n    ] = None\n    individual_name: Annotated[\n        ModelIndividualName | None,\n        Field(\n            description=\"The name of the individual counterparty. Use when company_name is not specified.\",\n        ),\n    ] = None\n\n    @model_validator(mode=\"after\")\n    def check_inputs(self) -&gt; \"ValidateAccountName.Body\":\n        \"\"\"\n        Ensure that either the individual_name or company_name is provided.\n        \"\"\"\n        if not self.company_name and not self.individual_name:\n            raise ValueError(\n                \"You must provide either the company_name or individual_name.\"\n            )\n        if self.company_name and self.individual_name:\n            raise ValueError(\n                \"You must provide either the company_name or individual_name, not both.\"\n            )\n        return self\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.ValidateAccountName.Body.ModelIndividualName","title":"<code>ModelIndividualName</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The name of the individual counterparty. Use when company_name isn't specified.</p> Source code in <code>pyrevolut/api/counterparties/post/validate_account_name.py</code> <pre><code>class ModelIndividualName(BaseModel):\n    \"\"\"The name of the individual counterparty. Use when company_name isn't specified.\"\"\"\n\n    first_name: Annotated[\n        str | None,\n        Field(description=\"The first name of the individual counterparty.\"),\n    ] = None\n    last_name: Annotated[\n        str | None,\n        Field(description=\"The last name of the individual counterparty.\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.ValidateAccountName.Body.check_inputs","title":"<code>check_inputs()</code>","text":"<p>Ensure that either the individual_name or company_name is provided.</p> Source code in <code>pyrevolut/api/counterparties/post/validate_account_name.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_inputs(self) -&gt; \"ValidateAccountName.Body\":\n    \"\"\"\n    Ensure that either the individual_name or company_name is provided.\n    \"\"\"\n    if not self.company_name and not self.individual_name:\n        raise ValueError(\n            \"You must provide either the company_name or individual_name.\"\n        )\n    if self.company_name and self.individual_name:\n        raise ValueError(\n            \"You must provide either the company_name or individual_name, not both.\"\n        )\n    return self\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.ValidateAccountName.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/counterparties/post/validate_account_name.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    class ModelIndividualName(BaseModel):\n        \"\"\"The name of the individual counterparty. Use when company_name isn't specified.\"\"\"\n\n        first_name: Annotated[\n            str | None,\n            Field(description=\"The first name of the individual counterparty.\"),\n        ] = None\n        last_name: Annotated[\n            str | None,\n            Field(description=\"The last name of the individual counterparty.\"),\n        ] = None\n\n    class ModelReason(BaseModel):\n        \"\"\"\n        A code which explains why a given result was returned.\n        For example, it might happen that the details you provided match the account details,\n        but you specified the counterparty as an individual, and the account type is business.\n        \"\"\"\n\n        type: Annotated[\n            EnumAccountNameMatchReasonType | None,\n            Field(\n                description=\"\"\"\n                The reason type. Possible values:\n\n                    uk_cop:\n                        The CoP reason\n                \"\"\",\n            ),\n        ] = None\n        code: Annotated[\n            EnumAccountNameMatchReasonCode | None,\n            Field(\n                description=\"\"\"\n                The reason code. Possible values:\n\n                    close_match:\n                        The provided name is similar to the account name, the account type is correct.\n                        The actual name is returned.\n                    individual_account_name_matched:\n                        The names match but the counterparty is an individual, not a business.\n                    company_account_name_matched:\n                        The names match but the counterparty is a business, not an individual.\n                    individual_account_close_match:\n                        The provided name is similar to the account name, and the account type is incorrect\n                        - the counterparty is an individual, not a business. The actual name is returned.\n                    company_account_close_match:\n                        The provided name is similar to the account name, and the account type is incorrect\n                        - the counterparty is a business, not an individual. The actual name is returned.\n                    not_matched:\n                        The account details don't match the provided values.\n                    account_does_not_exist:\n                        The account does not exist.\n                    account_switched:\n                        The account has been switched using the Current Account Switching Service.\n                        Please contact the recipient for updated account details.\n                    cannot_be_checked:\n                        The account cannot be checked.\n                \"\"\",\n            ),\n        ] = None\n\n    result_code: Annotated[\n        EnumAccountNameMatchCode,\n        Field(\n            description=\"\"\"\n            The result of the account name check. Possible values:\n\n                matched:\n                    The name and account type match the provided values.\n                close_match:\n                    The name and account type are similar to the provided values.\n                    The actual values are returned.\n                not_matched:\n                    The name and account type don't match the provided values.\n                cannot_be_checked:\n                    The check cannot be performed and retries won't help.\n                    For example, the recipient's bank doesn't support CoP.\n                temporarily_unavailable:\n                    The check cannot be performed right now.\n                    For example, the recipient's bank didn't respond to our request.\n                    You should retry the request later.\n            \"\"\"\n        ),\n    ]\n    reason: Annotated[\n        ModelReason | None,\n        Field(\n            description=\"\"\"\n            A code which explains why a given result was returned.\n            For example, it might happen that the details you provided match the account details,\n            but you specified the counterparty as an individual, and the account type is business.\n            \"\"\",\n        ),\n    ] = None\n    company_name: Annotated[\n        str | None,\n        Field(\n            description=\"The name of the business counterparty. Use when individual_name is not specified.\",\n        ),\n    ] = None\n    individual_name: Annotated[\n        ModelIndividualName | None,\n        Field(\n            description=\"The name of the individual counterparty. Use when company_name is not specified.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.ValidateAccountName.Response.ModelIndividualName","title":"<code>ModelIndividualName</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The name of the individual counterparty. Use when company_name isn't specified.</p> Source code in <code>pyrevolut/api/counterparties/post/validate_account_name.py</code> <pre><code>class ModelIndividualName(BaseModel):\n    \"\"\"The name of the individual counterparty. Use when company_name isn't specified.\"\"\"\n\n    first_name: Annotated[\n        str | None,\n        Field(description=\"The first name of the individual counterparty.\"),\n    ] = None\n    last_name: Annotated[\n        str | None,\n        Field(description=\"The last name of the individual counterparty.\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.post.ValidateAccountName.Response.ModelReason","title":"<code>ModelReason</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A code which explains why a given result was returned. For example, it might happen that the details you provided match the account details, but you specified the counterparty as an individual, and the account type is business.</p> Source code in <code>pyrevolut/api/counterparties/post/validate_account_name.py</code> <pre><code>class ModelReason(BaseModel):\n    \"\"\"\n    A code which explains why a given result was returned.\n    For example, it might happen that the details you provided match the account details,\n    but you specified the counterparty as an individual, and the account type is business.\n    \"\"\"\n\n    type: Annotated[\n        EnumAccountNameMatchReasonType | None,\n        Field(\n            description=\"\"\"\n            The reason type. Possible values:\n\n                uk_cop:\n                    The CoP reason\n            \"\"\",\n        ),\n    ] = None\n    code: Annotated[\n        EnumAccountNameMatchReasonCode | None,\n        Field(\n            description=\"\"\"\n            The reason code. Possible values:\n\n                close_match:\n                    The provided name is similar to the account name, the account type is correct.\n                    The actual name is returned.\n                individual_account_name_matched:\n                    The names match but the counterparty is an individual, not a business.\n                company_account_name_matched:\n                    The names match but the counterparty is a business, not an individual.\n                individual_account_close_match:\n                    The provided name is similar to the account name, and the account type is incorrect\n                    - the counterparty is an individual, not a business. The actual name is returned.\n                company_account_close_match:\n                    The provided name is similar to the account name, and the account type is incorrect\n                    - the counterparty is a business, not an individual. The actual name is returned.\n                not_matched:\n                    The account details don't match the provided values.\n                account_does_not_exist:\n                    The account does not exist.\n                account_switched:\n                    The account has been switched using the Current Account Switching Service.\n                    Please contact the recipient for updated account details.\n                cannot_be_checked:\n                    The account cannot be checked.\n            \"\"\",\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.delete.DeleteCounterparty","title":"<code>DeleteCounterparty</code>","text":"<p>Delete a counterparty with the given ID. When a counterparty is deleted, you cannot make any payments to the counterparty.</p> Source code in <code>pyrevolut/api/counterparties/delete/delete_counterparty.py</code> <pre><code>class DeleteCounterparty:\n    \"\"\"Delete a counterparty with the given ID.\n    When a counterparty is deleted, you cannot make any payments to the counterparty.\n    \"\"\"\n\n    ROUTE = \"/1.0/counterparty/{counterparty_id}\"\n\n    class Params(BaseModel):\n        \"\"\"\n        Query parameters for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.delete.DeleteCounterparty.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/counterparties/delete/delete_counterparty.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    Query parameters for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/counterparties/pydantic/#pyrevolut.api.counterparties.delete.DeleteCounterparty.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/counterparties/delete/delete_counterparty.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/counterparties/synchronous/","title":"Counterparties Synchronous Endpoints","text":"<p>This <code>Counterparties</code> endpoint provides methods to interact with the counterparties of the authenticated user.</p> <p>Example usage of the Counterparties endpoint object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    counterparties = client.Counterparties.get_all_counterparties()\n    print(counterparties)\n</code></pre>"},{"location":"code_reference/api/counterparties/synchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesSync","title":"<code>EndpointCounterpartiesSync</code>","text":"<p>               Bases: <code>BaseEndpointSync</code></p> <p>The Counterparties API</p> <p>Manage counterparties that you intend to transact with.</p> <p>Request and response examples can vary based on the account provider's location and type of the counterparty.</p> <p>In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties. Therefore, to help you simulate Create a counterparty requests, we have created some test accounts for counterparties of profile type personal.</p> <p>To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:</p> <p>Test User 1 &amp; john1pvki Test User 2 &amp; john2pvki ... Test User 9 &amp; john9pvki</p> Source code in <code>pyrevolut/api/counterparties/endpoint/synchronous.py</code> <pre><code>class EndpointCounterpartiesSync(BaseEndpointSync):\n    \"\"\"The Counterparties API\n\n    Manage counterparties that you intend to transact with.\n\n    Request and response examples can vary based on the account provider's\n    location and type of the counterparty.\n\n    In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties.\n    Therefore, to help you simulate Create a counterparty requests, we have created some\n    test accounts for counterparties of profile type personal.\n\n    To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:\n\n    Test User 1 &amp; john1pvki\n    Test User 2 &amp; john2pvki\n    ...\n    Test User 9 &amp; john9pvki\n    \"\"\"\n\n    def get_all_counterparties(\n        self,\n        name: str | None = None,\n        account_no: str | None = None,\n        sort_code: str | None = None,\n        iban: str | None = None,\n        bic: str | None = None,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        limit: int | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfCounterparties.Response]:\n        \"\"\"\n        Get all the counterparties that you have created, or use the query parameters to filter the results.\n\n        The counterparties are sorted by the created_at date in reverse chronological order.\n\n        The returned counterparties are paginated. The maximum number of counterparties returned per page\n        is specified by the limit parameter. To get to the next page, make a new request and use the\n        created_at date of the last counterparty returned in the previous response.\n\n        Parameters\n        ----------\n        name : str | None\n            The name of the counterparty to retrieve. It does not need to be an exact match,\n            partial match is also supported.\n        account_no : str | None\n            The exact account number of the counterparty to retrieve.\n        sort_code : str | None\n            The exact sort code of the counterparty to retrieve.\n            Only allowed in combination with the account_no parameter.\n        iban : str | None\n            The exact IBAN of the counterparty to retrieve.\n        bic : str | None\n            The exact BIC of the counterparty to retrieve. Only allowed in combination with the iban parameter.\n        created_before : datetime | DateTime | str | int | float | None\n            Retrieves counterparties with created_at &lt; created_before.\n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n        limit : int | None\n            The maximum number of counterparties returned per page.\n            To get to the next page, make a new request and use the\n            created_at date of the last card returned in the previous\n            response as the value for created_before.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfCounterparties.Response]\n            The list of all counterparties that you have created.\n        \"\"\"\n        endpoint = RetrieveListOfCounterparties\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            name=name,\n            account_no=account_no,\n            sort_code=sort_code,\n            iban=iban,\n            bic=bic,\n            created_before=created_before,\n            limit=limit,\n        )\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_counterparty(\n        self,\n        counterparty_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveCounterparty.Response:\n        \"\"\"Get the information about a specific counterparty by ID.\n\n        Parameters\n        ----------\n        counterparty_id : UUID\n            The ID of the counterparty to retrieve.\n\n        Returns\n        -------\n        dict | RetrieveCounterparty.Response\n            The information about the counterparty.\n        \"\"\"\n        endpoint = RetrieveCounterparty\n        path = endpoint.ROUTE.format(counterparty_id=counterparty_id)\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def create_counterparty(\n        self,\n        company_name: str | None = None,\n        profile_type: EnumProfileType | None = None,\n        name: str | None = None,\n        individual_first_name: str | None = None,\n        individual_last_name: str | None = None,\n        bank_country: str | None = None,\n        currency: str | None = None,\n        revtag: str | None = None,\n        account_no: str | None = None,\n        iban: str | None = None,\n        sort_code: str | None = None,\n        routing_number: str | None = None,\n        bic: str | None = None,\n        clabe: str | None = None,\n        isfc: str | None = None,\n        bsb_code: str | None = None,\n        address_street_line1: str | None = None,\n        address_street_line2: str | None = None,\n        address_region: str | None = None,\n        address_city: str | None = None,\n        address_country: str | None = None,\n        address_postcode: str | None = None,\n        **kwargs,\n    ) -&gt; dict | CreateCounterparty.Response:\n        \"\"\"\n        Create a new counterparty to transact with.\n\n        In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties.\n        To help you simulate Create a counterparty requests for counterparties of profile type personal,\n        we created some test accounts. Look inside for test Revtags.\n\n        To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:\n\n            Test User 1 &amp; john1pvki\n            Test User 2 &amp; john2pvki\n            ...\n            Test User 9 &amp; john9pvki\n\n        Parameters\n        ----------\n        company_name : str | None\n            The name of the company counterparty.\n            Use when individual_name or name isn't specified and profile_type is business.\n        profile_type : EnumProfileType | None\n            The type of the Revolut profile. Used when adding an existing Revolut user via Revtag.\n        name : str | None\n            The name of the counterparty that you create for an existing Revolut user via Revtag.\n            Provide the value only when you specify personal for profile_type.\n        individual_first_name : str | None\n            The first name of the individual counterparty.\n            Use when company_name isn't specified.\n        individual_last_name : str | None\n            The last name of the individual counterparty.\n            Use when company_name isn't specified.\n        bank_country : str | None\n            The country of the counterparty's bank as the 2-letter ISO 3166 code.\n        currency : str | None\n            ISO 4217 currency code in upper case.\n        revtag : str | None\n            The Revtag of the counterparty to add.\n        account_no : str | None\n            The bank account number of the counterparty.\n        iban : str | None\n            The IBAN number of the counterparty's account. This field is displayed for IBAN countries.\n        sort_code : str | None\n            The sort code of the counterparty's bank. This field is displayed for GBP accounts.\n        routing_number : str | None\n            The routing number of the counterparty's bank. This field is displayed for USD accounts.\n        bic : str | None\n            The BIC number of the counterparty's account. This field is required for non-SEPA IBAN/SWIFT.\n        clabe : str | None\n            The CLABE number of the counterparty's account. This field is required for SWIFT MX.\n        isfc : str | None\n            The ISFC number of the counterparty's account. This field is required for INR accounts.\n        bsb_code : str | None\n            The BSB code of the counterparty's account. This field is required for AUD accounts.\n        address_street_line1 : str | None\n            Street line 1 information.\n        address_street_line2 : str | None\n            Street line 2 information.\n        address_region : str | None\n            The name of the region.\n        address_city : str | None\n            The name of the city.\n        address_country : str | None\n            The country of the counterparty's address as the 2-letter ISO 3166 code.\n        address_postcode : str | None\n            The postcode of the counterparty's address.\n\n        Returns\n        -------\n        dict | CreateCounterparty.Response\n            A dict with the information about the created counterparty.\n        \"\"\"\n        endpoint = CreateCounterparty\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            company_name=company_name,\n            profile_type=profile_type,\n            name=name,\n            individual_name=(\n                endpoint.Body.ModelIndividualName(\n                    first_name=individual_first_name,\n                    last_name=individual_last_name,\n                )\n                if individual_first_name is not None or individual_last_name is not None\n                else None\n            ),\n            bank_country=bank_country,\n            currency=currency,\n            revtag=revtag,\n            account_no=account_no,\n            iban=iban,\n            sort_code=sort_code,\n            routing_number=routing_number,\n            bic=bic,\n            clabe=clabe,\n            isfc=isfc,\n            bsb_code=bsb_code,\n            address=(\n                endpoint.Body.ModelAddress(\n                    street_line1=address_street_line1,\n                    street_line2=address_street_line2,\n                    region=address_region,\n                    city=address_city,\n                    country=address_country,\n                    postcode=address_postcode,\n                )\n                if address_country is not None and address_postcode is not None\n                else None\n            ),\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def validate_account_name(\n        self,\n        account_no: str,\n        sort_code: str,\n        company_name: str | None = None,\n        individual_first_name: str | None = None,\n        individual_last_name: str | None = None,\n        **kwargs,\n    ) -&gt; dict | ValidateAccountName.Response:\n        \"\"\"\n        Use Confirmation of Payee (CoP) to validate a UK counterparty's account name\n        against their account number and sort code when adding a counterparty or making a\n        transfer to a new or existing counterparty.\n\n        Note\n        ----\n        Confirmation of Payee is an account name checking system in the UK that helps clients\n        to make sure payments aren't sent to the wrong bank or building society account.\n\n        When performing the check, you must specify the account type by providing the name for either\n        an individual (personal account) or a company (business account).\n\n        Caution\n        -------\n        The CoP check does not protect you against all kinds of fraud. It only checks if the name you provided for an account matches that account's details.\n        Even if the counterparty's details match, you should still exercise due caution when transferring funds.\n\n        This functionality is only available to UK-based businesses.\n\n        Parameters\n        ----------\n        account_no : str\n            The account number of the counterparty.\n        sort_code : str\n            The sort code of the counterparty's account.\n        company_name : str | None\n            The name of the business counterparty. Use when individual_name is not specified.\n        individual_first_name : str | None\n            The first name of the individual counterparty.\n            Use when company_name isn't specified.\n        individual_last_name : str | None\n            The last name of the individual counterparty.\n            Use when company_name isn't specified.\n\n        Returns\n        -------\n        dict | ValidateAccountName.Response\n            A dict with the information about the validated account name.\n        \"\"\"\n        endpoint = ValidateAccountName\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            account_no=account_no,\n            sort_code=sort_code,\n            company_name=company_name,\n            individual_name=(\n                endpoint.Body.ModelIndividualName(\n                    first_name=individual_first_name,\n                    last_name=individual_last_name,\n                )\n                if individual_first_name is not None or individual_last_name is not None\n                else None\n            ),\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def delete_counterparty(\n        self,\n        counterparty_id: UUID,\n        **kwargs,\n    ) -&gt; dict | DeleteCounterparty.Response:\n        \"\"\"Delete a counterparty with the given ID.\n        When a counterparty is deleted, you cannot make any payments to the counterparty.\n\n        Parameters\n        ----------\n        counterparty_id : UUID\n            The ID of the counterparty to delete.\n\n        Returns\n        -------\n        dict | DeleteCounterparty.Response\n            An empty dict.\n        \"\"\"\n        endpoint = DeleteCounterparty\n        path = endpoint.ROUTE.format(counterparty_id=counterparty_id)\n        params = endpoint.Params()\n\n        return self.client.delete(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/counterparties/synchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesSync.create_counterparty","title":"<code>create_counterparty(company_name=None, profile_type=None, name=None, individual_first_name=None, individual_last_name=None, bank_country=None, currency=None, revtag=None, account_no=None, iban=None, sort_code=None, routing_number=None, bic=None, clabe=None, isfc=None, bsb_code=None, address_street_line1=None, address_street_line2=None, address_region=None, address_city=None, address_country=None, address_postcode=None, **kwargs)</code>","text":"<p>Create a new counterparty to transact with.</p> <p>In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties. To help you simulate Create a counterparty requests for counterparties of profile type personal, we created some test accounts. Look inside for test Revtags.</p> <p>To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:</p> <pre><code>Test User 1 &amp; john1pvki\nTest User 2 &amp; john2pvki\n...\nTest User 9 &amp; john9pvki\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>company_name</code> <code>str | None</code> <p>The name of the company counterparty. Use when individual_name or name isn't specified and profile_type is business.</p> <code>None</code> <code>profile_type</code> <code>EnumProfileType | None</code> <p>The type of the Revolut profile. Used when adding an existing Revolut user via Revtag.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>The name of the counterparty that you create for an existing Revolut user via Revtag. Provide the value only when you specify personal for profile_type.</p> <code>None</code> <code>individual_first_name</code> <code>str | None</code> <p>The first name of the individual counterparty. Use when company_name isn't specified.</p> <code>None</code> <code>individual_last_name</code> <code>str | None</code> <p>The last name of the individual counterparty. Use when company_name isn't specified.</p> <code>None</code> <code>bank_country</code> <code>str | None</code> <p>The country of the counterparty's bank as the 2-letter ISO 3166 code.</p> <code>None</code> <code>currency</code> <code>str | None</code> <p>ISO 4217 currency code in upper case.</p> <code>None</code> <code>revtag</code> <code>str | None</code> <p>The Revtag of the counterparty to add.</p> <code>None</code> <code>account_no</code> <code>str | None</code> <p>The bank account number of the counterparty.</p> <code>None</code> <code>iban</code> <code>str | None</code> <p>The IBAN number of the counterparty's account. This field is displayed for IBAN countries.</p> <code>None</code> <code>sort_code</code> <code>str | None</code> <p>The sort code of the counterparty's bank. This field is displayed for GBP accounts.</p> <code>None</code> <code>routing_number</code> <code>str | None</code> <p>The routing number of the counterparty's bank. This field is displayed for USD accounts.</p> <code>None</code> <code>bic</code> <code>str | None</code> <p>The BIC number of the counterparty's account. This field is required for non-SEPA IBAN/SWIFT.</p> <code>None</code> <code>clabe</code> <code>str | None</code> <p>The CLABE number of the counterparty's account. This field is required for SWIFT MX.</p> <code>None</code> <code>isfc</code> <code>str | None</code> <p>The ISFC number of the counterparty's account. This field is required for INR accounts.</p> <code>None</code> <code>bsb_code</code> <code>str | None</code> <p>The BSB code of the counterparty's account. This field is required for AUD accounts.</p> <code>None</code> <code>address_street_line1</code> <code>str | None</code> <p>Street line 1 information.</p> <code>None</code> <code>address_street_line2</code> <code>str | None</code> <p>Street line 2 information.</p> <code>None</code> <code>address_region</code> <code>str | None</code> <p>The name of the region.</p> <code>None</code> <code>address_city</code> <code>str | None</code> <p>The name of the city.</p> <code>None</code> <code>address_country</code> <code>str | None</code> <p>The country of the counterparty's address as the 2-letter ISO 3166 code.</p> <code>None</code> <code>address_postcode</code> <code>str | None</code> <p>The postcode of the counterparty's address.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the created counterparty.</p> Source code in <code>pyrevolut/api/counterparties/endpoint/synchronous.py</code> <pre><code>def create_counterparty(\n    self,\n    company_name: str | None = None,\n    profile_type: EnumProfileType | None = None,\n    name: str | None = None,\n    individual_first_name: str | None = None,\n    individual_last_name: str | None = None,\n    bank_country: str | None = None,\n    currency: str | None = None,\n    revtag: str | None = None,\n    account_no: str | None = None,\n    iban: str | None = None,\n    sort_code: str | None = None,\n    routing_number: str | None = None,\n    bic: str | None = None,\n    clabe: str | None = None,\n    isfc: str | None = None,\n    bsb_code: str | None = None,\n    address_street_line1: str | None = None,\n    address_street_line2: str | None = None,\n    address_region: str | None = None,\n    address_city: str | None = None,\n    address_country: str | None = None,\n    address_postcode: str | None = None,\n    **kwargs,\n) -&gt; dict | CreateCounterparty.Response:\n    \"\"\"\n    Create a new counterparty to transact with.\n\n    In the Sandbox environment, you cannot add real people and businesses as Revolut counterparties.\n    To help you simulate Create a counterparty requests for counterparties of profile type personal,\n    we created some test accounts. Look inside for test Revtags.\n\n    To add a counterparty via Revtag, use one of these pairs for the name and revtag fields respectively:\n\n        Test User 1 &amp; john1pvki\n        Test User 2 &amp; john2pvki\n        ...\n        Test User 9 &amp; john9pvki\n\n    Parameters\n    ----------\n    company_name : str | None\n        The name of the company counterparty.\n        Use when individual_name or name isn't specified and profile_type is business.\n    profile_type : EnumProfileType | None\n        The type of the Revolut profile. Used when adding an existing Revolut user via Revtag.\n    name : str | None\n        The name of the counterparty that you create for an existing Revolut user via Revtag.\n        Provide the value only when you specify personal for profile_type.\n    individual_first_name : str | None\n        The first name of the individual counterparty.\n        Use when company_name isn't specified.\n    individual_last_name : str | None\n        The last name of the individual counterparty.\n        Use when company_name isn't specified.\n    bank_country : str | None\n        The country of the counterparty's bank as the 2-letter ISO 3166 code.\n    currency : str | None\n        ISO 4217 currency code in upper case.\n    revtag : str | None\n        The Revtag of the counterparty to add.\n    account_no : str | None\n        The bank account number of the counterparty.\n    iban : str | None\n        The IBAN number of the counterparty's account. This field is displayed for IBAN countries.\n    sort_code : str | None\n        The sort code of the counterparty's bank. This field is displayed for GBP accounts.\n    routing_number : str | None\n        The routing number of the counterparty's bank. This field is displayed for USD accounts.\n    bic : str | None\n        The BIC number of the counterparty's account. This field is required for non-SEPA IBAN/SWIFT.\n    clabe : str | None\n        The CLABE number of the counterparty's account. This field is required for SWIFT MX.\n    isfc : str | None\n        The ISFC number of the counterparty's account. This field is required for INR accounts.\n    bsb_code : str | None\n        The BSB code of the counterparty's account. This field is required for AUD accounts.\n    address_street_line1 : str | None\n        Street line 1 information.\n    address_street_line2 : str | None\n        Street line 2 information.\n    address_region : str | None\n        The name of the region.\n    address_city : str | None\n        The name of the city.\n    address_country : str | None\n        The country of the counterparty's address as the 2-letter ISO 3166 code.\n    address_postcode : str | None\n        The postcode of the counterparty's address.\n\n    Returns\n    -------\n    dict | CreateCounterparty.Response\n        A dict with the information about the created counterparty.\n    \"\"\"\n    endpoint = CreateCounterparty\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        company_name=company_name,\n        profile_type=profile_type,\n        name=name,\n        individual_name=(\n            endpoint.Body.ModelIndividualName(\n                first_name=individual_first_name,\n                last_name=individual_last_name,\n            )\n            if individual_first_name is not None or individual_last_name is not None\n            else None\n        ),\n        bank_country=bank_country,\n        currency=currency,\n        revtag=revtag,\n        account_no=account_no,\n        iban=iban,\n        sort_code=sort_code,\n        routing_number=routing_number,\n        bic=bic,\n        clabe=clabe,\n        isfc=isfc,\n        bsb_code=bsb_code,\n        address=(\n            endpoint.Body.ModelAddress(\n                street_line1=address_street_line1,\n                street_line2=address_street_line2,\n                region=address_region,\n                city=address_city,\n                country=address_country,\n                postcode=address_postcode,\n            )\n            if address_country is not None and address_postcode is not None\n            else None\n        ),\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/counterparties/synchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesSync.delete_counterparty","title":"<code>delete_counterparty(counterparty_id, **kwargs)</code>","text":"<p>Delete a counterparty with the given ID. When a counterparty is deleted, you cannot make any payments to the counterparty.</p> <p>Parameters:</p> Name Type Description Default <code>counterparty_id</code> <code>UUID</code> <p>The ID of the counterparty to delete.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dict.</p> Source code in <code>pyrevolut/api/counterparties/endpoint/synchronous.py</code> <pre><code>def delete_counterparty(\n    self,\n    counterparty_id: UUID,\n    **kwargs,\n) -&gt; dict | DeleteCounterparty.Response:\n    \"\"\"Delete a counterparty with the given ID.\n    When a counterparty is deleted, you cannot make any payments to the counterparty.\n\n    Parameters\n    ----------\n    counterparty_id : UUID\n        The ID of the counterparty to delete.\n\n    Returns\n    -------\n    dict | DeleteCounterparty.Response\n        An empty dict.\n    \"\"\"\n    endpoint = DeleteCounterparty\n    path = endpoint.ROUTE.format(counterparty_id=counterparty_id)\n    params = endpoint.Params()\n\n    return self.client.delete(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/counterparties/synchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesSync.get_all_counterparties","title":"<code>get_all_counterparties(name=None, account_no=None, sort_code=None, iban=None, bic=None, created_before=None, limit=None, **kwargs)</code>","text":"<p>Get all the counterparties that you have created, or use the query parameters to filter the results.</p> <p>The counterparties are sorted by the created_at date in reverse chronological order.</p> <p>The returned counterparties are paginated. The maximum number of counterparties returned per page is specified by the limit parameter. To get to the next page, make a new request and use the created_at date of the last counterparty returned in the previous response.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the counterparty to retrieve. It does not need to be an exact match, partial match is also supported.</p> <code>None</code> <code>account_no</code> <code>str | None</code> <p>The exact account number of the counterparty to retrieve.</p> <code>None</code> <code>sort_code</code> <code>str | None</code> <p>The exact sort code of the counterparty to retrieve. Only allowed in combination with the account_no parameter.</p> <code>None</code> <code>iban</code> <code>str | None</code> <p>The exact IBAN of the counterparty to retrieve.</p> <code>None</code> <code>bic</code> <code>str | None</code> <p>The exact BIC of the counterparty to retrieve. Only allowed in combination with the iban parameter.</p> <code>None</code> <code>created_before</code> <code>datetime | DateTime | str | int | float | None</code> <p>Retrieves counterparties with created_at &lt; created_before. The default value is the current date and time at which you are calling the endpoint. Provided in ISO 8601 format.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>The maximum number of counterparties returned per page. To get to the next page, make a new request and use the created_at date of the last card returned in the previous response as the value for created_before.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all counterparties that you have created.</p> Source code in <code>pyrevolut/api/counterparties/endpoint/synchronous.py</code> <pre><code>def get_all_counterparties(\n    self,\n    name: str | None = None,\n    account_no: str | None = None,\n    sort_code: str | None = None,\n    iban: str | None = None,\n    bic: str | None = None,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    limit: int | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfCounterparties.Response]:\n    \"\"\"\n    Get all the counterparties that you have created, or use the query parameters to filter the results.\n\n    The counterparties are sorted by the created_at date in reverse chronological order.\n\n    The returned counterparties are paginated. The maximum number of counterparties returned per page\n    is specified by the limit parameter. To get to the next page, make a new request and use the\n    created_at date of the last counterparty returned in the previous response.\n\n    Parameters\n    ----------\n    name : str | None\n        The name of the counterparty to retrieve. It does not need to be an exact match,\n        partial match is also supported.\n    account_no : str | None\n        The exact account number of the counterparty to retrieve.\n    sort_code : str | None\n        The exact sort code of the counterparty to retrieve.\n        Only allowed in combination with the account_no parameter.\n    iban : str | None\n        The exact IBAN of the counterparty to retrieve.\n    bic : str | None\n        The exact BIC of the counterparty to retrieve. Only allowed in combination with the iban parameter.\n    created_before : datetime | DateTime | str | int | float | None\n        Retrieves counterparties with created_at &lt; created_before.\n        The default value is the current date and time at which you are calling the endpoint.\n        Provided in ISO 8601 format.\n    limit : int | None\n        The maximum number of counterparties returned per page.\n        To get to the next page, make a new request and use the\n        created_at date of the last card returned in the previous\n        response as the value for created_before.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfCounterparties.Response]\n        The list of all counterparties that you have created.\n    \"\"\"\n    endpoint = RetrieveListOfCounterparties\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        name=name,\n        account_no=account_no,\n        sort_code=sort_code,\n        iban=iban,\n        bic=bic,\n        created_before=created_before,\n        limit=limit,\n    )\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/counterparties/synchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesSync.get_counterparty","title":"<code>get_counterparty(counterparty_id, **kwargs)</code>","text":"<p>Get the information about a specific counterparty by ID.</p> <p>Parameters:</p> Name Type Description Default <code>counterparty_id</code> <code>UUID</code> <p>The ID of the counterparty to retrieve.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The information about the counterparty.</p> Source code in <code>pyrevolut/api/counterparties/endpoint/synchronous.py</code> <pre><code>def get_counterparty(\n    self,\n    counterparty_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveCounterparty.Response:\n    \"\"\"Get the information about a specific counterparty by ID.\n\n    Parameters\n    ----------\n    counterparty_id : UUID\n        The ID of the counterparty to retrieve.\n\n    Returns\n    -------\n    dict | RetrieveCounterparty.Response\n        The information about the counterparty.\n    \"\"\"\n    endpoint = RetrieveCounterparty\n    path = endpoint.ROUTE.format(counterparty_id=counterparty_id)\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/counterparties/synchronous/#pyrevolut.api.counterparties.endpoint.EndpointCounterpartiesSync.validate_account_name","title":"<code>validate_account_name(account_no, sort_code, company_name=None, individual_first_name=None, individual_last_name=None, **kwargs)</code>","text":"<p>Use Confirmation of Payee (CoP) to validate a UK counterparty's account name against their account number and sort code when adding a counterparty or making a transfer to a new or existing counterparty.</p> Note <p>Confirmation of Payee is an account name checking system in the UK that helps clients to make sure payments aren't sent to the wrong bank or building society account.</p> <p>When performing the check, you must specify the account type by providing the name for either an individual (personal account) or a company (business account).</p> Caution <p>The CoP check does not protect you against all kinds of fraud. It only checks if the name you provided for an account matches that account's details. Even if the counterparty's details match, you should still exercise due caution when transferring funds.</p> <p>This functionality is only available to UK-based businesses.</p> <p>Parameters:</p> Name Type Description Default <code>account_no</code> <code>str</code> <p>The account number of the counterparty.</p> required <code>sort_code</code> <code>str</code> <p>The sort code of the counterparty's account.</p> required <code>company_name</code> <code>str | None</code> <p>The name of the business counterparty. Use when individual_name is not specified.</p> <code>None</code> <code>individual_first_name</code> <code>str | None</code> <p>The first name of the individual counterparty. Use when company_name isn't specified.</p> <code>None</code> <code>individual_last_name</code> <code>str | None</code> <p>The last name of the individual counterparty. Use when company_name isn't specified.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the validated account name.</p> Source code in <code>pyrevolut/api/counterparties/endpoint/synchronous.py</code> <pre><code>def validate_account_name(\n    self,\n    account_no: str,\n    sort_code: str,\n    company_name: str | None = None,\n    individual_first_name: str | None = None,\n    individual_last_name: str | None = None,\n    **kwargs,\n) -&gt; dict | ValidateAccountName.Response:\n    \"\"\"\n    Use Confirmation of Payee (CoP) to validate a UK counterparty's account name\n    against their account number and sort code when adding a counterparty or making a\n    transfer to a new or existing counterparty.\n\n    Note\n    ----\n    Confirmation of Payee is an account name checking system in the UK that helps clients\n    to make sure payments aren't sent to the wrong bank or building society account.\n\n    When performing the check, you must specify the account type by providing the name for either\n    an individual (personal account) or a company (business account).\n\n    Caution\n    -------\n    The CoP check does not protect you against all kinds of fraud. It only checks if the name you provided for an account matches that account's details.\n    Even if the counterparty's details match, you should still exercise due caution when transferring funds.\n\n    This functionality is only available to UK-based businesses.\n\n    Parameters\n    ----------\n    account_no : str\n        The account number of the counterparty.\n    sort_code : str\n        The sort code of the counterparty's account.\n    company_name : str | None\n        The name of the business counterparty. Use when individual_name is not specified.\n    individual_first_name : str | None\n        The first name of the individual counterparty.\n        Use when company_name isn't specified.\n    individual_last_name : str | None\n        The last name of the individual counterparty.\n        Use when company_name isn't specified.\n\n    Returns\n    -------\n    dict | ValidateAccountName.Response\n        A dict with the information about the validated account name.\n    \"\"\"\n    endpoint = ValidateAccountName\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        account_no=account_no,\n        sort_code=sort_code,\n        company_name=company_name,\n        individual_name=(\n            endpoint.Body.ModelIndividualName(\n                first_name=individual_first_name,\n                last_name=individual_last_name,\n            )\n            if individual_first_name is not None or individual_last_name is not None\n            else None\n        ),\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/asynchronous/","title":"Foreign Exchange Asynchronous Endpoints","text":"<p>This <code>Foreign Exchange</code> endpoint provides asynchronous methods to interact with the foreign exchange of the authenticated user.</p> <p>Example usage of the Foreign Exchange endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        rate = await client.ForeignExchange.get_exchange_rate(\n            from_currency=\"USD\",\n            to_currency=\"EUR\",\n            amount=1.0,\n        )\n        print(rate)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/asynchronous/#pyrevolut.api.foreign_exchange.endpoint.EndpointForeignExchangeAsync","title":"<code>EndpointForeignExchangeAsync</code>","text":"<p>               Bases: <code>BaseEndpointAsync</code></p> <p>The async Foreign Exchange API</p> <p>Retrieve information on exchange rates between currencies, buy and sell currencies.</p> Source code in <code>pyrevolut/api/foreign_exchange/endpoint/asynchronous.py</code> <pre><code>class EndpointForeignExchangeAsync(BaseEndpointAsync):\n    \"\"\"The async Foreign Exchange API\n\n    Retrieve information on exchange rates between currencies, buy and sell currencies.\n    \"\"\"\n\n    async def get_exchange_rate(\n        self,\n        from_currency: str,\n        to_currency: str,\n        amount: float | None = None,\n        **kwargs,\n    ) -&gt; dict | GetExchangeRate.Response:\n        \"\"\"\n        Get the sell exchange rate between two currencies.\n\n        Parameters\n        ----------\n        from_currency : str\n            The currency that you exchange from in ISO 4217 format.\n        to_currency : str\n            The currency that you exchange to in ISO 4217 format.\n        amount : float | None\n            The amount of the currency to exchange from.\n            The default value is 1.00 if not provided.\n\n        Returns\n        -------\n        dict | GetExchangeRate.Response\n            A dict with the information about the exchange rate.\n        \"\"\"\n        endpoint = GetExchangeRate\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            from_=from_currency,\n            to=to_currency,\n            amount=amount,\n        )\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def exchange_money(\n        self,\n        request_id: str,\n        from_account_id: UUID,\n        from_currency: str,\n        to_account_id: UUID,\n        to_currency: str,\n        from_amount: float | None = None,\n        to_amount: float | None = None,\n        reference: str | None = None,\n        **kwargs,\n    ) -&gt; dict | ExchangeMoney.Response:\n        \"\"\"\n        Exchange money using one of these methods:\n\n        Sell currency:\n            You know the amount of currency to sell.\n            For example, you want to exchange 135.5 USD to some EUR.\n            Specify the amount in the from object.\n\n        Buy currency:\n            You know the amount of currency to buy.\n            For example, you want to exchange some USD to 200 EUR.\n            Specify the amount in the to object.\n\n        Parameters\n        ----------\n        request_id : str\n            The ID of the request, provided by you.\n            It helps you identify the transaction in your system.\n\n            To ensure that an exchange transaction is not processed multiple\n            times if there are network or system errors, the same request_id\n            should be used for requests related to the same transaction.\n        from_account_id : UUID\n            The ID of the account to sell currency from.\n        from_currency : str\n            The currency to sell in ISO 4217 format.\n        to_account_id : UUID\n            The ID of the account to receive exchanged currency into.\n        to_currency : str\n            The currency to buy in ISO 4217 format.\n        from_amount : float | None\n            The amount of currency. Specify ONLY if you want to sell currency.\n        to_amount : float | None\n            The amount of currency. Specify ONLY if you want to buy currency.\n        reference : str | None\n            The reference for the exchange transaction, provided by you.\n            It helps you to identify the transaction if you want to look it up later.\n\n        Returns\n        -------\n        dict | ExchangeMoney.Response\n            A dict with the information about the exchange transaction.\n        \"\"\"\n        endpoint = ExchangeMoney\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            from_=endpoint.Body.ModelFrom(\n                account_id=from_account_id,\n                currency=from_currency,\n                amount=from_amount,\n            ),\n            to=endpoint.Body.ModelTo(\n                account_id=to_account_id,\n                currency=to_currency,\n                amount=to_amount,\n            ),\n            reference=reference,\n            request_id=request_id,\n        )\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/asynchronous/#pyrevolut.api.foreign_exchange.endpoint.EndpointForeignExchangeAsync.exchange_money","title":"<code>exchange_money(request_id, from_account_id, from_currency, to_account_id, to_currency, from_amount=None, to_amount=None, reference=None, **kwargs)</code>  <code>async</code>","text":"<p>Exchange money using one of these methods:</p> <p>Sell currency:     You know the amount of currency to sell.     For example, you want to exchange 135.5 USD to some EUR.     Specify the amount in the from object.</p> <p>Buy currency:     You know the amount of currency to buy.     For example, you want to exchange some USD to 200 EUR.     Specify the amount in the to object.</p> <p>Parameters:</p> Name Type Description Default <code>request_id</code> <code>str</code> <p>The ID of the request, provided by you. It helps you identify the transaction in your system.</p> <p>To ensure that an exchange transaction is not processed multiple times if there are network or system errors, the same request_id should be used for requests related to the same transaction.</p> required <code>from_account_id</code> <code>UUID</code> <p>The ID of the account to sell currency from.</p> required <code>from_currency</code> <code>str</code> <p>The currency to sell in ISO 4217 format.</p> required <code>to_account_id</code> <code>UUID</code> <p>The ID of the account to receive exchanged currency into.</p> required <code>to_currency</code> <code>str</code> <p>The currency to buy in ISO 4217 format.</p> required <code>from_amount</code> <code>float | None</code> <p>The amount of currency. Specify ONLY if you want to sell currency.</p> <code>None</code> <code>to_amount</code> <code>float | None</code> <p>The amount of currency. Specify ONLY if you want to buy currency.</p> <code>None</code> <code>reference</code> <code>str | None</code> <p>The reference for the exchange transaction, provided by you. It helps you to identify the transaction if you want to look it up later.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the exchange transaction.</p> Source code in <code>pyrevolut/api/foreign_exchange/endpoint/asynchronous.py</code> <pre><code>async def exchange_money(\n    self,\n    request_id: str,\n    from_account_id: UUID,\n    from_currency: str,\n    to_account_id: UUID,\n    to_currency: str,\n    from_amount: float | None = None,\n    to_amount: float | None = None,\n    reference: str | None = None,\n    **kwargs,\n) -&gt; dict | ExchangeMoney.Response:\n    \"\"\"\n    Exchange money using one of these methods:\n\n    Sell currency:\n        You know the amount of currency to sell.\n        For example, you want to exchange 135.5 USD to some EUR.\n        Specify the amount in the from object.\n\n    Buy currency:\n        You know the amount of currency to buy.\n        For example, you want to exchange some USD to 200 EUR.\n        Specify the amount in the to object.\n\n    Parameters\n    ----------\n    request_id : str\n        The ID of the request, provided by you.\n        It helps you identify the transaction in your system.\n\n        To ensure that an exchange transaction is not processed multiple\n        times if there are network or system errors, the same request_id\n        should be used for requests related to the same transaction.\n    from_account_id : UUID\n        The ID of the account to sell currency from.\n    from_currency : str\n        The currency to sell in ISO 4217 format.\n    to_account_id : UUID\n        The ID of the account to receive exchanged currency into.\n    to_currency : str\n        The currency to buy in ISO 4217 format.\n    from_amount : float | None\n        The amount of currency. Specify ONLY if you want to sell currency.\n    to_amount : float | None\n        The amount of currency. Specify ONLY if you want to buy currency.\n    reference : str | None\n        The reference for the exchange transaction, provided by you.\n        It helps you to identify the transaction if you want to look it up later.\n\n    Returns\n    -------\n    dict | ExchangeMoney.Response\n        A dict with the information about the exchange transaction.\n    \"\"\"\n    endpoint = ExchangeMoney\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        from_=endpoint.Body.ModelFrom(\n            account_id=from_account_id,\n            currency=from_currency,\n            amount=from_amount,\n        ),\n        to=endpoint.Body.ModelTo(\n            account_id=to_account_id,\n            currency=to_currency,\n            amount=to_amount,\n        ),\n        reference=reference,\n        request_id=request_id,\n    )\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/asynchronous/#pyrevolut.api.foreign_exchange.endpoint.EndpointForeignExchangeAsync.get_exchange_rate","title":"<code>get_exchange_rate(from_currency, to_currency, amount=None, **kwargs)</code>  <code>async</code>","text":"<p>Get the sell exchange rate between two currencies.</p> <p>Parameters:</p> Name Type Description Default <code>from_currency</code> <code>str</code> <p>The currency that you exchange from in ISO 4217 format.</p> required <code>to_currency</code> <code>str</code> <p>The currency that you exchange to in ISO 4217 format.</p> required <code>amount</code> <code>float | None</code> <p>The amount of the currency to exchange from. The default value is 1.00 if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the exchange rate.</p> Source code in <code>pyrevolut/api/foreign_exchange/endpoint/asynchronous.py</code> <pre><code>async def get_exchange_rate(\n    self,\n    from_currency: str,\n    to_currency: str,\n    amount: float | None = None,\n    **kwargs,\n) -&gt; dict | GetExchangeRate.Response:\n    \"\"\"\n    Get the sell exchange rate between two currencies.\n\n    Parameters\n    ----------\n    from_currency : str\n        The currency that you exchange from in ISO 4217 format.\n    to_currency : str\n        The currency that you exchange to in ISO 4217 format.\n    amount : float | None\n        The amount of the currency to exchange from.\n        The default value is 1.00 if not provided.\n\n    Returns\n    -------\n    dict | GetExchangeRate.Response\n        A dict with the information about the exchange rate.\n    \"\"\"\n    endpoint = GetExchangeRate\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        from_=from_currency,\n        to=to_currency,\n        amount=amount,\n    )\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/","title":"Foreign Exchange Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Foreign Exchange</code> endpoint.</p>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.resources.ResourceForeignExchange","title":"<code>ResourceForeignExchange</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Foreign Exchange resource model.</p> Source code in <code>pyrevolut/api/foreign_exchange/resources/foreign_exchange.py</code> <pre><code>class ResourceForeignExchange(BaseModel):\n    \"\"\"\n    Foreign Exchange resource model.\n    \"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        from_attributes=True,\n    )\n\n    class ModelFrom(ModelBaseAmount):\n        \"\"\"\n        The money to sell.\n        \"\"\"\n\n        pass\n\n    class ModelTo(ModelBaseAmount):\n        \"\"\"\n        The money to receive.\n        \"\"\"\n\n        pass\n\n    class ModelFee(ModelBaseAmount):\n        \"\"\"\n        The expected fee for the transaction.\n        \"\"\"\n\n        pass\n\n    from_: Annotated[ModelFrom, Field(alias=\"from\", description=\"The money to sell.\")]\n    to: Annotated[ModelTo, Field(description=\"The money to receive.\")]\n    rate: Annotated[float, Field(description=\"The proposed exchange rate.\")]\n    fee: Annotated[ModelFee, Field(description=\"The expected fee for the transaction.\")]\n    rate_date: Annotated[\n        DateTime,\n        Field(description=\"The date of the proposed exchange rate in ISO 8601 format.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.resources.ResourceForeignExchange.ModelFee","title":"<code>ModelFee</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The expected fee for the transaction.</p> Source code in <code>pyrevolut/api/foreign_exchange/resources/foreign_exchange.py</code> <pre><code>class ModelFee(ModelBaseAmount):\n    \"\"\"\n    The expected fee for the transaction.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.resources.ResourceForeignExchange.ModelFrom","title":"<code>ModelFrom</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The money to sell.</p> Source code in <code>pyrevolut/api/foreign_exchange/resources/foreign_exchange.py</code> <pre><code>class ModelFrom(ModelBaseAmount):\n    \"\"\"\n    The money to sell.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.resources.ResourceForeignExchange.ModelTo","title":"<code>ModelTo</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The money to receive.</p> Source code in <code>pyrevolut/api/foreign_exchange/resources/foreign_exchange.py</code> <pre><code>class ModelTo(ModelBaseAmount):\n    \"\"\"\n    The money to receive.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.get.GetExchangeRate","title":"<code>GetExchangeRate</code>","text":"<p>Get the sell exchange rate between two currencies.</p> Source code in <code>pyrevolut/api/foreign_exchange/get/get_exchange_rate.py</code> <pre><code>class GetExchangeRate:\n    \"\"\"\n    Get the sell exchange rate between two currencies.\n    \"\"\"\n\n    ROUTE = \"/1.0/rate\"\n\n    class Params(BaseModel):\n        \"\"\"\n        Query parameters for the endpoint.\n        \"\"\"\n\n        model_config = ConfigDict(\n            populate_by_name=True,\n            from_attributes=True,\n        )\n\n        from_: Annotated[\n            Currency,\n            Field(\n                alias=\"from\",\n                description=\"The currency that you exchange from in ISO 4217 format.\",\n            ),\n        ]\n        to: Annotated[\n            Currency,\n            Field(description=\"The currency that you exchange to in ISO 4217 format.\"),\n        ]\n        amount: Annotated[\n            float | None,\n            Field(\n                description=\"The amount of the currency to exchange from. The default value is 1.00.\"\n            ),\n        ] = None\n\n    class Response(ResourceForeignExchange):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.get.GetExchangeRate.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query parameters for the endpoint.</p> Source code in <code>pyrevolut/api/foreign_exchange/get/get_exchange_rate.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    Query parameters for the endpoint.\n    \"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        from_attributes=True,\n    )\n\n    from_: Annotated[\n        Currency,\n        Field(\n            alias=\"from\",\n            description=\"The currency that you exchange from in ISO 4217 format.\",\n        ),\n    ]\n    to: Annotated[\n        Currency,\n        Field(description=\"The currency that you exchange to in ISO 4217 format.\"),\n    ]\n    amount: Annotated[\n        float | None,\n        Field(\n            description=\"The amount of the currency to exchange from. The default value is 1.00.\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.get.GetExchangeRate.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceForeignExchange</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/foreign_exchange/get/get_exchange_rate.py</code> <pre><code>class Response(ResourceForeignExchange):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.post.ExchangeMoney","title":"<code>ExchangeMoney</code>","text":"<p>Exchange money using one of these methods:</p> <p>Sell currency:     You know the amount of currency to sell.     For example, you want to exchange 135.5 USD to some EUR.     Specify the amount in the from object.</p> <p>Buy currency:     You know the amount of currency to buy.     For example, you want to exchange some USD to 200 EUR.     Specify the amount in the to object.</p> Source code in <code>pyrevolut/api/foreign_exchange/post/exchange_money.py</code> <pre><code>class ExchangeMoney:\n    \"\"\"\n    Exchange money using one of these methods:\n\n    Sell currency:\n        You know the amount of currency to sell.\n        For example, you want to exchange 135.5 USD to some EUR.\n        Specify the amount in the from object.\n\n    Buy currency:\n        You know the amount of currency to buy.\n        For example, you want to exchange some USD to 200 EUR.\n        Specify the amount in the to object.\n    \"\"\"\n\n    ROUTE = \"/1.0/exchange\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The request body for the endpoint.\n        \"\"\"\n\n        model_config = ConfigDict(\n            populate_by_name=True,\n            from_attributes=True,\n        )\n\n        class ModelFrom(BaseModel):\n            \"\"\"The details of the currency to exchange from.\"\"\"\n\n            account_id: Annotated[\n                UUID, Field(description=\"The ID of the account to sell currency from.\")\n            ]\n            currency: Annotated[\n                Currency,\n                Field(description=\"The currency to sell in ISO 4217 format.\"),\n            ]\n            amount: Annotated[\n                float | None,\n                Field(\n                    description=\"The amount of currency. Specify ONLY if you want to sell currency.\"\n                ),\n            ] = None\n\n        class ModelTo(BaseModel):\n            \"\"\"The details of the currency to exchange to.\"\"\"\n\n            account_id: Annotated[\n                UUID,\n                Field(\n                    description=\"The ID of the account to receive exchanged currency into.\"\n                ),\n            ]\n            currency: Annotated[\n                Currency,\n                Field(description=\"The currency to buy in ISO 4217 format.\"),\n            ]\n            amount: Annotated[\n                float | None,\n                Field(\n                    description=\"The amount of currency. Specify ONLY if you want to buy currency.\"\n                ),\n            ] = None\n\n        from_: Annotated[\n            ModelFrom,\n            Field(\n                alias=\"from\",\n                description=\"The details of the currency to exchange from.\",\n            ),\n        ]\n        to: Annotated[\n            ModelTo,\n            Field(description=\"The details of the currency to exchange to.\"),\n        ]\n        reference: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The reference for the exchange transaction, provided by you. \n                It helps you to identify the transaction if you want to look it up later.\n                \"\"\"\n            ),\n        ] = None\n        request_id: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                The ID of the request, provided by you. \n                It helps you identify the transaction in your system.\n\n                To ensure that an exchange transaction is not processed multiple \n                times if there are network or system errors, the same request_id \n                should be used for requests related to the same transaction.\n                \"\"\",\n                max_length=40,\n            ),\n        ]\n\n        @model_validator(mode=\"after\")\n        def check_inputs(self) -&gt; \"ExchangeMoney.Body\":\n            \"\"\"Check if the amount is specified in either the from or to object.\"\"\"\n            if self.from_.amount is None and self.to.amount is None:\n                raise ValueError(\n                    \"Either the amount in the from or to object must be specified.\"\n                )\n            if self.from_.amount is not None and self.to.amount is not None:\n                raise ValueError(\n                    \"Only the amount in either the from or to object must be specified.\"\n                )\n            return self\n\n    class Response(BaseModel):\n        \"\"\"\n        Response model for the endpoint.\n        \"\"\"\n\n        id: Annotated[\n            UUID | None, Field(description=\"The ID of the created transaction.\")\n        ] = None\n        type: Annotated[\n            EnumTransactionType,\n            Field(\n                description=\"The type of the transaction. For money exchange, it is 'exchange'.\"\n            ),\n        ] = EnumTransactionType.EXCHANGE\n        reason_code: Annotated[\n            str | None,\n            Field(\n                description=\"The reason code when the state parameter of the transaction is declined or failed.\"\n            ),\n        ] = None\n        created_at: Annotated[\n            DateTime,\n            Field(\n                description=\"The date and time the transaction was created in ISO 8601 format.\"\n            ),\n        ]\n        completed_at: Annotated[\n            DateTime | None,\n            Field(\n                description=\"The date and time the transaction was completed in ISO 8601 format.\"\n            ),\n        ] = None\n        state: Annotated[\n            EnumTransactionState | None,\n            Field(\n                description=\"\"\"\n                Indicates the transaction state. Possible values:\n\n                    created:\n                        The transaction has been created and is either processed asynchronously\n                        or scheduled for a later time.\n                    pending:\n                        The transaction is pending until it's being processed.\n                        If the transfer is made between Revolut accounts,\n                        this state is skipped and the transaction is executed instantly.\n                    completed:\n                        The transaction was successful.\n                    declined:\n                        The transaction was unsuccessful. This can happen for a variety of reasons,\n                        for example, insufficient account balance, wrong receiver information, etc.\n                    failed:\n                        The transaction was unsuccessful. This can happen for a variety of reasons,\n                        for example, invalid API calls, blocked payments, etc.\n                    reverted:\n                        The transaction was reverted. This can happen for a variety of reasons,\n                        for example, the receiver being inaccessible.\n                \"\"\"\n            ),\n        ] = None\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.post.ExchangeMoney.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The request body for the endpoint.</p> Source code in <code>pyrevolut/api/foreign_exchange/post/exchange_money.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The request body for the endpoint.\n    \"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        from_attributes=True,\n    )\n\n    class ModelFrom(BaseModel):\n        \"\"\"The details of the currency to exchange from.\"\"\"\n\n        account_id: Annotated[\n            UUID, Field(description=\"The ID of the account to sell currency from.\")\n        ]\n        currency: Annotated[\n            Currency,\n            Field(description=\"The currency to sell in ISO 4217 format.\"),\n        ]\n        amount: Annotated[\n            float | None,\n            Field(\n                description=\"The amount of currency. Specify ONLY if you want to sell currency.\"\n            ),\n        ] = None\n\n    class ModelTo(BaseModel):\n        \"\"\"The details of the currency to exchange to.\"\"\"\n\n        account_id: Annotated[\n            UUID,\n            Field(\n                description=\"The ID of the account to receive exchanged currency into.\"\n            ),\n        ]\n        currency: Annotated[\n            Currency,\n            Field(description=\"The currency to buy in ISO 4217 format.\"),\n        ]\n        amount: Annotated[\n            float | None,\n            Field(\n                description=\"The amount of currency. Specify ONLY if you want to buy currency.\"\n            ),\n        ] = None\n\n    from_: Annotated[\n        ModelFrom,\n        Field(\n            alias=\"from\",\n            description=\"The details of the currency to exchange from.\",\n        ),\n    ]\n    to: Annotated[\n        ModelTo,\n        Field(description=\"The details of the currency to exchange to.\"),\n    ]\n    reference: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The reference for the exchange transaction, provided by you. \n            It helps you to identify the transaction if you want to look it up later.\n            \"\"\"\n        ),\n    ] = None\n    request_id: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            The ID of the request, provided by you. \n            It helps you identify the transaction in your system.\n\n            To ensure that an exchange transaction is not processed multiple \n            times if there are network or system errors, the same request_id \n            should be used for requests related to the same transaction.\n            \"\"\",\n            max_length=40,\n        ),\n    ]\n\n    @model_validator(mode=\"after\")\n    def check_inputs(self) -&gt; \"ExchangeMoney.Body\":\n        \"\"\"Check if the amount is specified in either the from or to object.\"\"\"\n        if self.from_.amount is None and self.to.amount is None:\n            raise ValueError(\n                \"Either the amount in the from or to object must be specified.\"\n            )\n        if self.from_.amount is not None and self.to.amount is not None:\n            raise ValueError(\n                \"Only the amount in either the from or to object must be specified.\"\n            )\n        return self\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.post.ExchangeMoney.Body.ModelFrom","title":"<code>ModelFrom</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The details of the currency to exchange from.</p> Source code in <code>pyrevolut/api/foreign_exchange/post/exchange_money.py</code> <pre><code>class ModelFrom(BaseModel):\n    \"\"\"The details of the currency to exchange from.\"\"\"\n\n    account_id: Annotated[\n        UUID, Field(description=\"The ID of the account to sell currency from.\")\n    ]\n    currency: Annotated[\n        Currency,\n        Field(description=\"The currency to sell in ISO 4217 format.\"),\n    ]\n    amount: Annotated[\n        float | None,\n        Field(\n            description=\"The amount of currency. Specify ONLY if you want to sell currency.\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.post.ExchangeMoney.Body.ModelTo","title":"<code>ModelTo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The details of the currency to exchange to.</p> Source code in <code>pyrevolut/api/foreign_exchange/post/exchange_money.py</code> <pre><code>class ModelTo(BaseModel):\n    \"\"\"The details of the currency to exchange to.\"\"\"\n\n    account_id: Annotated[\n        UUID,\n        Field(\n            description=\"The ID of the account to receive exchanged currency into.\"\n        ),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(description=\"The currency to buy in ISO 4217 format.\"),\n    ]\n    amount: Annotated[\n        float | None,\n        Field(\n            description=\"The amount of currency. Specify ONLY if you want to buy currency.\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.post.ExchangeMoney.Body.check_inputs","title":"<code>check_inputs()</code>","text":"<p>Check if the amount is specified in either the from or to object.</p> Source code in <code>pyrevolut/api/foreign_exchange/post/exchange_money.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_inputs(self) -&gt; \"ExchangeMoney.Body\":\n    \"\"\"Check if the amount is specified in either the from or to object.\"\"\"\n    if self.from_.amount is None and self.to.amount is None:\n        raise ValueError(\n            \"Either the amount in the from or to object must be specified.\"\n        )\n    if self.from_.amount is not None and self.to.amount is not None:\n        raise ValueError(\n            \"Only the amount in either the from or to object must be specified.\"\n        )\n    return self\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/pydantic/#pyrevolut.api.foreign_exchange.post.ExchangeMoney.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for the endpoint.</p> Source code in <code>pyrevolut/api/foreign_exchange/post/exchange_money.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    Response model for the endpoint.\n    \"\"\"\n\n    id: Annotated[\n        UUID | None, Field(description=\"The ID of the created transaction.\")\n    ] = None\n    type: Annotated[\n        EnumTransactionType,\n        Field(\n            description=\"The type of the transaction. For money exchange, it is 'exchange'.\"\n        ),\n    ] = EnumTransactionType.EXCHANGE\n    reason_code: Annotated[\n        str | None,\n        Field(\n            description=\"The reason code when the state parameter of the transaction is declined or failed.\"\n        ),\n    ] = None\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the transaction was created in ISO 8601 format.\"\n        ),\n    ]\n    completed_at: Annotated[\n        DateTime | None,\n        Field(\n            description=\"The date and time the transaction was completed in ISO 8601 format.\"\n        ),\n    ] = None\n    state: Annotated[\n        EnumTransactionState | None,\n        Field(\n            description=\"\"\"\n            Indicates the transaction state. Possible values:\n\n                created:\n                    The transaction has been created and is either processed asynchronously\n                    or scheduled for a later time.\n                pending:\n                    The transaction is pending until it's being processed.\n                    If the transfer is made between Revolut accounts,\n                    this state is skipped and the transaction is executed instantly.\n                completed:\n                    The transaction was successful.\n                declined:\n                    The transaction was unsuccessful. This can happen for a variety of reasons,\n                    for example, insufficient account balance, wrong receiver information, etc.\n                failed:\n                    The transaction was unsuccessful. This can happen for a variety of reasons,\n                    for example, invalid API calls, blocked payments, etc.\n                reverted:\n                    The transaction was reverted. This can happen for a variety of reasons,\n                    for example, the receiver being inaccessible.\n            \"\"\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/synchronous/","title":"Foreign Exchange Synchronous Endpoints","text":"<p>This <code>Foreign Exchange</code> endpoint provides methods to interact with the foreign exchanges of the authenticated user.</p> <p>Example usage of the Foreign Exchange endpoint object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    rate = client.ForeignExchange.get_exchange_rate(\n        from_currency=\"USD\",\n        to_currency=\"EUR\",\n        amount=1.0,\n    )\n    print(rate)\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/synchronous/#pyrevolut.api.foreign_exchange.endpoint.EndpointForeignExchangeSync","title":"<code>EndpointForeignExchangeSync</code>","text":"<p>               Bases: <code>BaseEndpointSync</code></p> <p>The Foreign Exchange API</p> <p>Retrieve information on exchange rates between currencies, buy and sell currencies.</p> Source code in <code>pyrevolut/api/foreign_exchange/endpoint/synchronous.py</code> <pre><code>class EndpointForeignExchangeSync(BaseEndpointSync):\n    \"\"\"The Foreign Exchange API\n\n    Retrieve information on exchange rates between currencies, buy and sell currencies.\n    \"\"\"\n\n    def get_exchange_rate(\n        self,\n        from_currency: str,\n        to_currency: str,\n        amount: float | None = None,\n        **kwargs,\n    ) -&gt; dict | GetExchangeRate.Response:\n        \"\"\"\n        Get the sell exchange rate between two currencies.\n\n        Parameters\n        ----------\n        from_currency : str\n            The currency that you exchange from in ISO 4217 format.\n        to_currency : str\n            The currency that you exchange to in ISO 4217 format.\n        amount : float | None\n            The amount of the currency to exchange from.\n            The default value is 1.00 if not provided.\n\n        Returns\n        -------\n        dict | GetExchangeRate.Response\n            A dict with the information about the exchange rate.\n        \"\"\"\n        endpoint = GetExchangeRate\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            from_=from_currency,\n            to=to_currency,\n            amount=amount,\n        )\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def exchange_money(\n        self,\n        request_id: str,\n        from_account_id: UUID,\n        from_currency: str,\n        to_account_id: UUID,\n        to_currency: str,\n        from_amount: float | None = None,\n        to_amount: float | None = None,\n        reference: str | None = None,\n        **kwargs,\n    ) -&gt; dict | ExchangeMoney.Response:\n        \"\"\"\n        Exchange money using one of these methods:\n\n        Sell currency:\n            You know the amount of currency to sell.\n            For example, you want to exchange 135.5 USD to some EUR.\n            Specify the amount in the from object.\n\n        Buy currency:\n            You know the amount of currency to buy.\n            For example, you want to exchange some USD to 200 EUR.\n            Specify the amount in the to object.\n\n        Parameters\n        ----------\n        request_id : str\n            The ID of the request, provided by you.\n            It helps you identify the transaction in your system.\n\n            To ensure that an exchange transaction is not processed multiple\n            times if there are network or system errors, the same request_id\n            should be used for requests related to the same transaction.\n        from_account_id : UUID\n            The ID of the account to sell currency from.\n        from_currency : str\n            The currency to sell in ISO 4217 format.\n        to_account_id : UUID\n            The ID of the account to receive exchanged currency into.\n        to_currency : str\n            The currency to buy in ISO 4217 format.\n        from_amount : float | None\n            The amount of currency. Specify ONLY if you want to sell currency.\n        to_amount : float | None\n            The amount of currency. Specify ONLY if you want to buy currency.\n        reference : str | None\n            The reference for the exchange transaction, provided by you.\n            It helps you to identify the transaction if you want to look it up later.\n\n        Returns\n        -------\n        dict | ExchangeMoney.Response\n            A dict with the information about the exchange transaction.\n        \"\"\"\n        endpoint = ExchangeMoney\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            from_=endpoint.Body.ModelFrom(\n                account_id=from_account_id,\n                currency=from_currency,\n                amount=from_amount,\n            ),\n            to=endpoint.Body.ModelTo(\n                account_id=to_account_id,\n                currency=to_currency,\n                amount=to_amount,\n            ),\n            reference=reference,\n            request_id=request_id,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/synchronous/#pyrevolut.api.foreign_exchange.endpoint.EndpointForeignExchangeSync.exchange_money","title":"<code>exchange_money(request_id, from_account_id, from_currency, to_account_id, to_currency, from_amount=None, to_amount=None, reference=None, **kwargs)</code>","text":"<p>Exchange money using one of these methods:</p> <p>Sell currency:     You know the amount of currency to sell.     For example, you want to exchange 135.5 USD to some EUR.     Specify the amount in the from object.</p> <p>Buy currency:     You know the amount of currency to buy.     For example, you want to exchange some USD to 200 EUR.     Specify the amount in the to object.</p> <p>Parameters:</p> Name Type Description Default <code>request_id</code> <code>str</code> <p>The ID of the request, provided by you. It helps you identify the transaction in your system.</p> <p>To ensure that an exchange transaction is not processed multiple times if there are network or system errors, the same request_id should be used for requests related to the same transaction.</p> required <code>from_account_id</code> <code>UUID</code> <p>The ID of the account to sell currency from.</p> required <code>from_currency</code> <code>str</code> <p>The currency to sell in ISO 4217 format.</p> required <code>to_account_id</code> <code>UUID</code> <p>The ID of the account to receive exchanged currency into.</p> required <code>to_currency</code> <code>str</code> <p>The currency to buy in ISO 4217 format.</p> required <code>from_amount</code> <code>float | None</code> <p>The amount of currency. Specify ONLY if you want to sell currency.</p> <code>None</code> <code>to_amount</code> <code>float | None</code> <p>The amount of currency. Specify ONLY if you want to buy currency.</p> <code>None</code> <code>reference</code> <code>str | None</code> <p>The reference for the exchange transaction, provided by you. It helps you to identify the transaction if you want to look it up later.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the exchange transaction.</p> Source code in <code>pyrevolut/api/foreign_exchange/endpoint/synchronous.py</code> <pre><code>def exchange_money(\n    self,\n    request_id: str,\n    from_account_id: UUID,\n    from_currency: str,\n    to_account_id: UUID,\n    to_currency: str,\n    from_amount: float | None = None,\n    to_amount: float | None = None,\n    reference: str | None = None,\n    **kwargs,\n) -&gt; dict | ExchangeMoney.Response:\n    \"\"\"\n    Exchange money using one of these methods:\n\n    Sell currency:\n        You know the amount of currency to sell.\n        For example, you want to exchange 135.5 USD to some EUR.\n        Specify the amount in the from object.\n\n    Buy currency:\n        You know the amount of currency to buy.\n        For example, you want to exchange some USD to 200 EUR.\n        Specify the amount in the to object.\n\n    Parameters\n    ----------\n    request_id : str\n        The ID of the request, provided by you.\n        It helps you identify the transaction in your system.\n\n        To ensure that an exchange transaction is not processed multiple\n        times if there are network or system errors, the same request_id\n        should be used for requests related to the same transaction.\n    from_account_id : UUID\n        The ID of the account to sell currency from.\n    from_currency : str\n        The currency to sell in ISO 4217 format.\n    to_account_id : UUID\n        The ID of the account to receive exchanged currency into.\n    to_currency : str\n        The currency to buy in ISO 4217 format.\n    from_amount : float | None\n        The amount of currency. Specify ONLY if you want to sell currency.\n    to_amount : float | None\n        The amount of currency. Specify ONLY if you want to buy currency.\n    reference : str | None\n        The reference for the exchange transaction, provided by you.\n        It helps you to identify the transaction if you want to look it up later.\n\n    Returns\n    -------\n    dict | ExchangeMoney.Response\n        A dict with the information about the exchange transaction.\n    \"\"\"\n    endpoint = ExchangeMoney\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        from_=endpoint.Body.ModelFrom(\n            account_id=from_account_id,\n            currency=from_currency,\n            amount=from_amount,\n        ),\n        to=endpoint.Body.ModelTo(\n            account_id=to_account_id,\n            currency=to_currency,\n            amount=to_amount,\n        ),\n        reference=reference,\n        request_id=request_id,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/foreign_exchange/synchronous/#pyrevolut.api.foreign_exchange.endpoint.EndpointForeignExchangeSync.get_exchange_rate","title":"<code>get_exchange_rate(from_currency, to_currency, amount=None, **kwargs)</code>","text":"<p>Get the sell exchange rate between two currencies.</p> <p>Parameters:</p> Name Type Description Default <code>from_currency</code> <code>str</code> <p>The currency that you exchange from in ISO 4217 format.</p> required <code>to_currency</code> <code>str</code> <p>The currency that you exchange to in ISO 4217 format.</p> required <code>amount</code> <code>float | None</code> <p>The amount of the currency to exchange from. The default value is 1.00 if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the exchange rate.</p> Source code in <code>pyrevolut/api/foreign_exchange/endpoint/synchronous.py</code> <pre><code>def get_exchange_rate(\n    self,\n    from_currency: str,\n    to_currency: str,\n    amount: float | None = None,\n    **kwargs,\n) -&gt; dict | GetExchangeRate.Response:\n    \"\"\"\n    Get the sell exchange rate between two currencies.\n\n    Parameters\n    ----------\n    from_currency : str\n        The currency that you exchange from in ISO 4217 format.\n    to_currency : str\n        The currency that you exchange to in ISO 4217 format.\n    amount : float | None\n        The amount of the currency to exchange from.\n        The default value is 1.00 if not provided.\n\n    Returns\n    -------\n    dict | GetExchangeRate.Response\n        A dict with the information about the exchange rate.\n    \"\"\"\n    endpoint = GetExchangeRate\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        from_=from_currency,\n        to=to_currency,\n        amount=amount,\n    )\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payment_drafts/asynchronous/","title":"Payment Drafts Asynchronous Endpoints","text":"<p>This <code>Payment Drafts</code> endpoint provides asynchronous methods to interact with the payment drafts of the authenticated user.</p> <p>Example usage of the Payment Drafts endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        drafts = await client.PaymentDrafts.get_all_payment_drafts()\n        print(drafts)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/payment_drafts/asynchronous/#pyrevolut.api.payment_drafts.endpoint.EndpointPaymentDraftsAsync","title":"<code>EndpointPaymentDraftsAsync</code>","text":"<p>               Bases: <code>BaseEndpointAsync</code></p> <p>The async Payment Drafts API</p> <p>Create a payment draft to request an approval for a payment from a business owner or admin before the payment is executed. The business owner or admin must manually approve it in the Revolut Business User Interface.</p> <p>You can also retrieve one or all payment drafts, and delete a payment draft.</p> Source code in <code>pyrevolut/api/payment_drafts/endpoint/asynchronous.py</code> <pre><code>class EndpointPaymentDraftsAsync(BaseEndpointAsync):\n    \"\"\"The async Payment Drafts API\n\n    Create a payment draft to request an approval for a payment from a\n    business owner or admin before the payment is executed.\n    The business owner or admin must manually approve it in the\n    Revolut Business User Interface.\n\n    You can also retrieve one or all payment drafts, and delete a payment draft.\n    \"\"\"\n\n    async def get_all_payment_drafts(\n        self,\n        **kwargs,\n    ) -&gt; dict | RetrieveAllPaymentDrafts.Response:\n        \"\"\"\n        Get a list of all the payment drafts that aren't processed.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        dict | RetrieveAllPaymentDrafts.Response\n            A dict with the information about the payment drafts.\n        \"\"\"\n        endpoint = RetrieveAllPaymentDrafts\n        path = endpoint.ROUTE\n        params = endpoint.Params()\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def get_payment_draft(\n        self,\n        payment_draft_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrievePaymentDraft.Response:\n        \"\"\"\n        Get the information about a specific payment draft by ID.\n\n        Parameters\n        ----------\n        payment_draft_id : UUID\n            The ID of the payment draft.\n\n        Returns\n        -------\n        dict | RetrievePaymentDraft.Response\n            A dict with the information about the payment draft.\n        \"\"\"\n        endpoint = RetrievePaymentDraft\n        path = endpoint.ROUTE.format(payment_draft_id=payment_draft_id)\n        params = endpoint.Params()\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def create_payment_draft(\n        self,\n        account_id: UUID,\n        counterparty_ids: list[UUID] = [],\n        counterparty_account_ids: list[UUID | None] = [],\n        counterparty_card_ids: list[UUID | None] = [],\n        amounts: list[float] = [],\n        currencies: list[str] = [],\n        references: list[str] = [],\n        title: str | None = None,\n        schedule_for: date | Date | str | None = None,\n        **kwargs,\n    ) -&gt; dict | CreatePaymentDraft.Response:\n        \"\"\"\n        Create a payment draft.\n\n        Parameters\n        ----------\n        account_id : UUID\n            The ID of the account to pay from.\n        counterparty_ids : list[UUID]\n            The IDs of the counterparty accounts. Each ID corresponds to a payment.\n        counterparty_account_ids : list[UUID | None]\n            The IDs of the counterparty accounts. Each ID corresponds to a payment.\n            If the counterparty has multiple payment methods available, use it to\n            specify the account to which you want to send the money. Otherwise, use None.\n        counterparty_card_ids : list[UUID | None]\n            The IDs of the counterparty cards. Each ID corresponds to a payment.\n            If the counterparty has multiple payment methods available, use it to\n            specify the card to which you want to send the money. Otherwise, use None.\n        amounts : list[float]\n            The amounts of the payments.\n        currencies : list[str]\n            The ISO 4217 currency codes in upper case.\n        references : list[str]\n            The references for the payments.\n        title : str, optional\n            The title of the payment draft.\n        schedule_for : date | Date | str, optional\n            The scheduled date of the payment draft in ISO 8601 format.\n\n        Returns\n        -------\n        dict | CreatePaymentDraft.Response\n            A dict with the information about the payment draft created.\n        \"\"\"\n        assert (\n            len(counterparty_ids)\n            == len(counterparty_account_ids)\n            == len(counterparty_card_ids)\n            == len(amounts)\n            == len(currencies)\n            == len(references)\n        ), (\n            \"The number of elements in the lists must be equal. \"\n            f\"Got {len(counterparty_ids)} counterparty_ids, \"\n            f\"{len(counterparty_account_ids)} counterparty_account_ids, \"\n            f\"{len(counterparty_card_ids)} counterparty_card_ids, \"\n            f\"{len(amounts)} amounts, \"\n            f\"{len(currencies)} currencies, \"\n            f\"and {len(references)} references.\"\n        )\n\n        endpoint = CreatePaymentDraft\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            title=title,\n            schedule_for=schedule_for,\n            payments=[\n                endpoint.Body.ModelPayment(\n                    account_id=account_id,\n                    receiver=endpoint.Body.ModelPayment.ModelReceiver(\n                        counterparty_id=counterparty_id,\n                        account_id=counterparty_account_id,\n                        card_id=counterparty_card_id,\n                    ),\n                    amount=amount,\n                    currency=currency,\n                    reference=reference,\n                )\n                for counterparty_id, counterparty_account_id, counterparty_card_id, amount, currency, reference in zip(\n                    counterparty_ids,\n                    counterparty_account_ids,\n                    counterparty_card_ids,\n                    amounts,\n                    currencies,\n                    references,\n                )\n            ],\n        )\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    async def delete_payment_draft(\n        self,\n        payment_draft_id: UUID,\n        **kwargs,\n    ) -&gt; dict | DeletePaymentDraft.Response:\n        \"\"\"\n        Delete a payment draft with the given ID.\n        You can delete a payment draft only if it isn't processed.\n\n        Parameters\n        ----------\n        payment_draft_id : UUID\n            The ID of the payment draft.\n\n        Returns\n        -------\n        dict | DeletePaymentDraft.Response\n            A dict with the information about the payment draft deleted.\n        \"\"\"\n        endpoint = DeletePaymentDraft\n        path = endpoint.ROUTE.format(payment_draft_id=payment_draft_id)\n        params = endpoint.Params()\n\n        return await self.client.delete(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/payment_drafts/asynchronous/#pyrevolut.api.payment_drafts.endpoint.EndpointPaymentDraftsAsync.create_payment_draft","title":"<code>create_payment_draft(account_id, counterparty_ids=[], counterparty_account_ids=[], counterparty_card_ids=[], amounts=[], currencies=[], references=[], title=None, schedule_for=None, **kwargs)</code>  <code>async</code>","text":"<p>Create a payment draft.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>UUID</code> <p>The ID of the account to pay from.</p> required <code>counterparty_ids</code> <code>list[UUID]</code> <p>The IDs of the counterparty accounts. Each ID corresponds to a payment.</p> <code>[]</code> <code>counterparty_account_ids</code> <code>list[UUID | None]</code> <p>The IDs of the counterparty accounts. Each ID corresponds to a payment. If the counterparty has multiple payment methods available, use it to specify the account to which you want to send the money. Otherwise, use None.</p> <code>[]</code> <code>counterparty_card_ids</code> <code>list[UUID | None]</code> <p>The IDs of the counterparty cards. Each ID corresponds to a payment. If the counterparty has multiple payment methods available, use it to specify the card to which you want to send the money. Otherwise, use None.</p> <code>[]</code> <code>amounts</code> <code>list[float]</code> <p>The amounts of the payments.</p> <code>[]</code> <code>currencies</code> <code>list[str]</code> <p>The ISO 4217 currency codes in upper case.</p> <code>[]</code> <code>references</code> <code>list[str]</code> <p>The references for the payments.</p> <code>[]</code> <code>title</code> <code>str</code> <p>The title of the payment draft.</p> <code>None</code> <code>schedule_for</code> <code>date | Date | str</code> <p>The scheduled date of the payment draft in ISO 8601 format.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the payment draft created.</p> Source code in <code>pyrevolut/api/payment_drafts/endpoint/asynchronous.py</code> <pre><code>async def create_payment_draft(\n    self,\n    account_id: UUID,\n    counterparty_ids: list[UUID] = [],\n    counterparty_account_ids: list[UUID | None] = [],\n    counterparty_card_ids: list[UUID | None] = [],\n    amounts: list[float] = [],\n    currencies: list[str] = [],\n    references: list[str] = [],\n    title: str | None = None,\n    schedule_for: date | Date | str | None = None,\n    **kwargs,\n) -&gt; dict | CreatePaymentDraft.Response:\n    \"\"\"\n    Create a payment draft.\n\n    Parameters\n    ----------\n    account_id : UUID\n        The ID of the account to pay from.\n    counterparty_ids : list[UUID]\n        The IDs of the counterparty accounts. Each ID corresponds to a payment.\n    counterparty_account_ids : list[UUID | None]\n        The IDs of the counterparty accounts. Each ID corresponds to a payment.\n        If the counterparty has multiple payment methods available, use it to\n        specify the account to which you want to send the money. Otherwise, use None.\n    counterparty_card_ids : list[UUID | None]\n        The IDs of the counterparty cards. Each ID corresponds to a payment.\n        If the counterparty has multiple payment methods available, use it to\n        specify the card to which you want to send the money. Otherwise, use None.\n    amounts : list[float]\n        The amounts of the payments.\n    currencies : list[str]\n        The ISO 4217 currency codes in upper case.\n    references : list[str]\n        The references for the payments.\n    title : str, optional\n        The title of the payment draft.\n    schedule_for : date | Date | str, optional\n        The scheduled date of the payment draft in ISO 8601 format.\n\n    Returns\n    -------\n    dict | CreatePaymentDraft.Response\n        A dict with the information about the payment draft created.\n    \"\"\"\n    assert (\n        len(counterparty_ids)\n        == len(counterparty_account_ids)\n        == len(counterparty_card_ids)\n        == len(amounts)\n        == len(currencies)\n        == len(references)\n    ), (\n        \"The number of elements in the lists must be equal. \"\n        f\"Got {len(counterparty_ids)} counterparty_ids, \"\n        f\"{len(counterparty_account_ids)} counterparty_account_ids, \"\n        f\"{len(counterparty_card_ids)} counterparty_card_ids, \"\n        f\"{len(amounts)} amounts, \"\n        f\"{len(currencies)} currencies, \"\n        f\"and {len(references)} references.\"\n    )\n\n    endpoint = CreatePaymentDraft\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        title=title,\n        schedule_for=schedule_for,\n        payments=[\n            endpoint.Body.ModelPayment(\n                account_id=account_id,\n                receiver=endpoint.Body.ModelPayment.ModelReceiver(\n                    counterparty_id=counterparty_id,\n                    account_id=counterparty_account_id,\n                    card_id=counterparty_card_id,\n                ),\n                amount=amount,\n                currency=currency,\n                reference=reference,\n            )\n            for counterparty_id, counterparty_account_id, counterparty_card_id, amount, currency, reference in zip(\n                counterparty_ids,\n                counterparty_account_ids,\n                counterparty_card_ids,\n                amounts,\n                currencies,\n                references,\n            )\n        ],\n    )\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payment_drafts/asynchronous/#pyrevolut.api.payment_drafts.endpoint.EndpointPaymentDraftsAsync.delete_payment_draft","title":"<code>delete_payment_draft(payment_draft_id, **kwargs)</code>  <code>async</code>","text":"<p>Delete a payment draft with the given ID. You can delete a payment draft only if it isn't processed.</p> <p>Parameters:</p> Name Type Description Default <code>payment_draft_id</code> <code>UUID</code> <p>The ID of the payment draft.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the payment draft deleted.</p> Source code in <code>pyrevolut/api/payment_drafts/endpoint/asynchronous.py</code> <pre><code>async def delete_payment_draft(\n    self,\n    payment_draft_id: UUID,\n    **kwargs,\n) -&gt; dict | DeletePaymentDraft.Response:\n    \"\"\"\n    Delete a payment draft with the given ID.\n    You can delete a payment draft only if it isn't processed.\n\n    Parameters\n    ----------\n    payment_draft_id : UUID\n        The ID of the payment draft.\n\n    Returns\n    -------\n    dict | DeletePaymentDraft.Response\n        A dict with the information about the payment draft deleted.\n    \"\"\"\n    endpoint = DeletePaymentDraft\n    path = endpoint.ROUTE.format(payment_draft_id=payment_draft_id)\n    params = endpoint.Params()\n\n    return await self.client.delete(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payment_drafts/asynchronous/#pyrevolut.api.payment_drafts.endpoint.EndpointPaymentDraftsAsync.get_all_payment_drafts","title":"<code>get_all_payment_drafts(**kwargs)</code>  <code>async</code>","text":"<p>Get a list of all the payment drafts that aren't processed.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the payment drafts.</p> Source code in <code>pyrevolut/api/payment_drafts/endpoint/asynchronous.py</code> <pre><code>async def get_all_payment_drafts(\n    self,\n    **kwargs,\n) -&gt; dict | RetrieveAllPaymentDrafts.Response:\n    \"\"\"\n    Get a list of all the payment drafts that aren't processed.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    dict | RetrieveAllPaymentDrafts.Response\n        A dict with the information about the payment drafts.\n    \"\"\"\n    endpoint = RetrieveAllPaymentDrafts\n    path = endpoint.ROUTE\n    params = endpoint.Params()\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payment_drafts/asynchronous/#pyrevolut.api.payment_drafts.endpoint.EndpointPaymentDraftsAsync.get_payment_draft","title":"<code>get_payment_draft(payment_draft_id, **kwargs)</code>  <code>async</code>","text":"<p>Get the information about a specific payment draft by ID.</p> <p>Parameters:</p> Name Type Description Default <code>payment_draft_id</code> <code>UUID</code> <p>The ID of the payment draft.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the payment draft.</p> Source code in <code>pyrevolut/api/payment_drafts/endpoint/asynchronous.py</code> <pre><code>async def get_payment_draft(\n    self,\n    payment_draft_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrievePaymentDraft.Response:\n    \"\"\"\n    Get the information about a specific payment draft by ID.\n\n    Parameters\n    ----------\n    payment_draft_id : UUID\n        The ID of the payment draft.\n\n    Returns\n    -------\n    dict | RetrievePaymentDraft.Response\n        A dict with the information about the payment draft.\n    \"\"\"\n    endpoint = RetrievePaymentDraft\n    path = endpoint.ROUTE.format(payment_draft_id=payment_draft_id)\n    params = endpoint.Params()\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/","title":"Payment Drafts Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Payment Drafts</code> endpoint.</p>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrieveAllPaymentDrafts","title":"<code>RetrieveAllPaymentDrafts</code>","text":"<p>Get a list of all the payment drafts that aren't processed.</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_all_payment_drafts.py</code> <pre><code>class RetrieveAllPaymentDrafts:\n    \"\"\"\n    Get a list of all the payment drafts that aren't processed.\n    \"\"\"\n\n    ROUTE = \"/1.0/payment-drafts\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The parameters for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model for the endpoint.\n        \"\"\"\n\n        class ModelPaymentOrder(BaseModel):\n            \"\"\"A payment draft.\"\"\"\n\n            id: Annotated[UUID, Field(description=\"The ID of the payment draft.\")]\n            scheduled_for: Annotated[\n                Date | None,\n                Field(\n                    description=\"The scheduled date of the payment draft in ISO 8601 format.\"\n                ),\n            ] = None\n            title: Annotated[\n                str | None,\n                Field(description=\"The title of the payment draft.\"),\n            ] = None\n            payment_counts: Annotated[\n                int,\n                Field(description=\"The number of payments in the payment draft.\", ge=0),\n            ]\n\n        payment_orders: Annotated[\n            list[ModelPaymentOrder],\n            Field(description=\"The list of payment drafts.\"),\n        ]\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrieveAllPaymentDrafts.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The parameters for the endpoint.</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_all_payment_drafts.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The parameters for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrieveAllPaymentDrafts.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model for the endpoint.</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_all_payment_drafts.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model for the endpoint.\n    \"\"\"\n\n    class ModelPaymentOrder(BaseModel):\n        \"\"\"A payment draft.\"\"\"\n\n        id: Annotated[UUID, Field(description=\"The ID of the payment draft.\")]\n        scheduled_for: Annotated[\n            Date | None,\n            Field(\n                description=\"The scheduled date of the payment draft in ISO 8601 format.\"\n            ),\n        ] = None\n        title: Annotated[\n            str | None,\n            Field(description=\"The title of the payment draft.\"),\n        ] = None\n        payment_counts: Annotated[\n            int,\n            Field(description=\"The number of payments in the payment draft.\", ge=0),\n        ]\n\n    payment_orders: Annotated[\n        list[ModelPaymentOrder],\n        Field(description=\"The list of payment drafts.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrieveAllPaymentDrafts.Response.ModelPaymentOrder","title":"<code>ModelPaymentOrder</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A payment draft.</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_all_payment_drafts.py</code> <pre><code>class ModelPaymentOrder(BaseModel):\n    \"\"\"A payment draft.\"\"\"\n\n    id: Annotated[UUID, Field(description=\"The ID of the payment draft.\")]\n    scheduled_for: Annotated[\n        Date | None,\n        Field(\n            description=\"The scheduled date of the payment draft in ISO 8601 format.\"\n        ),\n    ] = None\n    title: Annotated[\n        str | None,\n        Field(description=\"The title of the payment draft.\"),\n    ] = None\n    payment_counts: Annotated[\n        int,\n        Field(description=\"The number of payments in the payment draft.\", ge=0),\n    ]\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrievePaymentDraft","title":"<code>RetrievePaymentDraft</code>","text":"<p>Get the information about a specific payment draft by ID.</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_payment_draft.py</code> <pre><code>class RetrievePaymentDraft:\n    \"\"\"\n    Get the information about a specific payment draft by ID.\n    \"\"\"\n\n    ROUTE = \"/1.0/payment-drafts/{payment_draft_id}\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The parameters for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model for the endpoint.\n        \"\"\"\n\n        class ModelPayment(BaseModel):\n            \"\"\"A payment draft.\"\"\"\n\n            class ModelAmount(ModelBaseAmount):\n                \"\"\"The amount of the payment draft.\"\"\"\n\n                pass\n\n            class ModelReceiver(BaseModel):\n                \"\"\"The details of the transfer recipient.\n\n                If the counterparty has multiple payment methods available\n                (e.g. 2 accounts, or 1 account and 1 card), you must specify the\n                account (account_id) or card (card_id) to which you want to transfer the money.\n                \"\"\"\n\n                counterparty_id: Annotated[\n                    UUID,\n                    Field(description=\"The ID of the receiving counterparty.\"),\n                ]\n                account_id: Annotated[\n                    UUID | None,\n                    Field(\n                        description=\"\"\"\n                        The ID of the receiving counterparty's account, which can be own account. \n                        Used for bank transfers.\n\n                        If the counterparty has multiple payment methods available, use it to \n                        specify the account to which you want to send the money.\n                        \"\"\"\n                    ),\n                ] = None\n                card_id: Annotated[\n                    UUID | None,\n                    Field(\n                        description=\"\"\"\n                        The ID of the receiving counterparty's card. Used for card transfers.\n\n                        If the counterparty has multiple payment methods available, use it to \n                        specify the card to which you want to send the money.\n                        \"\"\"\n                    ),\n                ] = None\n\n            class ModelCurrentChargeOptions(BaseModel):\n                \"\"\"The explanation of conversion process\"\"\"\n\n                model_config = ConfigDict(\n                    populate_by_name=True,\n                    from_attributes=True,\n                )\n\n                class ModelFrom(ModelBaseAmount):\n                    \"\"\"The source of the conversion\"\"\"\n\n                    pass\n\n                class ModelTo(ModelBaseAmount):\n                    \"\"\"The target of the conversion\"\"\"\n\n                    pass\n\n                class ModelFee(ModelBaseAmount):\n                    \"\"\"The fee of the conversion\"\"\"\n\n                    pass\n\n                from_: Annotated[\n                    ModelFrom,\n                    Field(alias=\"from\", description=\"The source of the conversion.\"),\n                ]\n                to: Annotated[\n                    ModelTo,\n                    Field(description=\"The target of the conversion.\"),\n                ]\n                rate: Annotated[\n                    float | None,\n                    Field(description=\"The exchange rate used for the conversion.\"),\n                ] = None\n                fee: Annotated[\n                    ModelFee | None,\n                    Field(description=\"The fee of the conversion.\"),\n                ] = None\n\n            id: Annotated[UUID, Field(description=\"The ID of the payment draft.\")]\n            amount: Annotated[\n                ModelAmount,\n                Field(description=\"The amount of the payment draft.\"),\n            ]\n            currency: Annotated[\n                Currency | None,\n                Field(description=\"The currency of the payment draft.\"),\n            ] = None\n            account_id: Annotated[\n                UUID,\n                Field(description=\"The ID of the account to pay from.\"),\n            ]\n            receiver: Annotated[\n                ModelReceiver,\n                Field(\n                    description=\"\"\"\n                    The details of the transfer recipient.\n\n                    If the counterparty has multiple payment methods available \n                    (e.g. 2 accounts, or 1 account and 1 card), you must specify the \n                    account (account_id) or card (card_id) to which you want to transfer the money.\n                    \"\"\"\n                ),\n            ]\n            state: Annotated[\n                EnumPaymentDraftState,\n                Field(description=\"The state of the payment draft.\"),\n            ]\n            reason: Annotated[\n                str | None,\n                Field(description=\"The reason for the payment draft state.\"),\n            ] = None\n            error_message: Annotated[\n                str | None,\n                Field(description=\"The description of the error message.\"),\n            ] = None\n            current_charge_options: Annotated[\n                ModelCurrentChargeOptions,\n                Field(description=\"The explanation of conversion process.\"),\n            ]\n            reference: Annotated[\n                str | None,\n                Field(description=\"The description of the transaction.\"),\n            ] = None\n\n        scheduled_for: Annotated[\n            Date | None,\n            Field(\n                description=\"The scheduled date of the payment draft in ISO 8601 format.\"\n            ),\n        ] = None\n        title: Annotated[\n            str | None,\n            Field(description=\"The title of the payment draft.\"),\n        ] = None\n        payments: Annotated[\n            list[ModelPayment],\n            Field(description=\"The list of payment drafts.\"),\n        ]\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrievePaymentDraft.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The parameters for the endpoint.</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_payment_draft.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The parameters for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrievePaymentDraft.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model for the endpoint.</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_payment_draft.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model for the endpoint.\n    \"\"\"\n\n    class ModelPayment(BaseModel):\n        \"\"\"A payment draft.\"\"\"\n\n        class ModelAmount(ModelBaseAmount):\n            \"\"\"The amount of the payment draft.\"\"\"\n\n            pass\n\n        class ModelReceiver(BaseModel):\n            \"\"\"The details of the transfer recipient.\n\n            If the counterparty has multiple payment methods available\n            (e.g. 2 accounts, or 1 account and 1 card), you must specify the\n            account (account_id) or card (card_id) to which you want to transfer the money.\n            \"\"\"\n\n            counterparty_id: Annotated[\n                UUID,\n                Field(description=\"The ID of the receiving counterparty.\"),\n            ]\n            account_id: Annotated[\n                UUID | None,\n                Field(\n                    description=\"\"\"\n                    The ID of the receiving counterparty's account, which can be own account. \n                    Used for bank transfers.\n\n                    If the counterparty has multiple payment methods available, use it to \n                    specify the account to which you want to send the money.\n                    \"\"\"\n                ),\n            ] = None\n            card_id: Annotated[\n                UUID | None,\n                Field(\n                    description=\"\"\"\n                    The ID of the receiving counterparty's card. Used for card transfers.\n\n                    If the counterparty has multiple payment methods available, use it to \n                    specify the card to which you want to send the money.\n                    \"\"\"\n                ),\n            ] = None\n\n        class ModelCurrentChargeOptions(BaseModel):\n            \"\"\"The explanation of conversion process\"\"\"\n\n            model_config = ConfigDict(\n                populate_by_name=True,\n                from_attributes=True,\n            )\n\n            class ModelFrom(ModelBaseAmount):\n                \"\"\"The source of the conversion\"\"\"\n\n                pass\n\n            class ModelTo(ModelBaseAmount):\n                \"\"\"The target of the conversion\"\"\"\n\n                pass\n\n            class ModelFee(ModelBaseAmount):\n                \"\"\"The fee of the conversion\"\"\"\n\n                pass\n\n            from_: Annotated[\n                ModelFrom,\n                Field(alias=\"from\", description=\"The source of the conversion.\"),\n            ]\n            to: Annotated[\n                ModelTo,\n                Field(description=\"The target of the conversion.\"),\n            ]\n            rate: Annotated[\n                float | None,\n                Field(description=\"The exchange rate used for the conversion.\"),\n            ] = None\n            fee: Annotated[\n                ModelFee | None,\n                Field(description=\"The fee of the conversion.\"),\n            ] = None\n\n        id: Annotated[UUID, Field(description=\"The ID of the payment draft.\")]\n        amount: Annotated[\n            ModelAmount,\n            Field(description=\"The amount of the payment draft.\"),\n        ]\n        currency: Annotated[\n            Currency | None,\n            Field(description=\"The currency of the payment draft.\"),\n        ] = None\n        account_id: Annotated[\n            UUID,\n            Field(description=\"The ID of the account to pay from.\"),\n        ]\n        receiver: Annotated[\n            ModelReceiver,\n            Field(\n                description=\"\"\"\n                The details of the transfer recipient.\n\n                If the counterparty has multiple payment methods available \n                (e.g. 2 accounts, or 1 account and 1 card), you must specify the \n                account (account_id) or card (card_id) to which you want to transfer the money.\n                \"\"\"\n            ),\n        ]\n        state: Annotated[\n            EnumPaymentDraftState,\n            Field(description=\"The state of the payment draft.\"),\n        ]\n        reason: Annotated[\n            str | None,\n            Field(description=\"The reason for the payment draft state.\"),\n        ] = None\n        error_message: Annotated[\n            str | None,\n            Field(description=\"The description of the error message.\"),\n        ] = None\n        current_charge_options: Annotated[\n            ModelCurrentChargeOptions,\n            Field(description=\"The explanation of conversion process.\"),\n        ]\n        reference: Annotated[\n            str | None,\n            Field(description=\"The description of the transaction.\"),\n        ] = None\n\n    scheduled_for: Annotated[\n        Date | None,\n        Field(\n            description=\"The scheduled date of the payment draft in ISO 8601 format.\"\n        ),\n    ] = None\n    title: Annotated[\n        str | None,\n        Field(description=\"The title of the payment draft.\"),\n    ] = None\n    payments: Annotated[\n        list[ModelPayment],\n        Field(description=\"The list of payment drafts.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrievePaymentDraft.Response.ModelPayment","title":"<code>ModelPayment</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A payment draft.</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_payment_draft.py</code> <pre><code>class ModelPayment(BaseModel):\n    \"\"\"A payment draft.\"\"\"\n\n    class ModelAmount(ModelBaseAmount):\n        \"\"\"The amount of the payment draft.\"\"\"\n\n        pass\n\n    class ModelReceiver(BaseModel):\n        \"\"\"The details of the transfer recipient.\n\n        If the counterparty has multiple payment methods available\n        (e.g. 2 accounts, or 1 account and 1 card), you must specify the\n        account (account_id) or card (card_id) to which you want to transfer the money.\n        \"\"\"\n\n        counterparty_id: Annotated[\n            UUID,\n            Field(description=\"The ID of the receiving counterparty.\"),\n        ]\n        account_id: Annotated[\n            UUID | None,\n            Field(\n                description=\"\"\"\n                The ID of the receiving counterparty's account, which can be own account. \n                Used for bank transfers.\n\n                If the counterparty has multiple payment methods available, use it to \n                specify the account to which you want to send the money.\n                \"\"\"\n            ),\n        ] = None\n        card_id: Annotated[\n            UUID | None,\n            Field(\n                description=\"\"\"\n                The ID of the receiving counterparty's card. Used for card transfers.\n\n                If the counterparty has multiple payment methods available, use it to \n                specify the card to which you want to send the money.\n                \"\"\"\n            ),\n        ] = None\n\n    class ModelCurrentChargeOptions(BaseModel):\n        \"\"\"The explanation of conversion process\"\"\"\n\n        model_config = ConfigDict(\n            populate_by_name=True,\n            from_attributes=True,\n        )\n\n        class ModelFrom(ModelBaseAmount):\n            \"\"\"The source of the conversion\"\"\"\n\n            pass\n\n        class ModelTo(ModelBaseAmount):\n            \"\"\"The target of the conversion\"\"\"\n\n            pass\n\n        class ModelFee(ModelBaseAmount):\n            \"\"\"The fee of the conversion\"\"\"\n\n            pass\n\n        from_: Annotated[\n            ModelFrom,\n            Field(alias=\"from\", description=\"The source of the conversion.\"),\n        ]\n        to: Annotated[\n            ModelTo,\n            Field(description=\"The target of the conversion.\"),\n        ]\n        rate: Annotated[\n            float | None,\n            Field(description=\"The exchange rate used for the conversion.\"),\n        ] = None\n        fee: Annotated[\n            ModelFee | None,\n            Field(description=\"The fee of the conversion.\"),\n        ] = None\n\n    id: Annotated[UUID, Field(description=\"The ID of the payment draft.\")]\n    amount: Annotated[\n        ModelAmount,\n        Field(description=\"The amount of the payment draft.\"),\n    ]\n    currency: Annotated[\n        Currency | None,\n        Field(description=\"The currency of the payment draft.\"),\n    ] = None\n    account_id: Annotated[\n        UUID,\n        Field(description=\"The ID of the account to pay from.\"),\n    ]\n    receiver: Annotated[\n        ModelReceiver,\n        Field(\n            description=\"\"\"\n            The details of the transfer recipient.\n\n            If the counterparty has multiple payment methods available \n            (e.g. 2 accounts, or 1 account and 1 card), you must specify the \n            account (account_id) or card (card_id) to which you want to transfer the money.\n            \"\"\"\n        ),\n    ]\n    state: Annotated[\n        EnumPaymentDraftState,\n        Field(description=\"The state of the payment draft.\"),\n    ]\n    reason: Annotated[\n        str | None,\n        Field(description=\"The reason for the payment draft state.\"),\n    ] = None\n    error_message: Annotated[\n        str | None,\n        Field(description=\"The description of the error message.\"),\n    ] = None\n    current_charge_options: Annotated[\n        ModelCurrentChargeOptions,\n        Field(description=\"The explanation of conversion process.\"),\n    ]\n    reference: Annotated[\n        str | None,\n        Field(description=\"The description of the transaction.\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrievePaymentDraft.Response.ModelPayment.ModelAmount","title":"<code>ModelAmount</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The amount of the payment draft.</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_payment_draft.py</code> <pre><code>class ModelAmount(ModelBaseAmount):\n    \"\"\"The amount of the payment draft.\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrievePaymentDraft.Response.ModelPayment.ModelCurrentChargeOptions","title":"<code>ModelCurrentChargeOptions</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The explanation of conversion process</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_payment_draft.py</code> <pre><code>class ModelCurrentChargeOptions(BaseModel):\n    \"\"\"The explanation of conversion process\"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        from_attributes=True,\n    )\n\n    class ModelFrom(ModelBaseAmount):\n        \"\"\"The source of the conversion\"\"\"\n\n        pass\n\n    class ModelTo(ModelBaseAmount):\n        \"\"\"The target of the conversion\"\"\"\n\n        pass\n\n    class ModelFee(ModelBaseAmount):\n        \"\"\"The fee of the conversion\"\"\"\n\n        pass\n\n    from_: Annotated[\n        ModelFrom,\n        Field(alias=\"from\", description=\"The source of the conversion.\"),\n    ]\n    to: Annotated[\n        ModelTo,\n        Field(description=\"The target of the conversion.\"),\n    ]\n    rate: Annotated[\n        float | None,\n        Field(description=\"The exchange rate used for the conversion.\"),\n    ] = None\n    fee: Annotated[\n        ModelFee | None,\n        Field(description=\"The fee of the conversion.\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrievePaymentDraft.Response.ModelPayment.ModelCurrentChargeOptions.ModelFee","title":"<code>ModelFee</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The fee of the conversion</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_payment_draft.py</code> <pre><code>class ModelFee(ModelBaseAmount):\n    \"\"\"The fee of the conversion\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrievePaymentDraft.Response.ModelPayment.ModelCurrentChargeOptions.ModelFrom","title":"<code>ModelFrom</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The source of the conversion</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_payment_draft.py</code> <pre><code>class ModelFrom(ModelBaseAmount):\n    \"\"\"The source of the conversion\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrievePaymentDraft.Response.ModelPayment.ModelCurrentChargeOptions.ModelTo","title":"<code>ModelTo</code>","text":"<p>               Bases: <code>ModelBaseAmount</code></p> <p>The target of the conversion</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_payment_draft.py</code> <pre><code>class ModelTo(ModelBaseAmount):\n    \"\"\"The target of the conversion\"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.get.RetrievePaymentDraft.Response.ModelPayment.ModelReceiver","title":"<code>ModelReceiver</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The details of the transfer recipient.</p> <p>If the counterparty has multiple payment methods available (e.g. 2 accounts, or 1 account and 1 card), you must specify the account (account_id) or card (card_id) to which you want to transfer the money.</p> Source code in <code>pyrevolut/api/payment_drafts/get/retrieve_payment_draft.py</code> <pre><code>class ModelReceiver(BaseModel):\n    \"\"\"The details of the transfer recipient.\n\n    If the counterparty has multiple payment methods available\n    (e.g. 2 accounts, or 1 account and 1 card), you must specify the\n    account (account_id) or card (card_id) to which you want to transfer the money.\n    \"\"\"\n\n    counterparty_id: Annotated[\n        UUID,\n        Field(description=\"The ID of the receiving counterparty.\"),\n    ]\n    account_id: Annotated[\n        UUID | None,\n        Field(\n            description=\"\"\"\n            The ID of the receiving counterparty's account, which can be own account. \n            Used for bank transfers.\n\n            If the counterparty has multiple payment methods available, use it to \n            specify the account to which you want to send the money.\n            \"\"\"\n        ),\n    ] = None\n    card_id: Annotated[\n        UUID | None,\n        Field(\n            description=\"\"\"\n            The ID of the receiving counterparty's card. Used for card transfers.\n\n            If the counterparty has multiple payment methods available, use it to \n            specify the card to which you want to send the money.\n            \"\"\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.post.CreatePaymentDraft","title":"<code>CreatePaymentDraft</code>","text":"<p>Create a payment draft.</p> Source code in <code>pyrevolut/api/payment_drafts/post/create_payment_draft.py</code> <pre><code>class CreatePaymentDraft:\n    \"\"\"\n    Create a payment draft.\n    \"\"\"\n\n    ROUTE = \"/1.0/payment-drafts\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The body model for the endpoint.\n        \"\"\"\n\n        class ModelPayment(BaseModel):\n            \"\"\"The details of a payment\"\"\"\n\n            class ModelReceiver(BaseModel):\n                \"\"\"The details of the transfer recipient.\n\n                If the counterparty has multiple payment methods available\n                (e.g. 2 accounts, or 1 account and 1 card), you must specify the\n                account (account_id) or card (card_id) to which you want to transfer the money.\n                \"\"\"\n\n                counterparty_id: Annotated[\n                    UUID,\n                    Field(description=\"The ID of the receiving counterparty.\"),\n                ]\n                account_id: Annotated[\n                    UUID | None,\n                    Field(\n                        description=\"\"\"\n                        The ID of the receiving counterparty's account, which can be own account. \n                        Used for bank transfers.\n\n                        If the counterparty has multiple payment methods available, use it to \n                        specify the account to which you want to send the money.\n                        \"\"\"\n                    ),\n                ] = None\n                card_id: Annotated[\n                    UUID | None,\n                    Field(\n                        description=\"\"\"\n                        The ID of the receiving counterparty's card. Used for card transfers.\n\n                        If the counterparty has multiple payment methods available, use it to \n                        specify the card to which you want to send the money.\n                        \"\"\"\n                    ),\n                ] = None\n\n            account_id: Annotated[\n                UUID,\n                Field(\n                    description=\"\"\"\n                    The ID of the account to pay from.\n                    You can specify only one account ID for multiple payments in the same payment draft.\n                    \"\"\"\n                ),\n            ]\n            receiver: Annotated[\n                ModelReceiver,\n                Field(\n                    description=\"\"\"\n                    The details of the transfer recipient.\n\n                    If the counterparty has multiple payment methods available \n                    (e.g. 2 accounts, or 1 account and 1 card), you must specify the \n                    account (account_id) or card (card_id) to which you want to transfer the money.\n                    \"\"\"\n                ),\n            ]\n            amount: Annotated[\n                float,\n                Field(description=\"The amount of the payment.\"),\n            ]\n            currency: Annotated[\n                Currency,\n                Field(description=\"ISO 4217 currency code in upper case.\"),\n            ]\n            reference: Annotated[\n                str,\n                Field(description=\"The reference for the payment.\"),\n            ]\n\n        title: Annotated[\n            str | None,\n            Field(description=\"The title of the payment draft.\"),\n        ] = None\n        schedule_for: Annotated[\n            Date | None,\n            Field(\n                description=\"The scheduled date of the payment draft in ISO 8601 format.\"\n            ),\n        ] = None\n        payments: Annotated[\n            list[ModelPayment],\n            Field(description=\"The details of the payments.\"),\n        ]\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model for the endpoint.\n        \"\"\"\n\n        id: Annotated[UUID, Field(description=\"The ID of the payment draft created.\")]\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.post.CreatePaymentDraft.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The body model for the endpoint.</p> Source code in <code>pyrevolut/api/payment_drafts/post/create_payment_draft.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The body model for the endpoint.\n    \"\"\"\n\n    class ModelPayment(BaseModel):\n        \"\"\"The details of a payment\"\"\"\n\n        class ModelReceiver(BaseModel):\n            \"\"\"The details of the transfer recipient.\n\n            If the counterparty has multiple payment methods available\n            (e.g. 2 accounts, or 1 account and 1 card), you must specify the\n            account (account_id) or card (card_id) to which you want to transfer the money.\n            \"\"\"\n\n            counterparty_id: Annotated[\n                UUID,\n                Field(description=\"The ID of the receiving counterparty.\"),\n            ]\n            account_id: Annotated[\n                UUID | None,\n                Field(\n                    description=\"\"\"\n                    The ID of the receiving counterparty's account, which can be own account. \n                    Used for bank transfers.\n\n                    If the counterparty has multiple payment methods available, use it to \n                    specify the account to which you want to send the money.\n                    \"\"\"\n                ),\n            ] = None\n            card_id: Annotated[\n                UUID | None,\n                Field(\n                    description=\"\"\"\n                    The ID of the receiving counterparty's card. Used for card transfers.\n\n                    If the counterparty has multiple payment methods available, use it to \n                    specify the card to which you want to send the money.\n                    \"\"\"\n                ),\n            ] = None\n\n        account_id: Annotated[\n            UUID,\n            Field(\n                description=\"\"\"\n                The ID of the account to pay from.\n                You can specify only one account ID for multiple payments in the same payment draft.\n                \"\"\"\n            ),\n        ]\n        receiver: Annotated[\n            ModelReceiver,\n            Field(\n                description=\"\"\"\n                The details of the transfer recipient.\n\n                If the counterparty has multiple payment methods available \n                (e.g. 2 accounts, or 1 account and 1 card), you must specify the \n                account (account_id) or card (card_id) to which you want to transfer the money.\n                \"\"\"\n            ),\n        ]\n        amount: Annotated[\n            float,\n            Field(description=\"The amount of the payment.\"),\n        ]\n        currency: Annotated[\n            Currency,\n            Field(description=\"ISO 4217 currency code in upper case.\"),\n        ]\n        reference: Annotated[\n            str,\n            Field(description=\"The reference for the payment.\"),\n        ]\n\n    title: Annotated[\n        str | None,\n        Field(description=\"The title of the payment draft.\"),\n    ] = None\n    schedule_for: Annotated[\n        Date | None,\n        Field(\n            description=\"The scheduled date of the payment draft in ISO 8601 format.\"\n        ),\n    ] = None\n    payments: Annotated[\n        list[ModelPayment],\n        Field(description=\"The details of the payments.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.post.CreatePaymentDraft.Body.ModelPayment","title":"<code>ModelPayment</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The details of a payment</p> Source code in <code>pyrevolut/api/payment_drafts/post/create_payment_draft.py</code> <pre><code>class ModelPayment(BaseModel):\n    \"\"\"The details of a payment\"\"\"\n\n    class ModelReceiver(BaseModel):\n        \"\"\"The details of the transfer recipient.\n\n        If the counterparty has multiple payment methods available\n        (e.g. 2 accounts, or 1 account and 1 card), you must specify the\n        account (account_id) or card (card_id) to which you want to transfer the money.\n        \"\"\"\n\n        counterparty_id: Annotated[\n            UUID,\n            Field(description=\"The ID of the receiving counterparty.\"),\n        ]\n        account_id: Annotated[\n            UUID | None,\n            Field(\n                description=\"\"\"\n                The ID of the receiving counterparty's account, which can be own account. \n                Used for bank transfers.\n\n                If the counterparty has multiple payment methods available, use it to \n                specify the account to which you want to send the money.\n                \"\"\"\n            ),\n        ] = None\n        card_id: Annotated[\n            UUID | None,\n            Field(\n                description=\"\"\"\n                The ID of the receiving counterparty's card. Used for card transfers.\n\n                If the counterparty has multiple payment methods available, use it to \n                specify the card to which you want to send the money.\n                \"\"\"\n            ),\n        ] = None\n\n    account_id: Annotated[\n        UUID,\n        Field(\n            description=\"\"\"\n            The ID of the account to pay from.\n            You can specify only one account ID for multiple payments in the same payment draft.\n            \"\"\"\n        ),\n    ]\n    receiver: Annotated[\n        ModelReceiver,\n        Field(\n            description=\"\"\"\n            The details of the transfer recipient.\n\n            If the counterparty has multiple payment methods available \n            (e.g. 2 accounts, or 1 account and 1 card), you must specify the \n            account (account_id) or card (card_id) to which you want to transfer the money.\n            \"\"\"\n        ),\n    ]\n    amount: Annotated[\n        float,\n        Field(description=\"The amount of the payment.\"),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(description=\"ISO 4217 currency code in upper case.\"),\n    ]\n    reference: Annotated[\n        str,\n        Field(description=\"The reference for the payment.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.post.CreatePaymentDraft.Body.ModelPayment.ModelReceiver","title":"<code>ModelReceiver</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The details of the transfer recipient.</p> <p>If the counterparty has multiple payment methods available (e.g. 2 accounts, or 1 account and 1 card), you must specify the account (account_id) or card (card_id) to which you want to transfer the money.</p> Source code in <code>pyrevolut/api/payment_drafts/post/create_payment_draft.py</code> <pre><code>class ModelReceiver(BaseModel):\n    \"\"\"The details of the transfer recipient.\n\n    If the counterparty has multiple payment methods available\n    (e.g. 2 accounts, or 1 account and 1 card), you must specify the\n    account (account_id) or card (card_id) to which you want to transfer the money.\n    \"\"\"\n\n    counterparty_id: Annotated[\n        UUID,\n        Field(description=\"The ID of the receiving counterparty.\"),\n    ]\n    account_id: Annotated[\n        UUID | None,\n        Field(\n            description=\"\"\"\n            The ID of the receiving counterparty's account, which can be own account. \n            Used for bank transfers.\n\n            If the counterparty has multiple payment methods available, use it to \n            specify the account to which you want to send the money.\n            \"\"\"\n        ),\n    ] = None\n    card_id: Annotated[\n        UUID | None,\n        Field(\n            description=\"\"\"\n            The ID of the receiving counterparty's card. Used for card transfers.\n\n            If the counterparty has multiple payment methods available, use it to \n            specify the card to which you want to send the money.\n            \"\"\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.post.CreatePaymentDraft.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model for the endpoint.</p> Source code in <code>pyrevolut/api/payment_drafts/post/create_payment_draft.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model for the endpoint.\n    \"\"\"\n\n    id: Annotated[UUID, Field(description=\"The ID of the payment draft created.\")]\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.delete.DeletePaymentDraft","title":"<code>DeletePaymentDraft</code>","text":"<p>Delete a payment draft with the given ID. You can delete a payment draft only if it isn't processed.</p> Source code in <code>pyrevolut/api/payment_drafts/delete/delete_payment_draft.py</code> <pre><code>class DeletePaymentDraft:\n    \"\"\"\n    Delete a payment draft with the given ID.\n    You can delete a payment draft only if it isn't processed.\n    \"\"\"\n\n    ROUTE = \"/1.0/payment-drafts/{payment_draft_id}\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The parameters for the endpoint.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model for the endpoint.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.delete.DeletePaymentDraft.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The parameters for the endpoint.</p> Source code in <code>pyrevolut/api/payment_drafts/delete/delete_payment_draft.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The parameters for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payment_drafts/pydantic/#pyrevolut.api.payment_drafts.delete.DeletePaymentDraft.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model for the endpoint.</p> Source code in <code>pyrevolut/api/payment_drafts/delete/delete_payment_draft.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model for the endpoint.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payment_drafts/synchronous/","title":"Payment Drafts Synchronous Endpoints","text":"<p>This <code>Payment Drafts</code> endpoint provides methods to interact with the payment drafts of the authenticated user.</p> <p>Example usage of the Payment Drafts endpoint object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    drafts = client.PaymentDrafts.get_all_payment_drafts()\n    print(drafts)\n</code></pre>"},{"location":"code_reference/api/payment_drafts/synchronous/#pyrevolut.api.payment_drafts.endpoint.EndpointPaymentDraftsSync","title":"<code>EndpointPaymentDraftsSync</code>","text":"<p>               Bases: <code>BaseEndpointSync</code></p> <p>The Payment Drafts API</p> <p>Create a payment draft to request an approval for a payment from a business owner or admin before the payment is executed. The business owner or admin must manually approve it in the Revolut Business User Interface.</p> <p>You can also retrieve one or all payment drafts, and delete a payment draft.</p> Source code in <code>pyrevolut/api/payment_drafts/endpoint/synchronous.py</code> <pre><code>class EndpointPaymentDraftsSync(BaseEndpointSync):\n    \"\"\"The Payment Drafts API\n\n    Create a payment draft to request an approval for a payment from a\n    business owner or admin before the payment is executed.\n    The business owner or admin must manually approve it in the\n    Revolut Business User Interface.\n\n    You can also retrieve one or all payment drafts, and delete a payment draft.\n    \"\"\"\n\n    def get_all_payment_drafts(\n        self,\n        **kwargs,\n    ) -&gt; dict | RetrieveAllPaymentDrafts.Response:\n        \"\"\"\n        Get a list of all the payment drafts that aren't processed.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        dict | RetrieveAllPaymentDrafts.Response\n            A dict with the information about the payment drafts.\n        \"\"\"\n        endpoint = RetrieveAllPaymentDrafts\n        path = endpoint.ROUTE\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_payment_draft(\n        self,\n        payment_draft_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrievePaymentDraft.Response:\n        \"\"\"\n        Get the information about a specific payment draft by ID.\n\n        Parameters\n        ----------\n        payment_draft_id : UUID\n            The ID of the payment draft.\n\n        Returns\n        -------\n        dict | RetrievePaymentDraft.Response\n            A dict with the information about the payment draft.\n        \"\"\"\n        endpoint = RetrievePaymentDraft\n        path = endpoint.ROUTE.format(payment_draft_id=payment_draft_id)\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def create_payment_draft(\n        self,\n        account_id: UUID,\n        counterparty_ids: list[UUID] = [],\n        counterparty_account_ids: list[UUID | None] = [],\n        counterparty_card_ids: list[UUID | None] = [],\n        amounts: list[float] = [],\n        currencies: list[str] = [],\n        references: list[str] = [],\n        title: str | None = None,\n        schedule_for: date | Date | str | None = None,\n        **kwargs,\n    ) -&gt; dict | CreatePaymentDraft.Response:\n        \"\"\"\n        Create a payment draft.\n\n        Parameters\n        ----------\n        account_id : UUID\n            The ID of the account to pay from.\n        counterparty_ids : list[UUID]\n            The IDs of the counterparty accounts. Each ID corresponds to a payment.\n        counterparty_account_ids : list[UUID | None]\n            The IDs of the counterparty accounts. Each ID corresponds to a payment.\n            If the counterparty has multiple payment methods available, use it to\n            specify the account to which you want to send the money. Otherwise, use None.\n        counterparty_card_ids : list[UUID | None]\n            The IDs of the counterparty cards. Each ID corresponds to a payment.\n            If the counterparty has multiple payment methods available, use it to\n            specify the card to which you want to send the money. Otherwise, use None.\n        amounts : list[float]\n            The amounts of the payments.\n        currencies : list[str]\n            The ISO 4217 currency codes in upper case.\n        references : list[str]\n            The references for the payments.\n        title : str, optional\n            The title of the payment draft.\n        schedule_for : date | Date | str, optional\n            The scheduled date of the payment draft in ISO 8601 format.\n\n        Returns\n        -------\n        dict | CreatePaymentDraft.Response\n            A dict with the information about the payment draft created.\n        \"\"\"\n        assert (\n            len(counterparty_ids)\n            == len(counterparty_account_ids)\n            == len(counterparty_card_ids)\n            == len(amounts)\n            == len(currencies)\n            == len(references)\n        ), (\n            \"The number of elements in the lists must be equal. \"\n            f\"Got {len(counterparty_ids)} counterparty_ids, \"\n            f\"{len(counterparty_account_ids)} counterparty_account_ids, \"\n            f\"{len(counterparty_card_ids)} counterparty_card_ids, \"\n            f\"{len(amounts)} amounts, \"\n            f\"{len(currencies)} currencies, \"\n            f\"and {len(references)} references.\"\n        )\n\n        endpoint = CreatePaymentDraft\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            title=title,\n            schedule_for=schedule_for,\n            payments=[\n                endpoint.Body.ModelPayment(\n                    account_id=account_id,\n                    receiver=endpoint.Body.ModelPayment.ModelReceiver(\n                        counterparty_id=counterparty_id,\n                        account_id=counterparty_account_id,\n                        card_id=counterparty_card_id,\n                    ),\n                    amount=amount,\n                    currency=currency,\n                    reference=reference,\n                )\n                for counterparty_id, counterparty_account_id, counterparty_card_id, amount, currency, reference in zip(\n                    counterparty_ids,\n                    counterparty_account_ids,\n                    counterparty_card_ids,\n                    amounts,\n                    currencies,\n                    references,\n                )\n            ],\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def delete_payment_draft(\n        self,\n        payment_draft_id: UUID,\n        **kwargs,\n    ) -&gt; dict | DeletePaymentDraft.Response:\n        \"\"\"\n        Delete a payment draft with the given ID.\n        You can delete a payment draft only if it isn't processed.\n\n        Parameters\n        ----------\n        payment_draft_id : UUID\n            The ID of the payment draft.\n\n        Returns\n        -------\n        dict | DeletePaymentDraft.Response\n            A dict with the information about the payment draft deleted.\n        \"\"\"\n        endpoint = DeletePaymentDraft\n        path = endpoint.ROUTE.format(payment_draft_id=payment_draft_id)\n        params = endpoint.Params()\n\n        return self.client.delete(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/payment_drafts/synchronous/#pyrevolut.api.payment_drafts.endpoint.EndpointPaymentDraftsSync.create_payment_draft","title":"<code>create_payment_draft(account_id, counterparty_ids=[], counterparty_account_ids=[], counterparty_card_ids=[], amounts=[], currencies=[], references=[], title=None, schedule_for=None, **kwargs)</code>","text":"<p>Create a payment draft.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>UUID</code> <p>The ID of the account to pay from.</p> required <code>counterparty_ids</code> <code>list[UUID]</code> <p>The IDs of the counterparty accounts. Each ID corresponds to a payment.</p> <code>[]</code> <code>counterparty_account_ids</code> <code>list[UUID | None]</code> <p>The IDs of the counterparty accounts. Each ID corresponds to a payment. If the counterparty has multiple payment methods available, use it to specify the account to which you want to send the money. Otherwise, use None.</p> <code>[]</code> <code>counterparty_card_ids</code> <code>list[UUID | None]</code> <p>The IDs of the counterparty cards. Each ID corresponds to a payment. If the counterparty has multiple payment methods available, use it to specify the card to which you want to send the money. Otherwise, use None.</p> <code>[]</code> <code>amounts</code> <code>list[float]</code> <p>The amounts of the payments.</p> <code>[]</code> <code>currencies</code> <code>list[str]</code> <p>The ISO 4217 currency codes in upper case.</p> <code>[]</code> <code>references</code> <code>list[str]</code> <p>The references for the payments.</p> <code>[]</code> <code>title</code> <code>str</code> <p>The title of the payment draft.</p> <code>None</code> <code>schedule_for</code> <code>date | Date | str</code> <p>The scheduled date of the payment draft in ISO 8601 format.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the payment draft created.</p> Source code in <code>pyrevolut/api/payment_drafts/endpoint/synchronous.py</code> <pre><code>def create_payment_draft(\n    self,\n    account_id: UUID,\n    counterparty_ids: list[UUID] = [],\n    counterparty_account_ids: list[UUID | None] = [],\n    counterparty_card_ids: list[UUID | None] = [],\n    amounts: list[float] = [],\n    currencies: list[str] = [],\n    references: list[str] = [],\n    title: str | None = None,\n    schedule_for: date | Date | str | None = None,\n    **kwargs,\n) -&gt; dict | CreatePaymentDraft.Response:\n    \"\"\"\n    Create a payment draft.\n\n    Parameters\n    ----------\n    account_id : UUID\n        The ID of the account to pay from.\n    counterparty_ids : list[UUID]\n        The IDs of the counterparty accounts. Each ID corresponds to a payment.\n    counterparty_account_ids : list[UUID | None]\n        The IDs of the counterparty accounts. Each ID corresponds to a payment.\n        If the counterparty has multiple payment methods available, use it to\n        specify the account to which you want to send the money. Otherwise, use None.\n    counterparty_card_ids : list[UUID | None]\n        The IDs of the counterparty cards. Each ID corresponds to a payment.\n        If the counterparty has multiple payment methods available, use it to\n        specify the card to which you want to send the money. Otherwise, use None.\n    amounts : list[float]\n        The amounts of the payments.\n    currencies : list[str]\n        The ISO 4217 currency codes in upper case.\n    references : list[str]\n        The references for the payments.\n    title : str, optional\n        The title of the payment draft.\n    schedule_for : date | Date | str, optional\n        The scheduled date of the payment draft in ISO 8601 format.\n\n    Returns\n    -------\n    dict | CreatePaymentDraft.Response\n        A dict with the information about the payment draft created.\n    \"\"\"\n    assert (\n        len(counterparty_ids)\n        == len(counterparty_account_ids)\n        == len(counterparty_card_ids)\n        == len(amounts)\n        == len(currencies)\n        == len(references)\n    ), (\n        \"The number of elements in the lists must be equal. \"\n        f\"Got {len(counterparty_ids)} counterparty_ids, \"\n        f\"{len(counterparty_account_ids)} counterparty_account_ids, \"\n        f\"{len(counterparty_card_ids)} counterparty_card_ids, \"\n        f\"{len(amounts)} amounts, \"\n        f\"{len(currencies)} currencies, \"\n        f\"and {len(references)} references.\"\n    )\n\n    endpoint = CreatePaymentDraft\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        title=title,\n        schedule_for=schedule_for,\n        payments=[\n            endpoint.Body.ModelPayment(\n                account_id=account_id,\n                receiver=endpoint.Body.ModelPayment.ModelReceiver(\n                    counterparty_id=counterparty_id,\n                    account_id=counterparty_account_id,\n                    card_id=counterparty_card_id,\n                ),\n                amount=amount,\n                currency=currency,\n                reference=reference,\n            )\n            for counterparty_id, counterparty_account_id, counterparty_card_id, amount, currency, reference in zip(\n                counterparty_ids,\n                counterparty_account_ids,\n                counterparty_card_ids,\n                amounts,\n                currencies,\n                references,\n            )\n        ],\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payment_drafts/synchronous/#pyrevolut.api.payment_drafts.endpoint.EndpointPaymentDraftsSync.delete_payment_draft","title":"<code>delete_payment_draft(payment_draft_id, **kwargs)</code>","text":"<p>Delete a payment draft with the given ID. You can delete a payment draft only if it isn't processed.</p> <p>Parameters:</p> Name Type Description Default <code>payment_draft_id</code> <code>UUID</code> <p>The ID of the payment draft.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the payment draft deleted.</p> Source code in <code>pyrevolut/api/payment_drafts/endpoint/synchronous.py</code> <pre><code>def delete_payment_draft(\n    self,\n    payment_draft_id: UUID,\n    **kwargs,\n) -&gt; dict | DeletePaymentDraft.Response:\n    \"\"\"\n    Delete a payment draft with the given ID.\n    You can delete a payment draft only if it isn't processed.\n\n    Parameters\n    ----------\n    payment_draft_id : UUID\n        The ID of the payment draft.\n\n    Returns\n    -------\n    dict | DeletePaymentDraft.Response\n        A dict with the information about the payment draft deleted.\n    \"\"\"\n    endpoint = DeletePaymentDraft\n    path = endpoint.ROUTE.format(payment_draft_id=payment_draft_id)\n    params = endpoint.Params()\n\n    return self.client.delete(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payment_drafts/synchronous/#pyrevolut.api.payment_drafts.endpoint.EndpointPaymentDraftsSync.get_all_payment_drafts","title":"<code>get_all_payment_drafts(**kwargs)</code>","text":"<p>Get a list of all the payment drafts that aren't processed.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the payment drafts.</p> Source code in <code>pyrevolut/api/payment_drafts/endpoint/synchronous.py</code> <pre><code>def get_all_payment_drafts(\n    self,\n    **kwargs,\n) -&gt; dict | RetrieveAllPaymentDrafts.Response:\n    \"\"\"\n    Get a list of all the payment drafts that aren't processed.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    dict | RetrieveAllPaymentDrafts.Response\n        A dict with the information about the payment drafts.\n    \"\"\"\n    endpoint = RetrieveAllPaymentDrafts\n    path = endpoint.ROUTE\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payment_drafts/synchronous/#pyrevolut.api.payment_drafts.endpoint.EndpointPaymentDraftsSync.get_payment_draft","title":"<code>get_payment_draft(payment_draft_id, **kwargs)</code>","text":"<p>Get the information about a specific payment draft by ID.</p> <p>Parameters:</p> Name Type Description Default <code>payment_draft_id</code> <code>UUID</code> <p>The ID of the payment draft.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict with the information about the payment draft.</p> Source code in <code>pyrevolut/api/payment_drafts/endpoint/synchronous.py</code> <pre><code>def get_payment_draft(\n    self,\n    payment_draft_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrievePaymentDraft.Response:\n    \"\"\"\n    Get the information about a specific payment draft by ID.\n\n    Parameters\n    ----------\n    payment_draft_id : UUID\n        The ID of the payment draft.\n\n    Returns\n    -------\n    dict | RetrievePaymentDraft.Response\n        A dict with the information about the payment draft.\n    \"\"\"\n    endpoint = RetrievePaymentDraft\n    path = endpoint.ROUTE.format(payment_draft_id=payment_draft_id)\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payout_links/asynchronous/","title":"Payout Links Asynchronous Endpoints","text":"<p>This <code>Payout Links</code> endpoint provides asynchronous methods to interact with the payout links of the authenticated user.</p> <p>Example usage of the Payout links endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        links = await client.PayoutLinks.get_all_payout_links()\n        print(links)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/payout_links/asynchronous/#pyrevolut.api.payout_links.endpoint.EndpointPayoutLinksAsync","title":"<code>EndpointPayoutLinksAsync</code>","text":"<p>               Bases: <code>BaseEndpointAsync</code></p> <p>The async Payout Links API</p> <p>Use payout links to send money without having to request full banking details of the recipient. The recipient must claim the money before the link expires.</p> Source code in <code>pyrevolut/api/payout_links/endpoint/asynchronous.py</code> <pre><code>class EndpointPayoutLinksAsync(BaseEndpointAsync):\n    \"\"\"The async Payout Links API\n\n    Use payout links to send money without having to request full\n    banking details of the recipient.\n    The recipient must claim the money before the link expires.\n    \"\"\"\n\n    async def get_all_payout_links(\n        self,\n        state: EnumPayoutLinkState | None = None,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        limit: int | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfPayoutLinks.Response]:\n        \"\"\"\n        Get all the links that you have created, or use the query parameters to filter the results.\n\n        The links are sorted by the created_at date in reverse chronological order.\n\n        The returned links are paginated. The maximum number of payout links returned per\n        page is specified by the limit parameter. To get to the next page, make a\n        new request and use the created_at date of the last payout link returned in the previous response.\n\n        Note\n        ----\n        This feature is available in the UK and the EEA.\n\n        Parameters\n        ----------\n        state : EnumPayoutLinkState, optional\n            The state that the payout link is in. Possible states are:\n\n                created:\n                    The payout link has been created, but the amount has not yet been blocked.\n                failed:\n                    The payout link couldn't be generated due to a failure during transaction booking.\n                awaiting:\n                    The payout link is awaiting approval.\n                active:\n                    The payout link can be redeemed.\n                expired:\n                    The payout link cannot be redeemed because it wasn't claimed before its expiry date.\n                cancelled:\n                    The payout link cannot be redeemed because it was cancelled.\n                processing:\n                    The payout link has been redeemed and is being processed.\n                processed:\n                    The payout link has been redeemed and the money has been transferred to the recipient.\n        created_before : datetime | DateTime | str | int | float, optional\n            Retrieves links with created_at &lt; created_before.\n            The default value is the current date and time at which you are calling the endpoint.\n\n            Provided in ISO 8601 format.\n        limit : int, optional\n            The maximum number of links returned per page.\n            To get to the next page, make a new request and use the\n            created_at date of the last payout link returned in the previous\n            response as the value for created_before.\n\n            If not provided, the default value is 100.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfPayoutLinks.Response]\n            A list of payout links.\n        \"\"\"\n        endpoint = RetrieveListOfPayoutLinks\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            state=state,\n            created_before=created_before,\n            limit=limit,\n        )\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def get_payout_link(\n        self,\n        payout_link_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrievePayoutLink.Response:\n        \"\"\"\n        Get the information about a specific link by its ID.\n\n        Note\n        ----\n        This feature is available in the UK and the EEA.\n\n        Parameters\n        ----------\n        payout_link_id : UUID\n            The ID of the payout link.\n\n        Returns\n        -------\n        dict | RetrievePayoutLink.Response\n            The payout link information.\n        \"\"\"\n        endpoint = RetrievePayoutLink\n        path = endpoint.ROUTE.format(payout_link_id=payout_link_id)\n        params = endpoint.Params()\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def create_payout_link(\n        self,\n        counterparty_name: str,\n        request_id: str,\n        account_id: UUID,\n        amount: float,\n        currency: str,\n        reference: str,\n        payout_methods: list[EnumPayoutLinkPaymentMethod],\n        save_counterparty: bool | None = None,\n        expiry_period: Duration | str | None = None,\n        transfer_reason_code: EnumTransferReasonCode | None = None,\n        **kwargs,\n    ) -&gt; dict | CreatePayoutLink.Response:\n        \"\"\"\n        Create a payout link to send money even when you don't have the full\n        banking details of the counterparty.\n        After you have created the link, send it to the recipient so that\n        they can claim the payment.\n\n        Note\n        ----\n        This feature is available in the UK and the EEA.\n\n        Parameters\n        ----------\n        counterparty_name : str\n            The name of the counterparty provided by the sender.\n        request_id : str\n            The ID of the request, provided by the sender.\n\n            To ensure that a link payment is not processed multiple times if there\n            are network or system errors, the same request_id should be used for\n            requests related to the same link.\n        account_id : UUID\n            The ID of the sender's account.\n        amount : float\n            The amount of money to be sent.\n        currency : str\n            The currency of the amount to be sent.\n        reference : str\n            A reference for the payment.\n        payout_methods : list[EnumPayoutLinkPaymentMethod]\n            The payout methods that the recipient can use to claim the payment.\n        save_counterparty : bool, optional\n            Indicates whether to save the recipient as your counterparty upon link claim.\n            If false then the counterparty will not show up on your counterparties list,\n            for example, when you retrieve your counterparties.\n            However, you will still be able to retrieve this counterparty by its ID.\n\n            If you don't choose to save the counterparty on link creation, you can do it later\n            from your transactions list in the Business app.\n\n            If not provided, the default value is false.\n        expiry_period : Duration | str, optional\n            Possible values: &gt;= P1D and &lt;= P7D\n\n            Default value: P7D\n\n            The period after which the payout link expires if not claimed before,\n            provided in ISO 8601 format.\n\n            The default and maximum value is 7 days from the link creation.\n        transfer_reason_code : EnumTransferReasonCode, optional\n            The reason code for the transaction.\n            Transactions to certain countries and currencies might require you to\n            provide a transfer reason.\n            You can check available reason codes with the getTransferReasons operation.\n\n            If a transfer reason is not required for the given currency and country,\n            this field is ignored.\n\n        Returns\n        -------\n        dict | CreatePayoutLink.Response\n            The payout link information.\n        \"\"\"\n        endpoint = CreatePayoutLink\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            counterparty_name=counterparty_name,\n            save_counterparty=save_counterparty,\n            request_id=request_id,\n            account_id=account_id,\n            amount=amount,\n            currency=currency,\n            reference=reference,\n            payout_methods=payout_methods,\n            expiry_period=expiry_period,\n            transfer_reasion_code=transfer_reason_code,\n        )\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    async def cancel_payout_link(\n        self,\n        payout_link_id: UUID,\n        **kwargs,\n    ) -&gt; dict | CancelPayoutLink.Response:\n        \"\"\"\n        Cancel a payout link.\n        You can only cancel a link that hasn't been claimed yet.\n        A successful request does not get any content in response.\n\n        Note\n        ----\n        This feature is available in the UK and the EEA.\n\n        Parameters\n        ----------\n        payout_link_id : UUID\n            The ID of the payout link.\n\n        Returns\n        -------\n        dict | CancelPayoutLink.Response\n            An empty dictionary.\n        \"\"\"\n        endpoint = CancelPayoutLink\n        path = endpoint.ROUTE.format(payout_link_id=payout_link_id)\n        body = endpoint.Body()\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/payout_links/asynchronous/#pyrevolut.api.payout_links.endpoint.EndpointPayoutLinksAsync.cancel_payout_link","title":"<code>cancel_payout_link(payout_link_id, **kwargs)</code>  <code>async</code>","text":"<p>Cancel a payout link. You can only cancel a link that hasn't been claimed yet. A successful request does not get any content in response.</p> Note <p>This feature is available in the UK and the EEA.</p> <p>Parameters:</p> Name Type Description Default <code>payout_link_id</code> <code>UUID</code> <p>The ID of the payout link.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dictionary.</p> Source code in <code>pyrevolut/api/payout_links/endpoint/asynchronous.py</code> <pre><code>async def cancel_payout_link(\n    self,\n    payout_link_id: UUID,\n    **kwargs,\n) -&gt; dict | CancelPayoutLink.Response:\n    \"\"\"\n    Cancel a payout link.\n    You can only cancel a link that hasn't been claimed yet.\n    A successful request does not get any content in response.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n\n    Parameters\n    ----------\n    payout_link_id : UUID\n        The ID of the payout link.\n\n    Returns\n    -------\n    dict | CancelPayoutLink.Response\n        An empty dictionary.\n    \"\"\"\n    endpoint = CancelPayoutLink\n    path = endpoint.ROUTE.format(payout_link_id=payout_link_id)\n    body = endpoint.Body()\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payout_links/asynchronous/#pyrevolut.api.payout_links.endpoint.EndpointPayoutLinksAsync.create_payout_link","title":"<code>create_payout_link(counterparty_name, request_id, account_id, amount, currency, reference, payout_methods, save_counterparty=None, expiry_period=None, transfer_reason_code=None, **kwargs)</code>  <code>async</code>","text":"<p>Create a payout link to send money even when you don't have the full banking details of the counterparty. After you have created the link, send it to the recipient so that they can claim the payment.</p> Note <p>This feature is available in the UK and the EEA.</p> <p>Parameters:</p> Name Type Description Default <code>counterparty_name</code> <code>str</code> <p>The name of the counterparty provided by the sender.</p> required <code>request_id</code> <code>str</code> <p>The ID of the request, provided by the sender.</p> <p>To ensure that a link payment is not processed multiple times if there are network or system errors, the same request_id should be used for requests related to the same link.</p> required <code>account_id</code> <code>UUID</code> <p>The ID of the sender's account.</p> required <code>amount</code> <code>float</code> <p>The amount of money to be sent.</p> required <code>currency</code> <code>str</code> <p>The currency of the amount to be sent.</p> required <code>reference</code> <code>str</code> <p>A reference for the payment.</p> required <code>payout_methods</code> <code>list[EnumPayoutLinkPaymentMethod]</code> <p>The payout methods that the recipient can use to claim the payment.</p> required <code>save_counterparty</code> <code>bool</code> <p>Indicates whether to save the recipient as your counterparty upon link claim. If false then the counterparty will not show up on your counterparties list, for example, when you retrieve your counterparties. However, you will still be able to retrieve this counterparty by its ID.</p> <p>If you don't choose to save the counterparty on link creation, you can do it later from your transactions list in the Business app.</p> <p>If not provided, the default value is false.</p> <code>None</code> <code>expiry_period</code> <code>Duration | str</code> <p>Possible values: &gt;= P1D and &lt;= P7D</p> <p>Default value: P7D</p> <p>The period after which the payout link expires if not claimed before, provided in ISO 8601 format.</p> <p>The default and maximum value is 7 days from the link creation.</p> <code>None</code> <code>transfer_reason_code</code> <code>EnumTransferReasonCode</code> <p>The reason code for the transaction. Transactions to certain countries and currencies might require you to provide a transfer reason. You can check available reason codes with the getTransferReasons operation.</p> <p>If a transfer reason is not required for the given currency and country, this field is ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The payout link information.</p> Source code in <code>pyrevolut/api/payout_links/endpoint/asynchronous.py</code> <pre><code>async def create_payout_link(\n    self,\n    counterparty_name: str,\n    request_id: str,\n    account_id: UUID,\n    amount: float,\n    currency: str,\n    reference: str,\n    payout_methods: list[EnumPayoutLinkPaymentMethod],\n    save_counterparty: bool | None = None,\n    expiry_period: Duration | str | None = None,\n    transfer_reason_code: EnumTransferReasonCode | None = None,\n    **kwargs,\n) -&gt; dict | CreatePayoutLink.Response:\n    \"\"\"\n    Create a payout link to send money even when you don't have the full\n    banking details of the counterparty.\n    After you have created the link, send it to the recipient so that\n    they can claim the payment.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n\n    Parameters\n    ----------\n    counterparty_name : str\n        The name of the counterparty provided by the sender.\n    request_id : str\n        The ID of the request, provided by the sender.\n\n        To ensure that a link payment is not processed multiple times if there\n        are network or system errors, the same request_id should be used for\n        requests related to the same link.\n    account_id : UUID\n        The ID of the sender's account.\n    amount : float\n        The amount of money to be sent.\n    currency : str\n        The currency of the amount to be sent.\n    reference : str\n        A reference for the payment.\n    payout_methods : list[EnumPayoutLinkPaymentMethod]\n        The payout methods that the recipient can use to claim the payment.\n    save_counterparty : bool, optional\n        Indicates whether to save the recipient as your counterparty upon link claim.\n        If false then the counterparty will not show up on your counterparties list,\n        for example, when you retrieve your counterparties.\n        However, you will still be able to retrieve this counterparty by its ID.\n\n        If you don't choose to save the counterparty on link creation, you can do it later\n        from your transactions list in the Business app.\n\n        If not provided, the default value is false.\n    expiry_period : Duration | str, optional\n        Possible values: &gt;= P1D and &lt;= P7D\n\n        Default value: P7D\n\n        The period after which the payout link expires if not claimed before,\n        provided in ISO 8601 format.\n\n        The default and maximum value is 7 days from the link creation.\n    transfer_reason_code : EnumTransferReasonCode, optional\n        The reason code for the transaction.\n        Transactions to certain countries and currencies might require you to\n        provide a transfer reason.\n        You can check available reason codes with the getTransferReasons operation.\n\n        If a transfer reason is not required for the given currency and country,\n        this field is ignored.\n\n    Returns\n    -------\n    dict | CreatePayoutLink.Response\n        The payout link information.\n    \"\"\"\n    endpoint = CreatePayoutLink\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        counterparty_name=counterparty_name,\n        save_counterparty=save_counterparty,\n        request_id=request_id,\n        account_id=account_id,\n        amount=amount,\n        currency=currency,\n        reference=reference,\n        payout_methods=payout_methods,\n        expiry_period=expiry_period,\n        transfer_reasion_code=transfer_reason_code,\n    )\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payout_links/asynchronous/#pyrevolut.api.payout_links.endpoint.EndpointPayoutLinksAsync.get_all_payout_links","title":"<code>get_all_payout_links(state=None, created_before=None, limit=None, **kwargs)</code>  <code>async</code>","text":"<p>Get all the links that you have created, or use the query parameters to filter the results.</p> <p>The links are sorted by the created_at date in reverse chronological order.</p> <p>The returned links are paginated. The maximum number of payout links returned per page is specified by the limit parameter. To get to the next page, make a new request and use the created_at date of the last payout link returned in the previous response.</p> Note <p>This feature is available in the UK and the EEA.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnumPayoutLinkState</code> <p>The state that the payout link is in. Possible states are:</p> <pre><code>created:\n    The payout link has been created, but the amount has not yet been blocked.\nfailed:\n    The payout link couldn't be generated due to a failure during transaction booking.\nawaiting:\n    The payout link is awaiting approval.\nactive:\n    The payout link can be redeemed.\nexpired:\n    The payout link cannot be redeemed because it wasn't claimed before its expiry date.\ncancelled:\n    The payout link cannot be redeemed because it was cancelled.\nprocessing:\n    The payout link has been redeemed and is being processed.\nprocessed:\n    The payout link has been redeemed and the money has been transferred to the recipient.\n</code></pre> <code>None</code> <code>created_before</code> <code>datetime | DateTime | str | int | float</code> <p>Retrieves links with created_at &lt; created_before. The default value is the current date and time at which you are calling the endpoint.</p> <p>Provided in ISO 8601 format.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of links returned per page. To get to the next page, make a new request and use the created_at date of the last payout link returned in the previous response as the value for created_before.</p> <p>If not provided, the default value is 100.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>A list of payout links.</p> Source code in <code>pyrevolut/api/payout_links/endpoint/asynchronous.py</code> <pre><code>async def get_all_payout_links(\n    self,\n    state: EnumPayoutLinkState | None = None,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    limit: int | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfPayoutLinks.Response]:\n    \"\"\"\n    Get all the links that you have created, or use the query parameters to filter the results.\n\n    The links are sorted by the created_at date in reverse chronological order.\n\n    The returned links are paginated. The maximum number of payout links returned per\n    page is specified by the limit parameter. To get to the next page, make a\n    new request and use the created_at date of the last payout link returned in the previous response.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n\n    Parameters\n    ----------\n    state : EnumPayoutLinkState, optional\n        The state that the payout link is in. Possible states are:\n\n            created:\n                The payout link has been created, but the amount has not yet been blocked.\n            failed:\n                The payout link couldn't be generated due to a failure during transaction booking.\n            awaiting:\n                The payout link is awaiting approval.\n            active:\n                The payout link can be redeemed.\n            expired:\n                The payout link cannot be redeemed because it wasn't claimed before its expiry date.\n            cancelled:\n                The payout link cannot be redeemed because it was cancelled.\n            processing:\n                The payout link has been redeemed and is being processed.\n            processed:\n                The payout link has been redeemed and the money has been transferred to the recipient.\n    created_before : datetime | DateTime | str | int | float, optional\n        Retrieves links with created_at &lt; created_before.\n        The default value is the current date and time at which you are calling the endpoint.\n\n        Provided in ISO 8601 format.\n    limit : int, optional\n        The maximum number of links returned per page.\n        To get to the next page, make a new request and use the\n        created_at date of the last payout link returned in the previous\n        response as the value for created_before.\n\n        If not provided, the default value is 100.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfPayoutLinks.Response]\n        A list of payout links.\n    \"\"\"\n    endpoint = RetrieveListOfPayoutLinks\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        state=state,\n        created_before=created_before,\n        limit=limit,\n    )\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payout_links/asynchronous/#pyrevolut.api.payout_links.endpoint.EndpointPayoutLinksAsync.get_payout_link","title":"<code>get_payout_link(payout_link_id, **kwargs)</code>  <code>async</code>","text":"<p>Get the information about a specific link by its ID.</p> Note <p>This feature is available in the UK and the EEA.</p> <p>Parameters:</p> Name Type Description Default <code>payout_link_id</code> <code>UUID</code> <p>The ID of the payout link.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The payout link information.</p> Source code in <code>pyrevolut/api/payout_links/endpoint/asynchronous.py</code> <pre><code>async def get_payout_link(\n    self,\n    payout_link_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrievePayoutLink.Response:\n    \"\"\"\n    Get the information about a specific link by its ID.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n\n    Parameters\n    ----------\n    payout_link_id : UUID\n        The ID of the payout link.\n\n    Returns\n    -------\n    dict | RetrievePayoutLink.Response\n        The payout link information.\n    \"\"\"\n    endpoint = RetrievePayoutLink\n    path = endpoint.ROUTE.format(payout_link_id=payout_link_id)\n    params = endpoint.Params()\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/","title":"Payout Links Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Payout Links</code> endpoint.</p>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.resources.ResourcePayoutLink","title":"<code>ResourcePayoutLink</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Payout Link resource model.</p> Source code in <code>pyrevolut/api/payout_links/resources/payout_link.py</code> <pre><code>class ResourcePayoutLink(BaseModel):\n    \"\"\"\n    Payout Link resource model.\n    \"\"\"\n\n    id: Annotated[UUID, Field(description=\"The ID of the payout link.\")]\n    state: Annotated[\n        EnumPayoutLinkState,\n        Field(\n            description=\"\"\"\n            The state that the payout link is in. Possible states are:\n\n                created:\n                    The payout link has been created, but the amount has not yet been blocked.\n                failed:\n                    The payout link couldn't be generated due to a failure during transaction booking.\n                awaiting:\n                    The payout link is awaiting approval.\n                active:\n                    The payout link can be redeemed.\n                expired:\n                    The payout link cannot be redeemed because it wasn't claimed before its expiry date.\n                cancelled:\n                    The payout link cannot be redeemed because it was cancelled.\n                processing:\n                    The payout link has been redeemed and is being processed.\n                processed:\n                    The payout link has been redeemed and the money has been transferred to the recipient.\n            \"\"\"\n        ),\n    ]\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the payout link was created in ISO 8601 format.\"\n        ),\n    ]\n    updated_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the payout link was last updated in ISO 8601 format.\"\n        ),\n    ]\n    counterparty_name: Annotated[\n        str, Field(description=\"The name of the counterparty provided by the sender.\")\n    ]\n    counterparty_id: Annotated[\n        UUID | None,\n        Field(\n            description=\"\"\"\n            The ID of the counterparty created based on the recipient's details.\n\n            By default, the newly created counterparty is hidden from your counterparties list.\n            To automatically save it when the link is claimed, pass the save_counterparty parameter set to true.\n            Alternatively, you can add the recipient to your counterparties later from the list of transactions \n            in the Business app.\n            \"\"\"\n        ),\n    ] = None\n    save_counterparty: Annotated[\n        bool,\n        Field(\n            description=\"\"\"\n            Indicates whether you chose to save the recipient as your counterparty upon link claim. \n            If false then the counterparty will not show up on your counterparties list, \n            for example, when you retrieve your counterparties. \n            However, you can still retrieve this counterparty by its ID.\n\n            If you didn't choose to save the counterparty on link creation, you can still do it \n            from your transactions list in the Business app.\n            \"\"\"\n        ),\n    ]\n    request_id: Annotated[\n        str,\n        Field(\n            description=\"The ID of the request, provided by the sender.\",\n        ),\n    ]\n    expiry_date: Annotated[\n        DateTime,\n        Field(description=\"The datetime the payout link expires in ISO 8601 format.\"),\n    ]\n    payout_methods: Annotated[\n        list[EnumPayoutLinkPaymentMethod],\n        Field(\n            description=\"\"\"\n            The list of payout methods that the recipient can use to claim the payout, where:\n\n                revolut:\n                    Revolut peer-to-peer (P2P) transfer\n\n                bank_account:\n                    External bank transfer\n\n                card:\n                    Card transfer\n            \"\"\"\n        ),\n    ]\n    account_id: Annotated[UUID, Field(description=\"The ID of the sender's account.\")]\n    amount: Annotated[\n        float,\n        Field(\n            description=\"\"\"\n            The amount of money to be transferred.\n            The amount must be between \u00a31 and \u00a32,500, or equivalent in the selected currency.\n            \"\"\"\n        ),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(description=\"ISO 4217 currency code in upper case.\"),\n    ]\n    transaction_id: Annotated[\n        UUID | None,\n        Field(\n            description=\"\"\"\n            The ID of the created transaction. Returned only if the payout has been claimed.\n            \"\"\"\n        ),\n    ] = None\n    url: Annotated[\n        HttpUrl | None,\n        Field(\n            description=\"The URL of the payout link. Returned only for active payout links.\"\n        ),\n    ] = None\n    reference: Annotated[\n        str,\n        Field(\n            description=\"The reference for the payout transaction, provided by the sender.\"\n        ),\n    ]\n    transfer_reason_code: Annotated[\n        EnumTransferReasonCode | None,\n        Field(\n            description=\"\"\"\n            The reason code for the transaction. \n            Transactions to certain countries and currencies might require you to \n            provide a transfer reason. \n            You can check available reason codes with the getTransferReasons operation.\n\n            If a transfer reason is not required for the given currency and country, \n            this field is ignored.\n            \"\"\"\n        ),\n    ] = None\n    cancellation_reason: Annotated[\n        EnumPayoutLinkCancellationReason | None,\n        Field(\n            description=\"\"\"\n            The reason why the payout link was cancelled. Possible reasons are:\n\n                too_many_name_check_attempts:\n                    The name check failed too many times.\n            \"\"\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.get.RetrieveListOfPayoutLinks","title":"<code>RetrieveListOfPayoutLinks</code>","text":"<p>Get all the links that you have created, or use the query parameters to filter the results.</p> <p>The links are sorted by the created_at date in reverse chronological order.</p> <p>The returned links are paginated. The maximum number of payout links returned per page is specified by the limit parameter. To get to the next page, make a new request and use the created_at date of the last payout link returned in the previous response.</p> Note <p>This feature is available in the UK and the EEA.</p> Source code in <code>pyrevolut/api/payout_links/get/retrieve_list_of_payout_links.py</code> <pre><code>class RetrieveListOfPayoutLinks:\n    \"\"\"\n    Get all the links that you have created, or use the query parameters to filter the results.\n\n    The links are sorted by the created_at date in reverse chronological order.\n\n    The returned links are paginated. The maximum number of payout links returned per\n    page is specified by the limit parameter. To get to the next page, make a\n    new request and use the created_at date of the last payout link returned in the previous response.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n    \"\"\"\n\n    ROUTE = \"/1.0/payout-links\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The query parameters for the request.\n        \"\"\"\n\n        state: Annotated[\n            EnumPayoutLinkState | None,\n            Field(\n                description=\"\"\"\n                The state that the payout link is in. Possible states are:\n\n                    created:\n                        The payout link has been created, but the amount has not yet been blocked.\n                    failed:\n                        The payout link couldn't be generated due to a failure during transaction booking.\n                    awaiting:\n                        The payout link is awaiting approval.\n                    active:\n                        The payout link can be redeemed.\n                    expired:\n                        The payout link cannot be redeemed because it wasn't claimed before its expiry date.\n                    cancelled:\n                        The payout link cannot be redeemed because it was cancelled.\n                    processing:\n                        The payout link has been redeemed and is being processed.\n                    processed:\n                        The payout link has been redeemed and the money has been transferred to the recipient.\n                \"\"\",\n            ),\n        ] = None\n        created_before: Annotated[\n            DateTime | None,\n            Field(\n                description=\"\"\"\n                Retrieves links with created_at &lt; created_before. \n                The default value is the current date and time at which you are calling the endpoint.\n\n                Provided in ISO 8601 format.\n                \"\"\"\n            ),\n        ] = None\n        limit: Annotated[\n            int | None,\n            Field(\n                description=\"\"\"\n                The maximum number of links returned per page.\n                To get to the next page, make a new request and use the \n                created_at date of the last payout link returned in the previous \n                response as the value for created_before.              \n\n                If not provided, the default value is 100.  \n                \"\"\",\n                ge=1,\n                le=100,\n            ),\n        ] = None\n\n    class Response(ResourcePayoutLink):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.get.RetrieveListOfPayoutLinks.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The query parameters for the request.</p> Source code in <code>pyrevolut/api/payout_links/get/retrieve_list_of_payout_links.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The query parameters for the request.\n    \"\"\"\n\n    state: Annotated[\n        EnumPayoutLinkState | None,\n        Field(\n            description=\"\"\"\n            The state that the payout link is in. Possible states are:\n\n                created:\n                    The payout link has been created, but the amount has not yet been blocked.\n                failed:\n                    The payout link couldn't be generated due to a failure during transaction booking.\n                awaiting:\n                    The payout link is awaiting approval.\n                active:\n                    The payout link can be redeemed.\n                expired:\n                    The payout link cannot be redeemed because it wasn't claimed before its expiry date.\n                cancelled:\n                    The payout link cannot be redeemed because it was cancelled.\n                processing:\n                    The payout link has been redeemed and is being processed.\n                processed:\n                    The payout link has been redeemed and the money has been transferred to the recipient.\n            \"\"\",\n        ),\n    ] = None\n    created_before: Annotated[\n        DateTime | None,\n        Field(\n            description=\"\"\"\n            Retrieves links with created_at &lt; created_before. \n            The default value is the current date and time at which you are calling the endpoint.\n\n            Provided in ISO 8601 format.\n            \"\"\"\n        ),\n    ] = None\n    limit: Annotated[\n        int | None,\n        Field(\n            description=\"\"\"\n            The maximum number of links returned per page.\n            To get to the next page, make a new request and use the \n            created_at date of the last payout link returned in the previous \n            response as the value for created_before.              \n\n            If not provided, the default value is 100.  \n            \"\"\",\n            ge=1,\n            le=100,\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.get.RetrieveListOfPayoutLinks.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourcePayoutLink</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/payout_links/get/retrieve_list_of_payout_links.py</code> <pre><code>class Response(ResourcePayoutLink):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.get.RetrievePayoutLink","title":"<code>RetrievePayoutLink</code>","text":"<p>Get the information about a specific link by its ID.</p> Note <p>This feature is available in the UK and the EEA.</p> Source code in <code>pyrevolut/api/payout_links/get/retrieve_payout_link.py</code> <pre><code>class RetrievePayoutLink:\n    \"\"\"\n    Get the information about a specific link by its ID.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n    \"\"\"\n\n    ROUTE = \"/1.0/payout-links/{payout_link_id}\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The query parameters for the request.\n        \"\"\"\n\n        pass\n\n    class Response(ResourcePayoutLink):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.get.RetrievePayoutLink.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The query parameters for the request.</p> Source code in <code>pyrevolut/api/payout_links/get/retrieve_payout_link.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The query parameters for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.get.RetrievePayoutLink.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourcePayoutLink</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/payout_links/get/retrieve_payout_link.py</code> <pre><code>class Response(ResourcePayoutLink):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.post.CreatePayoutLink","title":"<code>CreatePayoutLink</code>","text":"<p>Create a payout link to send money even when you don't have the full banking details of the counterparty. After you have created the link, send it to the recipient so that they can claim the payment.</p> Note <p>This feature is available in the UK and the EEA.</p> Source code in <code>pyrevolut/api/payout_links/post/create_payout_link.py</code> <pre><code>class CreatePayoutLink:\n    \"\"\"\n    Create a payout link to send money even when you don't have the full\n    banking details of the counterparty.\n    After you have created the link, send it to the recipient so that\n    they can claim the payment.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n    \"\"\"\n\n    ROUTE = \"/1.0/payout-links\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The request body model for the request.\n        \"\"\"\n\n        counterparty_name: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                The name of the counterparty provided by the sender.                \n                \"\"\",\n            ),\n        ]\n        save_counterparty: Annotated[\n            bool | None,\n            Field(\n                description=\"\"\"\n                Indicates whether to save the recipient as your counterparty upon link claim. \n                If false then the counterparty will not show up on your counterparties list, \n                for example, when you retrieve your counterparties. \n                However, you will still be able to retrieve this counterparty by its ID.\n\n                If you don't choose to save the counterparty on link creation, you can do it later \n                from your transactions list in the Business app.\n\n                If not provided, the default value is false.\n                \"\"\",\n            ),\n        ] = None\n        request_id: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                The ID of the request, provided by the sender.\n\n                To ensure that a link payment is not processed multiple times if there\n                are network or system errors, the same request_id should be used for \n                requests related to the same link.\n                \"\"\",\n                max_length=40,\n            ),\n        ]\n        account_id: Annotated[\n            UUID,\n            Field(\n                description=\"\"\"\n                The ID of the sender's account.\n                \"\"\",\n            ),\n        ]\n        amount: Annotated[\n            float,\n            Field(\n                description=\"\"\"\n                The amount of money to be transferred.\n                The amount must be between \u00a31 and \u00a32,500, or equivalent in the selected currency.\n                \"\"\",\n            ),\n        ]\n        currency: Annotated[\n            Currency,\n            Field(\n                description=\"\"\"\n                ISO 4217 currency code in upper case.\n                \"\"\",\n            ),\n        ]\n        reference: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                The reference for the payout transaction, provided by the sender.\n                \"\"\",\n            ),\n        ]\n        payout_methods: Annotated[\n            list[EnumPayoutLinkPaymentMethod],\n            Field(\n                description=\"\"\"\n                The list of payout methods that the recipient can use to claim the payout, where:\n\n                    revolut:\n                        Revolut peer-to-peer (P2P) transfer\n\n                    bank_account:\n                        External bank transfer\n\n                    card:\n                        Card transfer\n                \"\"\"\n            ),\n        ]\n        expiry_period: Annotated[\n            Duration | None,\n            Field(\n                description=\"\"\"\n                Possible values: &gt;= P1D and &lt;= P7D\n\n                Default value: P7D\n\n                The period after which the payout link expires if not claimed before, \n                provided in ISO 8601 format.\n\n                The default and maximum value is 7 days from the link creation.\n                \"\"\",\n            ),\n        ] = None\n        transfer_reason_code: Annotated[\n            EnumTransferReasonCode | None,\n            Field(\n                description=\"\"\"\n                The reason code for the transaction. \n                Transactions to certain countries and currencies might require you to \n                provide a transfer reason. \n                You can check available reason codes with the getTransferReasons operation.\n\n                If a transfer reason is not required for the given currency and country, \n                this field is ignored.\n                \"\"\"\n            ),\n        ] = None\n\n    class Response(ResourcePayoutLink):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.post.CreatePayoutLink.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The request body model for the request.</p> Source code in <code>pyrevolut/api/payout_links/post/create_payout_link.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The request body model for the request.\n    \"\"\"\n\n    counterparty_name: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            The name of the counterparty provided by the sender.                \n            \"\"\",\n        ),\n    ]\n    save_counterparty: Annotated[\n        bool | None,\n        Field(\n            description=\"\"\"\n            Indicates whether to save the recipient as your counterparty upon link claim. \n            If false then the counterparty will not show up on your counterparties list, \n            for example, when you retrieve your counterparties. \n            However, you will still be able to retrieve this counterparty by its ID.\n\n            If you don't choose to save the counterparty on link creation, you can do it later \n            from your transactions list in the Business app.\n\n            If not provided, the default value is false.\n            \"\"\",\n        ),\n    ] = None\n    request_id: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            The ID of the request, provided by the sender.\n\n            To ensure that a link payment is not processed multiple times if there\n            are network or system errors, the same request_id should be used for \n            requests related to the same link.\n            \"\"\",\n            max_length=40,\n        ),\n    ]\n    account_id: Annotated[\n        UUID,\n        Field(\n            description=\"\"\"\n            The ID of the sender's account.\n            \"\"\",\n        ),\n    ]\n    amount: Annotated[\n        float,\n        Field(\n            description=\"\"\"\n            The amount of money to be transferred.\n            The amount must be between \u00a31 and \u00a32,500, or equivalent in the selected currency.\n            \"\"\",\n        ),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(\n            description=\"\"\"\n            ISO 4217 currency code in upper case.\n            \"\"\",\n        ),\n    ]\n    reference: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            The reference for the payout transaction, provided by the sender.\n            \"\"\",\n        ),\n    ]\n    payout_methods: Annotated[\n        list[EnumPayoutLinkPaymentMethod],\n        Field(\n            description=\"\"\"\n            The list of payout methods that the recipient can use to claim the payout, where:\n\n                revolut:\n                    Revolut peer-to-peer (P2P) transfer\n\n                bank_account:\n                    External bank transfer\n\n                card:\n                    Card transfer\n            \"\"\"\n        ),\n    ]\n    expiry_period: Annotated[\n        Duration | None,\n        Field(\n            description=\"\"\"\n            Possible values: &gt;= P1D and &lt;= P7D\n\n            Default value: P7D\n\n            The period after which the payout link expires if not claimed before, \n            provided in ISO 8601 format.\n\n            The default and maximum value is 7 days from the link creation.\n            \"\"\",\n        ),\n    ] = None\n    transfer_reason_code: Annotated[\n        EnumTransferReasonCode | None,\n        Field(\n            description=\"\"\"\n            The reason code for the transaction. \n            Transactions to certain countries and currencies might require you to \n            provide a transfer reason. \n            You can check available reason codes with the getTransferReasons operation.\n\n            If a transfer reason is not required for the given currency and country, \n            this field is ignored.\n            \"\"\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.post.CreatePayoutLink.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourcePayoutLink</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/payout_links/post/create_payout_link.py</code> <pre><code>class Response(ResourcePayoutLink):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.post.CancelPayoutLink","title":"<code>CancelPayoutLink</code>","text":"<p>Cancel a payout link. You can only cancel a link that hasn't been claimed yet. A successful request does not get any content in response.</p> Note <p>This feature is available in the UK and the EEA.</p> Source code in <code>pyrevolut/api/payout_links/post/cancel_payout_link.py</code> <pre><code>class CancelPayoutLink:\n    \"\"\"\n    Cancel a payout link.\n    You can only cancel a link that hasn't been claimed yet.\n    A successful request does not get any content in response.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n    \"\"\"\n\n    ROUTE = \"/1.0/payout-links/{payout_link_id}/cancel\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The request body model for the request.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.post.CancelPayoutLink.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The request body model for the request.</p> Source code in <code>pyrevolut/api/payout_links/post/cancel_payout_link.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The request body model for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payout_links/pydantic/#pyrevolut.api.payout_links.post.CancelPayoutLink.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/payout_links/post/cancel_payout_link.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/payout_links/synchronous/","title":"Payout Links Synchronous Endpoints","text":"<p>This <code>Payout Links</code> endpoint provides methods to interact with the payout links of the authenticated user.</p> <p>Example usage of the Payout links endpoint object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    links = client.PayoutLinks.get_all_payout_links()\n    print(links)\n</code></pre>"},{"location":"code_reference/api/payout_links/synchronous/#pyrevolut.api.payout_links.endpoint.EndpointPayoutLinksSync","title":"<code>EndpointPayoutLinksSync</code>","text":"<p>               Bases: <code>BaseEndpointSync</code></p> <p>The Payout Links API</p> <p>Use payout links to send money without having to request full banking details of the recipient. The recipient must claim the money before the link expires.</p> Source code in <code>pyrevolut/api/payout_links/endpoint/synchronous.py</code> <pre><code>class EndpointPayoutLinksSync(BaseEndpointSync):\n    \"\"\"The Payout Links API\n\n    Use payout links to send money without having to request full\n    banking details of the recipient.\n    The recipient must claim the money before the link expires.\n    \"\"\"\n\n    def get_all_payout_links(\n        self,\n        state: EnumPayoutLinkState | None = None,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        limit: int | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfPayoutLinks.Response]:\n        \"\"\"\n        Get all the links that you have created, or use the query parameters to filter the results.\n\n        The links are sorted by the created_at date in reverse chronological order.\n\n        The returned links are paginated. The maximum number of payout links returned per\n        page is specified by the limit parameter. To get to the next page, make a\n        new request and use the created_at date of the last payout link returned in the previous response.\n\n        Note\n        ----\n        This feature is available in the UK and the EEA.\n\n        Parameters\n        ----------\n        state : EnumPayoutLinkState, optional\n            The state that the payout link is in. Possible states are:\n\n                created:\n                    The payout link has been created, but the amount has not yet been blocked.\n                failed:\n                    The payout link couldn't be generated due to a failure during transaction booking.\n                awaiting:\n                    The payout link is awaiting approval.\n                active:\n                    The payout link can be redeemed.\n                expired:\n                    The payout link cannot be redeemed because it wasn't claimed before its expiry date.\n                cancelled:\n                    The payout link cannot be redeemed because it was cancelled.\n                processing:\n                    The payout link has been redeemed and is being processed.\n                processed:\n                    The payout link has been redeemed and the money has been transferred to the recipient.\n        created_before : datetime | DateTime | str | int | float, optional\n            Retrieves links with created_at &lt; created_before.\n            The default value is the current date and time at which you are calling the endpoint.\n\n            Provided in ISO 8601 format.\n        limit : int, optional\n            The maximum number of links returned per page.\n            To get to the next page, make a new request and use the\n            created_at date of the last payout link returned in the previous\n            response as the value for created_before.\n\n            If not provided, the default value is 100.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfPayoutLinks.Response]\n            A list of payout links.\n        \"\"\"\n        endpoint = RetrieveListOfPayoutLinks\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            state=state,\n            created_before=created_before,\n            limit=limit,\n        )\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_payout_link(\n        self,\n        payout_link_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrievePayoutLink.Response:\n        \"\"\"\n        Get the information about a specific link by its ID.\n\n        Note\n        ----\n        This feature is available in the UK and the EEA.\n\n        Parameters\n        ----------\n        payout_link_id : UUID\n            The ID of the payout link.\n\n        Returns\n        -------\n        dict | RetrievePayoutLink.Response\n            The payout link information.\n        \"\"\"\n        endpoint = RetrievePayoutLink\n        path = endpoint.ROUTE.format(payout_link_id=payout_link_id)\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def create_payout_link(\n        self,\n        counterparty_name: str,\n        request_id: str,\n        account_id: UUID,\n        amount: float,\n        currency: str,\n        reference: str,\n        payout_methods: list[EnumPayoutLinkPaymentMethod],\n        save_counterparty: bool | None = None,\n        expiry_period: Duration | str | None = None,\n        transfer_reason_code: EnumTransferReasonCode | None = None,\n        **kwargs,\n    ) -&gt; dict | CreatePayoutLink.Response:\n        \"\"\"\n        Create a payout link to send money even when you don't have the full\n        banking details of the counterparty.\n        After you have created the link, send it to the recipient so that\n        they can claim the payment.\n\n        Note\n        ----\n        This feature is available in the UK and the EEA.\n\n        Parameters\n        ----------\n        counterparty_name : str\n            The name of the counterparty provided by the sender.\n        request_id : str\n            The ID of the request, provided by the sender.\n\n            To ensure that a link payment is not processed multiple times if there\n            are network or system errors, the same request_id should be used for\n            requests related to the same link.\n        account_id : UUID\n            The ID of the sender's account.\n        amount : float\n            The amount of money to be sent.\n        currency : str\n            The currency of the amount to be sent.\n        reference : str\n            A reference for the payment.\n        payout_methods : list[EnumPayoutLinkPaymentMethod]\n            The payout methods that the recipient can use to claim the payment.\n            If not provided, the default value is\n            [EnumPayoutLinkPaymentMethod.REVOLUT, EnumPayoutLinkPaymentMethod.BANK_ACCOUNT].\n        save_counterparty : bool, optional\n            Indicates whether to save the recipient as your counterparty upon link claim.\n            If false then the counterparty will not show up on your counterparties list,\n            for example, when you retrieve your counterparties.\n            However, you will still be able to retrieve this counterparty by its ID.\n\n            If you don't choose to save the counterparty on link creation, you can do it later\n            from your transactions list in the Business app.\n\n            If not provided, the default value is false.\n        expiry_period : Duration | str, optional\n            Possible values: &gt;= P1D and &lt;= P7D\n\n            Default value: P7D\n\n            The period after which the payout link expires if not claimed before,\n            provided in ISO 8601 format.\n\n            The default and maximum value is 7 days from the link creation.\n        transfer_reason_code : EnumTransferReasonCode, optional\n            The reason code for the transaction.\n            Transactions to certain countries and currencies might require you to\n            provide a transfer reason.\n            You can check available reason codes with the getTransferReasons operation.\n\n            If a transfer reason is not required for the given currency and country,\n            this field is ignored.\n\n        Returns\n        -------\n        dict | CreatePayoutLink.Response\n            The payout link information.\n        \"\"\"\n        endpoint = CreatePayoutLink\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            counterparty_name=counterparty_name,\n            save_counterparty=save_counterparty,\n            request_id=request_id,\n            account_id=account_id,\n            amount=amount,\n            currency=currency,\n            reference=reference,\n            payout_methods=payout_methods,\n            expiry_period=expiry_period,\n            transfer_reasion_code=transfer_reason_code,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def cancel_payout_link(\n        self,\n        payout_link_id: UUID,\n        **kwargs,\n    ) -&gt; dict | CancelPayoutLink.Response:\n        \"\"\"\n        Cancel a payout link.\n        You can only cancel a link that hasn't been claimed yet.\n        A successful request does not get any content in response.\n\n        Note\n        ----\n        This feature is available in the UK and the EEA.\n\n        Parameters\n        ----------\n        payout_link_id : UUID\n            The ID of the payout link.\n\n        Returns\n        -------\n        dict | CancelPayoutLink.Response\n            An empty dictionary.\n        \"\"\"\n        endpoint = CancelPayoutLink\n        path = endpoint.ROUTE.format(payout_link_id=payout_link_id)\n        body = endpoint.Body()\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/payout_links/synchronous/#pyrevolut.api.payout_links.endpoint.EndpointPayoutLinksSync.cancel_payout_link","title":"<code>cancel_payout_link(payout_link_id, **kwargs)</code>","text":"<p>Cancel a payout link. You can only cancel a link that hasn't been claimed yet. A successful request does not get any content in response.</p> Note <p>This feature is available in the UK and the EEA.</p> <p>Parameters:</p> Name Type Description Default <code>payout_link_id</code> <code>UUID</code> <p>The ID of the payout link.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dictionary.</p> Source code in <code>pyrevolut/api/payout_links/endpoint/synchronous.py</code> <pre><code>def cancel_payout_link(\n    self,\n    payout_link_id: UUID,\n    **kwargs,\n) -&gt; dict | CancelPayoutLink.Response:\n    \"\"\"\n    Cancel a payout link.\n    You can only cancel a link that hasn't been claimed yet.\n    A successful request does not get any content in response.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n\n    Parameters\n    ----------\n    payout_link_id : UUID\n        The ID of the payout link.\n\n    Returns\n    -------\n    dict | CancelPayoutLink.Response\n        An empty dictionary.\n    \"\"\"\n    endpoint = CancelPayoutLink\n    path = endpoint.ROUTE.format(payout_link_id=payout_link_id)\n    body = endpoint.Body()\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payout_links/synchronous/#pyrevolut.api.payout_links.endpoint.EndpointPayoutLinksSync.create_payout_link","title":"<code>create_payout_link(counterparty_name, request_id, account_id, amount, currency, reference, payout_methods, save_counterparty=None, expiry_period=None, transfer_reason_code=None, **kwargs)</code>","text":"<p>Create a payout link to send money even when you don't have the full banking details of the counterparty. After you have created the link, send it to the recipient so that they can claim the payment.</p> Note <p>This feature is available in the UK and the EEA.</p> <p>Parameters:</p> Name Type Description Default <code>counterparty_name</code> <code>str</code> <p>The name of the counterparty provided by the sender.</p> required <code>request_id</code> <code>str</code> <p>The ID of the request, provided by the sender.</p> <p>To ensure that a link payment is not processed multiple times if there are network or system errors, the same request_id should be used for requests related to the same link.</p> required <code>account_id</code> <code>UUID</code> <p>The ID of the sender's account.</p> required <code>amount</code> <code>float</code> <p>The amount of money to be sent.</p> required <code>currency</code> <code>str</code> <p>The currency of the amount to be sent.</p> required <code>reference</code> <code>str</code> <p>A reference for the payment.</p> required <code>payout_methods</code> <code>list[EnumPayoutLinkPaymentMethod]</code> <p>The payout methods that the recipient can use to claim the payment. If not provided, the default value is [EnumPayoutLinkPaymentMethod.REVOLUT, EnumPayoutLinkPaymentMethod.BANK_ACCOUNT].</p> required <code>save_counterparty</code> <code>bool</code> <p>Indicates whether to save the recipient as your counterparty upon link claim. If false then the counterparty will not show up on your counterparties list, for example, when you retrieve your counterparties. However, you will still be able to retrieve this counterparty by its ID.</p> <p>If you don't choose to save the counterparty on link creation, you can do it later from your transactions list in the Business app.</p> <p>If not provided, the default value is false.</p> <code>None</code> <code>expiry_period</code> <code>Duration | str</code> <p>Possible values: &gt;= P1D and &lt;= P7D</p> <p>Default value: P7D</p> <p>The period after which the payout link expires if not claimed before, provided in ISO 8601 format.</p> <p>The default and maximum value is 7 days from the link creation.</p> <code>None</code> <code>transfer_reason_code</code> <code>EnumTransferReasonCode</code> <p>The reason code for the transaction. Transactions to certain countries and currencies might require you to provide a transfer reason. You can check available reason codes with the getTransferReasons operation.</p> <p>If a transfer reason is not required for the given currency and country, this field is ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The payout link information.</p> Source code in <code>pyrevolut/api/payout_links/endpoint/synchronous.py</code> <pre><code>def create_payout_link(\n    self,\n    counterparty_name: str,\n    request_id: str,\n    account_id: UUID,\n    amount: float,\n    currency: str,\n    reference: str,\n    payout_methods: list[EnumPayoutLinkPaymentMethod],\n    save_counterparty: bool | None = None,\n    expiry_period: Duration | str | None = None,\n    transfer_reason_code: EnumTransferReasonCode | None = None,\n    **kwargs,\n) -&gt; dict | CreatePayoutLink.Response:\n    \"\"\"\n    Create a payout link to send money even when you don't have the full\n    banking details of the counterparty.\n    After you have created the link, send it to the recipient so that\n    they can claim the payment.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n\n    Parameters\n    ----------\n    counterparty_name : str\n        The name of the counterparty provided by the sender.\n    request_id : str\n        The ID of the request, provided by the sender.\n\n        To ensure that a link payment is not processed multiple times if there\n        are network or system errors, the same request_id should be used for\n        requests related to the same link.\n    account_id : UUID\n        The ID of the sender's account.\n    amount : float\n        The amount of money to be sent.\n    currency : str\n        The currency of the amount to be sent.\n    reference : str\n        A reference for the payment.\n    payout_methods : list[EnumPayoutLinkPaymentMethod]\n        The payout methods that the recipient can use to claim the payment.\n        If not provided, the default value is\n        [EnumPayoutLinkPaymentMethod.REVOLUT, EnumPayoutLinkPaymentMethod.BANK_ACCOUNT].\n    save_counterparty : bool, optional\n        Indicates whether to save the recipient as your counterparty upon link claim.\n        If false then the counterparty will not show up on your counterparties list,\n        for example, when you retrieve your counterparties.\n        However, you will still be able to retrieve this counterparty by its ID.\n\n        If you don't choose to save the counterparty on link creation, you can do it later\n        from your transactions list in the Business app.\n\n        If not provided, the default value is false.\n    expiry_period : Duration | str, optional\n        Possible values: &gt;= P1D and &lt;= P7D\n\n        Default value: P7D\n\n        The period after which the payout link expires if not claimed before,\n        provided in ISO 8601 format.\n\n        The default and maximum value is 7 days from the link creation.\n    transfer_reason_code : EnumTransferReasonCode, optional\n        The reason code for the transaction.\n        Transactions to certain countries and currencies might require you to\n        provide a transfer reason.\n        You can check available reason codes with the getTransferReasons operation.\n\n        If a transfer reason is not required for the given currency and country,\n        this field is ignored.\n\n    Returns\n    -------\n    dict | CreatePayoutLink.Response\n        The payout link information.\n    \"\"\"\n    endpoint = CreatePayoutLink\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        counterparty_name=counterparty_name,\n        save_counterparty=save_counterparty,\n        request_id=request_id,\n        account_id=account_id,\n        amount=amount,\n        currency=currency,\n        reference=reference,\n        payout_methods=payout_methods,\n        expiry_period=expiry_period,\n        transfer_reasion_code=transfer_reason_code,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payout_links/synchronous/#pyrevolut.api.payout_links.endpoint.EndpointPayoutLinksSync.get_all_payout_links","title":"<code>get_all_payout_links(state=None, created_before=None, limit=None, **kwargs)</code>","text":"<p>Get all the links that you have created, or use the query parameters to filter the results.</p> <p>The links are sorted by the created_at date in reverse chronological order.</p> <p>The returned links are paginated. The maximum number of payout links returned per page is specified by the limit parameter. To get to the next page, make a new request and use the created_at date of the last payout link returned in the previous response.</p> Note <p>This feature is available in the UK and the EEA.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnumPayoutLinkState</code> <p>The state that the payout link is in. Possible states are:</p> <pre><code>created:\n    The payout link has been created, but the amount has not yet been blocked.\nfailed:\n    The payout link couldn't be generated due to a failure during transaction booking.\nawaiting:\n    The payout link is awaiting approval.\nactive:\n    The payout link can be redeemed.\nexpired:\n    The payout link cannot be redeemed because it wasn't claimed before its expiry date.\ncancelled:\n    The payout link cannot be redeemed because it was cancelled.\nprocessing:\n    The payout link has been redeemed and is being processed.\nprocessed:\n    The payout link has been redeemed and the money has been transferred to the recipient.\n</code></pre> <code>None</code> <code>created_before</code> <code>datetime | DateTime | str | int | float</code> <p>Retrieves links with created_at &lt; created_before. The default value is the current date and time at which you are calling the endpoint.</p> <p>Provided in ISO 8601 format.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of links returned per page. To get to the next page, make a new request and use the created_at date of the last payout link returned in the previous response as the value for created_before.</p> <p>If not provided, the default value is 100.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>A list of payout links.</p> Source code in <code>pyrevolut/api/payout_links/endpoint/synchronous.py</code> <pre><code>def get_all_payout_links(\n    self,\n    state: EnumPayoutLinkState | None = None,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    limit: int | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfPayoutLinks.Response]:\n    \"\"\"\n    Get all the links that you have created, or use the query parameters to filter the results.\n\n    The links are sorted by the created_at date in reverse chronological order.\n\n    The returned links are paginated. The maximum number of payout links returned per\n    page is specified by the limit parameter. To get to the next page, make a\n    new request and use the created_at date of the last payout link returned in the previous response.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n\n    Parameters\n    ----------\n    state : EnumPayoutLinkState, optional\n        The state that the payout link is in. Possible states are:\n\n            created:\n                The payout link has been created, but the amount has not yet been blocked.\n            failed:\n                The payout link couldn't be generated due to a failure during transaction booking.\n            awaiting:\n                The payout link is awaiting approval.\n            active:\n                The payout link can be redeemed.\n            expired:\n                The payout link cannot be redeemed because it wasn't claimed before its expiry date.\n            cancelled:\n                The payout link cannot be redeemed because it was cancelled.\n            processing:\n                The payout link has been redeemed and is being processed.\n            processed:\n                The payout link has been redeemed and the money has been transferred to the recipient.\n    created_before : datetime | DateTime | str | int | float, optional\n        Retrieves links with created_at &lt; created_before.\n        The default value is the current date and time at which you are calling the endpoint.\n\n        Provided in ISO 8601 format.\n    limit : int, optional\n        The maximum number of links returned per page.\n        To get to the next page, make a new request and use the\n        created_at date of the last payout link returned in the previous\n        response as the value for created_before.\n\n        If not provided, the default value is 100.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfPayoutLinks.Response]\n        A list of payout links.\n    \"\"\"\n    endpoint = RetrieveListOfPayoutLinks\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        state=state,\n        created_before=created_before,\n        limit=limit,\n    )\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/payout_links/synchronous/#pyrevolut.api.payout_links.endpoint.EndpointPayoutLinksSync.get_payout_link","title":"<code>get_payout_link(payout_link_id, **kwargs)</code>","text":"<p>Get the information about a specific link by its ID.</p> Note <p>This feature is available in the UK and the EEA.</p> <p>Parameters:</p> Name Type Description Default <code>payout_link_id</code> <code>UUID</code> <p>The ID of the payout link.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The payout link information.</p> Source code in <code>pyrevolut/api/payout_links/endpoint/synchronous.py</code> <pre><code>def get_payout_link(\n    self,\n    payout_link_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrievePayoutLink.Response:\n    \"\"\"\n    Get the information about a specific link by its ID.\n\n    Note\n    ----\n    This feature is available in the UK and the EEA.\n\n    Parameters\n    ----------\n    payout_link_id : UUID\n        The ID of the payout link.\n\n    Returns\n    -------\n    dict | RetrievePayoutLink.Response\n        The payout link information.\n    \"\"\"\n    endpoint = RetrievePayoutLink\n    path = endpoint.ROUTE.format(payout_link_id=payout_link_id)\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/simulations/asynchronous/","title":"Simulations Asynchronous Endpoints","text":"<p>This <code>Simulations</code> endpoint provides asynchronous methods to interact with the simulations of the authenticated user.</p> <p>Example usage of the Simulations endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        response = await client.Simulations.simulate_account_topup(\n            account_id=\"SOME_ACCOUNT_ID\",\n            amount=100.0,\n            currency=\"USD\",\n            reference=\"Sugar Daddy :heart:\",\n            state=EnumTransactionState.COMPLETED,\n        )\n        print(response)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/simulations/asynchronous/#pyrevolut.api.simulations.endpoint.EndpointSimulationsAsync","title":"<code>EndpointSimulationsAsync</code>","text":"<p>               Bases: <code>BaseEndpointAsync</code></p> <p>The async Simulations API</p> <p>The Simulations API is only available in the Sandbox environment. It lets you simulate certain events that are otherwise only possible in the production environment, such as your account's top-up and transfer state changes.</p> Source code in <code>pyrevolut/api/simulations/endpoint/asynchronous.py</code> <pre><code>class EndpointSimulationsAsync(BaseEndpointAsync):\n    \"\"\"The async Simulations API\n\n    The Simulations API is only available in the Sandbox environment.\n    It lets you simulate certain events that are otherwise only possible in the production environment,\n    such as your account's top-up and transfer state changes.\n    \"\"\"\n\n    async def simulate_account_topup(\n        self,\n        account_id: UUID,\n        amount: float,\n        currency: str,\n        reference: str | None = None,\n        state: EnumTransactionState | None = None,\n        **kwargs,\n    ) -&gt; dict | SimulateAccountTopup.Response:\n        \"\"\"\n        Simulate a top-up of your account in the Sandbox environment.\n\n        This is useful during testing, when you run out of money in your test account\n        and need to add more.\n\n        Parameters\n        ----------\n        account_id : UUID\n            The ID of the account that you want to top up.\n        amount : float\n            The amount with which you want to top up the account. Must be &lt;= 10000\n        currency : str\n            The currency of the top-up amount. Must be a valid ISO 4217 currency code.\n        reference : str, optional\n            A short description for your top up.\n            Default value: 'Test Top-up' if not provided.\n        state : EnumTransactionState, optional\n            The state to which you want to set the top-up transaction.\n\n            If not provided, the default value is 'completed'.\n\n            Possible values:\n\n                pending:\n                    The transaction is pending until it's being processed.\n                    If the transfer is made between Revolut accounts,\n                    this state is skipped and the transaction is executed instantly.\n                completed:\n                    The transaction was successful.\n                failed:\n                    The transaction was unsuccessful. This can happen for a variety of reasons,\n                    for example, invalid API calls, blocked payments, etc.\n                reverted:\n                    The transaction was reverted. This can happen for a variety of reasons,\n                    for example, the receiver being inaccessible.\n\n        Returns\n        -------\n        dict | SimulateAccountTopup.Response\n            The top-up transaction information.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = SimulateAccountTopup\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            account_id=account_id,\n            amount=amount,\n            currency=currency,\n            reference=reference,\n            state=state,\n        )\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    async def simulate_transfer_state_update(\n        self,\n        transfer_id: UUID,\n        action: Literal[\"complete\", \"revert\", \"decline\", \"fail\"],\n        **kwargs,\n    ) -&gt; dict | SimulateTransferStateUpdate.Response:\n        \"\"\"\n        Simulate a transfer state change in the Sandbox environment.\n\n        For example, after you make a transfer in Sandbox, you can change its\n        state to completed.\n\n        The resulting state is final and cannot be changed.\n\n        Parameters\n        ----------\n        transfer_id : UUID\n            The ID of the transfer whose state you want to update.\n        action : Literal[\"complete\", \"revert\", \"decline\", \"fail\"]\n            The action you want to perform on the transfer. Possible values:\n\n                complete:\n                    Simulate a completed transfer.\n                revert:\n                    Simulate a reverted transfer.\n                decline:\n                    Simulate a declined transfer.\n                fail:\n                    Simulate a failed transfer.\n\n        Returns\n        -------\n        dict | SimulateTransferStateUpdate.Response\n            The updated transfer information.\n        \"\"\"\n        self.__check_sandbox()\n        assert action in [\"complete\", \"revert\", \"decline\", \"fail\"], \"Invalid action\"\n        endpoint = SimulateTransferStateUpdate\n        path = endpoint.ROUTE.format(transfer_id=transfer_id, action=action)\n        body = endpoint.Body()\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def __check_sandbox(self):\n        \"\"\"\n        Check if the sandbox is enabled.\n\n        Raises\n        ------\n        PyRevolutInvalidEnvironment\n            If the sandbox is enabled.\n        \"\"\"\n        if not self.client.sandbox:\n            raise PyRevolutInvalidEnvironment(\n                \"This feature is only available in the Sandbox.\"\n            )\n</code></pre>"},{"location":"code_reference/api/simulations/asynchronous/#pyrevolut.api.simulations.endpoint.EndpointSimulationsAsync.__check_sandbox","title":"<code>__check_sandbox()</code>","text":"<p>Check if the sandbox is enabled.</p> <p>Raises:</p> Type Description <code>PyRevolutInvalidEnvironment</code> <p>If the sandbox is enabled.</p> Source code in <code>pyrevolut/api/simulations/endpoint/asynchronous.py</code> <pre><code>def __check_sandbox(self):\n    \"\"\"\n    Check if the sandbox is enabled.\n\n    Raises\n    ------\n    PyRevolutInvalidEnvironment\n        If the sandbox is enabled.\n    \"\"\"\n    if not self.client.sandbox:\n        raise PyRevolutInvalidEnvironment(\n            \"This feature is only available in the Sandbox.\"\n        )\n</code></pre>"},{"location":"code_reference/api/simulations/asynchronous/#pyrevolut.api.simulations.endpoint.EndpointSimulationsAsync.simulate_account_topup","title":"<code>simulate_account_topup(account_id, amount, currency, reference=None, state=None, **kwargs)</code>  <code>async</code>","text":"<p>Simulate a top-up of your account in the Sandbox environment.</p> <p>This is useful during testing, when you run out of money in your test account and need to add more.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>UUID</code> <p>The ID of the account that you want to top up.</p> required <code>amount</code> <code>float</code> <p>The amount with which you want to top up the account. Must be &lt;= 10000</p> required <code>currency</code> <code>str</code> <p>The currency of the top-up amount. Must be a valid ISO 4217 currency code.</p> required <code>reference</code> <code>str</code> <p>A short description for your top up. Default value: 'Test Top-up' if not provided.</p> <code>None</code> <code>state</code> <code>EnumTransactionState</code> <p>The state to which you want to set the top-up transaction.</p> <p>If not provided, the default value is 'completed'.</p> <p>Possible values:</p> <pre><code>pending:\n    The transaction is pending until it's being processed.\n    If the transfer is made between Revolut accounts,\n    this state is skipped and the transaction is executed instantly.\ncompleted:\n    The transaction was successful.\nfailed:\n    The transaction was unsuccessful. This can happen for a variety of reasons,\n    for example, invalid API calls, blocked payments, etc.\nreverted:\n    The transaction was reverted. This can happen for a variety of reasons,\n    for example, the receiver being inaccessible.\n</code></pre> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The top-up transaction information.</p> Source code in <code>pyrevolut/api/simulations/endpoint/asynchronous.py</code> <pre><code>async def simulate_account_topup(\n    self,\n    account_id: UUID,\n    amount: float,\n    currency: str,\n    reference: str | None = None,\n    state: EnumTransactionState | None = None,\n    **kwargs,\n) -&gt; dict | SimulateAccountTopup.Response:\n    \"\"\"\n    Simulate a top-up of your account in the Sandbox environment.\n\n    This is useful during testing, when you run out of money in your test account\n    and need to add more.\n\n    Parameters\n    ----------\n    account_id : UUID\n        The ID of the account that you want to top up.\n    amount : float\n        The amount with which you want to top up the account. Must be &lt;= 10000\n    currency : str\n        The currency of the top-up amount. Must be a valid ISO 4217 currency code.\n    reference : str, optional\n        A short description for your top up.\n        Default value: 'Test Top-up' if not provided.\n    state : EnumTransactionState, optional\n        The state to which you want to set the top-up transaction.\n\n        If not provided, the default value is 'completed'.\n\n        Possible values:\n\n            pending:\n                The transaction is pending until it's being processed.\n                If the transfer is made between Revolut accounts,\n                this state is skipped and the transaction is executed instantly.\n            completed:\n                The transaction was successful.\n            failed:\n                The transaction was unsuccessful. This can happen for a variety of reasons,\n                for example, invalid API calls, blocked payments, etc.\n            reverted:\n                The transaction was reverted. This can happen for a variety of reasons,\n                for example, the receiver being inaccessible.\n\n    Returns\n    -------\n    dict | SimulateAccountTopup.Response\n        The top-up transaction information.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = SimulateAccountTopup\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        account_id=account_id,\n        amount=amount,\n        currency=currency,\n        reference=reference,\n        state=state,\n    )\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/simulations/asynchronous/#pyrevolut.api.simulations.endpoint.EndpointSimulationsAsync.simulate_transfer_state_update","title":"<code>simulate_transfer_state_update(transfer_id, action, **kwargs)</code>  <code>async</code>","text":"<p>Simulate a transfer state change in the Sandbox environment.</p> <p>For example, after you make a transfer in Sandbox, you can change its state to completed.</p> <p>The resulting state is final and cannot be changed.</p> <p>Parameters:</p> Name Type Description Default <code>transfer_id</code> <code>UUID</code> <p>The ID of the transfer whose state you want to update.</p> required <code>action</code> <code>Literal['complete', 'revert', 'decline', 'fail']</code> <p>The action you want to perform on the transfer. Possible values:</p> <pre><code>complete:\n    Simulate a completed transfer.\nrevert:\n    Simulate a reverted transfer.\ndecline:\n    Simulate a declined transfer.\nfail:\n    Simulate a failed transfer.\n</code></pre> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The updated transfer information.</p> Source code in <code>pyrevolut/api/simulations/endpoint/asynchronous.py</code> <pre><code>async def simulate_transfer_state_update(\n    self,\n    transfer_id: UUID,\n    action: Literal[\"complete\", \"revert\", \"decline\", \"fail\"],\n    **kwargs,\n) -&gt; dict | SimulateTransferStateUpdate.Response:\n    \"\"\"\n    Simulate a transfer state change in the Sandbox environment.\n\n    For example, after you make a transfer in Sandbox, you can change its\n    state to completed.\n\n    The resulting state is final and cannot be changed.\n\n    Parameters\n    ----------\n    transfer_id : UUID\n        The ID of the transfer whose state you want to update.\n    action : Literal[\"complete\", \"revert\", \"decline\", \"fail\"]\n        The action you want to perform on the transfer. Possible values:\n\n            complete:\n                Simulate a completed transfer.\n            revert:\n                Simulate a reverted transfer.\n            decline:\n                Simulate a declined transfer.\n            fail:\n                Simulate a failed transfer.\n\n    Returns\n    -------\n    dict | SimulateTransferStateUpdate.Response\n        The updated transfer information.\n    \"\"\"\n    self.__check_sandbox()\n    assert action in [\"complete\", \"revert\", \"decline\", \"fail\"], \"Invalid action\"\n    endpoint = SimulateTransferStateUpdate\n    path = endpoint.ROUTE.format(transfer_id=transfer_id, action=action)\n    body = endpoint.Body()\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/simulations/pydantic/","title":"Simulations Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Simulations</code> endpoint.</p>"},{"location":"code_reference/api/simulations/pydantic/#pyrevolut.api.simulations.post.SimulateAccountTopup","title":"<code>SimulateAccountTopup</code>","text":"<p>Simulate a top-up of your account in the Sandbox environment.</p> <p>This is useful during testing, when you run out of money in your test account and need to add more.</p> Source code in <code>pyrevolut/api/simulations/post/simulate_account_topup.py</code> <pre><code>class SimulateAccountTopup:\n    \"\"\"\n    Simulate a top-up of your account in the Sandbox environment.\n\n    This is useful during testing, when you run out of money in your test account\n    and need to add more.\n    \"\"\"\n\n    ROUTE = \"/1.0/sandbox/topup\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The body of the request.\n        \"\"\"\n\n        account_id: Annotated[\n            UUID,\n            Field(description=\"The ID of the account that you want to top up.\"),\n        ]\n        amount: Annotated[\n            float,\n            Field(\n                description=\"The amount with which you want to top up the account. Must be &lt;= 10000\",\n                gt=0,\n                le=10000,\n            ),\n        ]\n        currency: Annotated[\n            Currency,\n            Field(\n                description=\"The currency of the top-up amount. Must be a valid ISO 4217 currency code.\",\n            ),\n        ]\n        reference: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                A short description for your top up.\n                Default value: 'Test Top-up' if not provided.\n                \"\"\",\n            ),\n        ] = None\n        state: Annotated[\n            EnumTransactionState | None,\n            Field(\n                description=\"\"\"\n                The state to which you want to set the top-up transaction. \n\n                If not provided, the default value is 'completed'.\n\n                Possible values:\n\n                    pending:\n                        The transaction is pending until it's being processed.\n                        If the transfer is made between Revolut accounts,\n                        this state is skipped and the transaction is executed instantly.\n                    completed:\n                        The transaction was successful.\n                    failed:\n                        The transaction was unsuccessful. This can happen for a variety of reasons,\n                        for example, invalid API calls, blocked payments, etc.\n                    reverted:\n                        The transaction was reverted. This can happen for a variety of reasons,\n                        for example, the receiver being inaccessible.\n                \"\"\"\n            ),\n        ] = None\n\n        @model_validator(mode=\"after\")\n        def check_inputs(self) -&gt; \"SimulateAccountTopup.Body\":\n            \"\"\"\n            Check that the input is correct.\n            \"\"\"\n\n            if self.state is not None:\n                assert self.state in [\n                    EnumTransactionState.PENDING,\n                    EnumTransactionState.COMPLETED,\n                    EnumTransactionState.FAILED,\n                    EnumTransactionState.REVERTED,\n                ], (\n                    f\"Invalid state: {self.state}. \"\n                    f\"Possible values: {EnumTransactionState.PENDING}, \"\n                    f\"{EnumTransactionState.COMPLETED}, {EnumTransactionState.FAILED}, \"\n                    f\"{EnumTransactionState.REVERTED}.\"\n                )\n            return self\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model.\n        \"\"\"\n\n        id: Annotated[\n            UUID, Field(description=\"The ID of the account that was topped up.\")\n        ]\n        state: Annotated[\n            EnumTransactionState,\n            Field(\n                description=\"\"\"\n                The state of the top-up transaction. Possible values:\n\n                pending:\n                    The transaction is pending until it's being processed.\n                    If the transfer is made between Revolut accounts,\n                    this state is skipped and the transaction is executed instantly.\n                completed:\n                    The transaction was successful.\n                failed:\n                    The transaction was unsuccessful. This can happen for a variety of reasons,\n                    for example, invalid API calls, blocked payments, etc.\n                reverted:\n                    The transaction was reverted. This can happen for a variety of reasons,\n                    for example, the receiver being inaccessible.\n                \"\"\"\n            ),\n        ]\n        created_at: Annotated[\n            DateTime,\n            Field(\n                description=\"The date and time the transaction was created in ISO 8601 format.\"\n            ),\n        ]\n        completed_at: Annotated[\n            DateTime | None,\n            Field(\n                description=\"The date and time the transaction was completed in ISO 8601 format.\"\n            ),\n        ] = None\n</code></pre>"},{"location":"code_reference/api/simulations/pydantic/#pyrevolut.api.simulations.post.SimulateAccountTopup.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The body of the request.</p> Source code in <code>pyrevolut/api/simulations/post/simulate_account_topup.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The body of the request.\n    \"\"\"\n\n    account_id: Annotated[\n        UUID,\n        Field(description=\"The ID of the account that you want to top up.\"),\n    ]\n    amount: Annotated[\n        float,\n        Field(\n            description=\"The amount with which you want to top up the account. Must be &lt;= 10000\",\n            gt=0,\n            le=10000,\n        ),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(\n            description=\"The currency of the top-up amount. Must be a valid ISO 4217 currency code.\",\n        ),\n    ]\n    reference: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            A short description for your top up.\n            Default value: 'Test Top-up' if not provided.\n            \"\"\",\n        ),\n    ] = None\n    state: Annotated[\n        EnumTransactionState | None,\n        Field(\n            description=\"\"\"\n            The state to which you want to set the top-up transaction. \n\n            If not provided, the default value is 'completed'.\n\n            Possible values:\n\n                pending:\n                    The transaction is pending until it's being processed.\n                    If the transfer is made between Revolut accounts,\n                    this state is skipped and the transaction is executed instantly.\n                completed:\n                    The transaction was successful.\n                failed:\n                    The transaction was unsuccessful. This can happen for a variety of reasons,\n                    for example, invalid API calls, blocked payments, etc.\n                reverted:\n                    The transaction was reverted. This can happen for a variety of reasons,\n                    for example, the receiver being inaccessible.\n            \"\"\"\n        ),\n    ] = None\n\n    @model_validator(mode=\"after\")\n    def check_inputs(self) -&gt; \"SimulateAccountTopup.Body\":\n        \"\"\"\n        Check that the input is correct.\n        \"\"\"\n\n        if self.state is not None:\n            assert self.state in [\n                EnumTransactionState.PENDING,\n                EnumTransactionState.COMPLETED,\n                EnumTransactionState.FAILED,\n                EnumTransactionState.REVERTED,\n            ], (\n                f\"Invalid state: {self.state}. \"\n                f\"Possible values: {EnumTransactionState.PENDING}, \"\n                f\"{EnumTransactionState.COMPLETED}, {EnumTransactionState.FAILED}, \"\n                f\"{EnumTransactionState.REVERTED}.\"\n            )\n        return self\n</code></pre>"},{"location":"code_reference/api/simulations/pydantic/#pyrevolut.api.simulations.post.SimulateAccountTopup.Body.check_inputs","title":"<code>check_inputs()</code>","text":"<p>Check that the input is correct.</p> Source code in <code>pyrevolut/api/simulations/post/simulate_account_topup.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_inputs(self) -&gt; \"SimulateAccountTopup.Body\":\n    \"\"\"\n    Check that the input is correct.\n    \"\"\"\n\n    if self.state is not None:\n        assert self.state in [\n            EnumTransactionState.PENDING,\n            EnumTransactionState.COMPLETED,\n            EnumTransactionState.FAILED,\n            EnumTransactionState.REVERTED,\n        ], (\n            f\"Invalid state: {self.state}. \"\n            f\"Possible values: {EnumTransactionState.PENDING}, \"\n            f\"{EnumTransactionState.COMPLETED}, {EnumTransactionState.FAILED}, \"\n            f\"{EnumTransactionState.REVERTED}.\"\n        )\n    return self\n</code></pre>"},{"location":"code_reference/api/simulations/pydantic/#pyrevolut.api.simulations.post.SimulateAccountTopup.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model.</p> Source code in <code>pyrevolut/api/simulations/post/simulate_account_topup.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model.\n    \"\"\"\n\n    id: Annotated[\n        UUID, Field(description=\"The ID of the account that was topped up.\")\n    ]\n    state: Annotated[\n        EnumTransactionState,\n        Field(\n            description=\"\"\"\n            The state of the top-up transaction. Possible values:\n\n            pending:\n                The transaction is pending until it's being processed.\n                If the transfer is made between Revolut accounts,\n                this state is skipped and the transaction is executed instantly.\n            completed:\n                The transaction was successful.\n            failed:\n                The transaction was unsuccessful. This can happen for a variety of reasons,\n                for example, invalid API calls, blocked payments, etc.\n            reverted:\n                The transaction was reverted. This can happen for a variety of reasons,\n                for example, the receiver being inaccessible.\n            \"\"\"\n        ),\n    ]\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the transaction was created in ISO 8601 format.\"\n        ),\n    ]\n    completed_at: Annotated[\n        DateTime | None,\n        Field(\n            description=\"The date and time the transaction was completed in ISO 8601 format.\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/simulations/pydantic/#pyrevolut.api.simulations.post.SimulateTransferStateUpdate","title":"<code>SimulateTransferStateUpdate</code>","text":"<p>Simulate a transfer state change in the Sandbox environment.</p> <p>For example, after you make a transfer in Sandbox, you can change its state to completed.</p> <p>The resulting state is final and cannot be changed.</p> Source code in <code>pyrevolut/api/simulations/post/simulate_transfer_state_update.py</code> <pre><code>class SimulateTransferStateUpdate:\n    \"\"\"\n    Simulate a transfer state change in the Sandbox environment.\n\n    For example, after you make a transfer in Sandbox, you can change its\n    state to completed.\n\n    The resulting state is final and cannot be changed.\n    \"\"\"\n\n    ROUTE = \"/1.0/sandbox/transactions/{transfer_id}/{action}\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The body of the request.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model.\n        \"\"\"\n\n        id: Annotated[\n            UUID, Field(description=\"The ID of the transfer whose state was updated.\")\n        ]\n        state: Annotated[\n            EnumTransactionState,\n            Field(\n                description=\"\"\"\n                Indicates the simulated transaction state. Possible values:\n\n                completed:\n                    Transaction was successfully processed.\n                reverted:\n                    Transaction was reverted by the system or company, but not the user. \n                    This can happen for a variety of reasons, for example, the receiver being inaccessible.\n                declined:\n                    Transaction was declined to the user for a good reason, such as insufficient \n                    account balance, wrong receiver information, etc.\n                failed:\n                    Transaction failed during initiation or completion. \n                    This can happen for a variety of reasons, for example, \n                    invalid API calls, blocked payments, etc.\n                \"\"\"\n            ),\n        ]\n        created_at: Annotated[\n            DateTime,\n            Field(\n                description=\"The date and time the transfer was created in ISO 8601 format.\"\n            ),\n        ]\n        completed_at: Annotated[\n            DateTime | None,\n            Field(\n                description=\"The date and time the transfer was completed in ISO 8601 format.\"\n            ),\n        ] = None\n</code></pre>"},{"location":"code_reference/api/simulations/pydantic/#pyrevolut.api.simulations.post.SimulateTransferStateUpdate.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The body of the request.</p> Source code in <code>pyrevolut/api/simulations/post/simulate_transfer_state_update.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The body of the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/simulations/pydantic/#pyrevolut.api.simulations.post.SimulateTransferStateUpdate.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model.</p> Source code in <code>pyrevolut/api/simulations/post/simulate_transfer_state_update.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model.\n    \"\"\"\n\n    id: Annotated[\n        UUID, Field(description=\"The ID of the transfer whose state was updated.\")\n    ]\n    state: Annotated[\n        EnumTransactionState,\n        Field(\n            description=\"\"\"\n            Indicates the simulated transaction state. Possible values:\n\n            completed:\n                Transaction was successfully processed.\n            reverted:\n                Transaction was reverted by the system or company, but not the user. \n                This can happen for a variety of reasons, for example, the receiver being inaccessible.\n            declined:\n                Transaction was declined to the user for a good reason, such as insufficient \n                account balance, wrong receiver information, etc.\n            failed:\n                Transaction failed during initiation or completion. \n                This can happen for a variety of reasons, for example, \n                invalid API calls, blocked payments, etc.\n            \"\"\"\n        ),\n    ]\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the transfer was created in ISO 8601 format.\"\n        ),\n    ]\n    completed_at: Annotated[\n        DateTime | None,\n        Field(\n            description=\"The date and time the transfer was completed in ISO 8601 format.\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/simulations/synchronous/","title":"Simulations Synchronous Endpoints","text":"<p>This <code>Simulations</code> endpoint provides methods to interact with the simulations of the authenticated user.</p> <p>Example usage of the Simulations endpoint object:</p> <pre><code>from pyrevolut.client import Client\nfrom pyrevolut.api import EnumTransactionState\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    response = client.Simulations.simulate_account_topup(\n        account_id=\"SOME_ACCOUNT_ID\",\n        amount=100.0,\n        currency=\"USD\",\n        reference=\"Sugar Daddy :heart:\",\n        state=EnumTransactionState.COMPLETED,\n    )\n    print(response)\n</code></pre>"},{"location":"code_reference/api/simulations/synchronous/#pyrevolut.api.simulations.endpoint.EndpointSimulationsSync","title":"<code>EndpointSimulationsSync</code>","text":"<p>               Bases: <code>BaseEndpointSync</code></p> <p>The Simulations API</p> <p>The Simulations API is only available in the Sandbox environment. It lets you simulate certain events that are otherwise only possible in the production environment, such as your account's top-up and transfer state changes.</p> Source code in <code>pyrevolut/api/simulations/endpoint/synchronous.py</code> <pre><code>class EndpointSimulationsSync(BaseEndpointSync):\n    \"\"\"The Simulations API\n\n    The Simulations API is only available in the Sandbox environment.\n    It lets you simulate certain events that are otherwise only possible in the production environment,\n    such as your account's top-up and transfer state changes.\n    \"\"\"\n\n    def simulate_account_topup(\n        self,\n        account_id: UUID,\n        amount: float,\n        currency: str,\n        reference: str | None = None,\n        state: EnumTransactionState | None = None,\n        **kwargs,\n    ) -&gt; dict | SimulateAccountTopup.Response:\n        \"\"\"\n        Simulate a top-up of your account in the Sandbox environment.\n\n        This is useful during testing, when you run out of money in your test account\n        and need to add more.\n\n        Parameters\n        ----------\n        account_id : UUID\n            The ID of the account that you want to top up.\n        amount : float\n            The amount with which you want to top up the account. Must be &lt;= 10000\n        currency : str\n            The currency of the top-up amount. Must be a valid ISO 4217 currency code.\n        reference : str, optional\n            A short description for your top up.\n            Default value: 'Test Top-up' if not provided.\n        state : EnumTransactionState, optional\n            The state to which you want to set the top-up transaction.\n\n            If not provided, the default value is 'completed'.\n\n            Possible values:\n\n                pending:\n                    The transaction is pending until it's being processed.\n                    If the transfer is made between Revolut accounts,\n                    this state is skipped and the transaction is executed instantly.\n                completed:\n                    The transaction was successful.\n                failed:\n                    The transaction was unsuccessful. This can happen for a variety of reasons,\n                    for example, invalid API calls, blocked payments, etc.\n                reverted:\n                    The transaction was reverted. This can happen for a variety of reasons,\n                    for example, the receiver being inaccessible.\n\n        Returns\n        -------\n        dict | SimulateAccountTopup.Response\n            The top-up transaction information.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = SimulateAccountTopup\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            account_id=account_id,\n            amount=amount,\n            currency=currency,\n            reference=reference,\n            state=state,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def simulate_transfer_state_update(\n        self,\n        transfer_id: UUID,\n        action: Literal[\"complete\", \"revert\", \"decline\", \"fail\"],\n        **kwargs,\n    ) -&gt; dict | SimulateTransferStateUpdate.Response:\n        \"\"\"\n        Simulate a transfer state change in the Sandbox environment.\n\n        For example, after you make a transfer in Sandbox, you can change its\n        state to completed.\n\n        The resulting state is final and cannot be changed.\n\n        Parameters\n        ----------\n        transfer_id : UUID\n            The ID of the transfer whose state you want to update.\n        action : Literal[\"complete\", \"revert\", \"decline\", \"fail\"]\n            The action you want to perform on the transfer. Possible values:\n\n                complete:\n                    Simulate a completed transfer.\n                revert:\n                    Simulate a reverted transfer.\n                decline:\n                    Simulate a declined transfer.\n                fail:\n                    Simulate a failed transfer.\n\n        Returns\n        -------\n        dict | SimulateTransferStateUpdate.Response\n            The updated transfer information.\n        \"\"\"\n        self.__check_sandbox()\n        assert action in [\"complete\", \"revert\", \"decline\", \"fail\"], \"Invalid action\"\n        endpoint = SimulateTransferStateUpdate\n        path = endpoint.ROUTE.format(transfer_id=transfer_id, action=action)\n        body = endpoint.Body()\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def __check_sandbox(self):\n        \"\"\"\n        Check if the sandbox is enabled.\n\n        Raises\n        ------\n        PyRevolutInvalidEnvironment\n            If the sandbox is enabled.\n        \"\"\"\n        if not self.client.sandbox:\n            raise PyRevolutInvalidEnvironment(\n                \"This feature is only available in the Sandbox.\"\n            )\n</code></pre>"},{"location":"code_reference/api/simulations/synchronous/#pyrevolut.api.simulations.endpoint.EndpointSimulationsSync.__check_sandbox","title":"<code>__check_sandbox()</code>","text":"<p>Check if the sandbox is enabled.</p> <p>Raises:</p> Type Description <code>PyRevolutInvalidEnvironment</code> <p>If the sandbox is enabled.</p> Source code in <code>pyrevolut/api/simulations/endpoint/synchronous.py</code> <pre><code>def __check_sandbox(self):\n    \"\"\"\n    Check if the sandbox is enabled.\n\n    Raises\n    ------\n    PyRevolutInvalidEnvironment\n        If the sandbox is enabled.\n    \"\"\"\n    if not self.client.sandbox:\n        raise PyRevolutInvalidEnvironment(\n            \"This feature is only available in the Sandbox.\"\n        )\n</code></pre>"},{"location":"code_reference/api/simulations/synchronous/#pyrevolut.api.simulations.endpoint.EndpointSimulationsSync.simulate_account_topup","title":"<code>simulate_account_topup(account_id, amount, currency, reference=None, state=None, **kwargs)</code>","text":"<p>Simulate a top-up of your account in the Sandbox environment.</p> <p>This is useful during testing, when you run out of money in your test account and need to add more.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>UUID</code> <p>The ID of the account that you want to top up.</p> required <code>amount</code> <code>float</code> <p>The amount with which you want to top up the account. Must be &lt;= 10000</p> required <code>currency</code> <code>str</code> <p>The currency of the top-up amount. Must be a valid ISO 4217 currency code.</p> required <code>reference</code> <code>str</code> <p>A short description for your top up. Default value: 'Test Top-up' if not provided.</p> <code>None</code> <code>state</code> <code>EnumTransactionState</code> <p>The state to which you want to set the top-up transaction.</p> <p>If not provided, the default value is 'completed'.</p> <p>Possible values:</p> <pre><code>pending:\n    The transaction is pending until it's being processed.\n    If the transfer is made between Revolut accounts,\n    this state is skipped and the transaction is executed instantly.\ncompleted:\n    The transaction was successful.\nfailed:\n    The transaction was unsuccessful. This can happen for a variety of reasons,\n    for example, invalid API calls, blocked payments, etc.\nreverted:\n    The transaction was reverted. This can happen for a variety of reasons,\n    for example, the receiver being inaccessible.\n</code></pre> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The top-up transaction information.</p> Source code in <code>pyrevolut/api/simulations/endpoint/synchronous.py</code> <pre><code>def simulate_account_topup(\n    self,\n    account_id: UUID,\n    amount: float,\n    currency: str,\n    reference: str | None = None,\n    state: EnumTransactionState | None = None,\n    **kwargs,\n) -&gt; dict | SimulateAccountTopup.Response:\n    \"\"\"\n    Simulate a top-up of your account in the Sandbox environment.\n\n    This is useful during testing, when you run out of money in your test account\n    and need to add more.\n\n    Parameters\n    ----------\n    account_id : UUID\n        The ID of the account that you want to top up.\n    amount : float\n        The amount with which you want to top up the account. Must be &lt;= 10000\n    currency : str\n        The currency of the top-up amount. Must be a valid ISO 4217 currency code.\n    reference : str, optional\n        A short description for your top up.\n        Default value: 'Test Top-up' if not provided.\n    state : EnumTransactionState, optional\n        The state to which you want to set the top-up transaction.\n\n        If not provided, the default value is 'completed'.\n\n        Possible values:\n\n            pending:\n                The transaction is pending until it's being processed.\n                If the transfer is made between Revolut accounts,\n                this state is skipped and the transaction is executed instantly.\n            completed:\n                The transaction was successful.\n            failed:\n                The transaction was unsuccessful. This can happen for a variety of reasons,\n                for example, invalid API calls, blocked payments, etc.\n            reverted:\n                The transaction was reverted. This can happen for a variety of reasons,\n                for example, the receiver being inaccessible.\n\n    Returns\n    -------\n    dict | SimulateAccountTopup.Response\n        The top-up transaction information.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = SimulateAccountTopup\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        account_id=account_id,\n        amount=amount,\n        currency=currency,\n        reference=reference,\n        state=state,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/simulations/synchronous/#pyrevolut.api.simulations.endpoint.EndpointSimulationsSync.simulate_transfer_state_update","title":"<code>simulate_transfer_state_update(transfer_id, action, **kwargs)</code>","text":"<p>Simulate a transfer state change in the Sandbox environment.</p> <p>For example, after you make a transfer in Sandbox, you can change its state to completed.</p> <p>The resulting state is final and cannot be changed.</p> <p>Parameters:</p> Name Type Description Default <code>transfer_id</code> <code>UUID</code> <p>The ID of the transfer whose state you want to update.</p> required <code>action</code> <code>Literal['complete', 'revert', 'decline', 'fail']</code> <p>The action you want to perform on the transfer. Possible values:</p> <pre><code>complete:\n    Simulate a completed transfer.\nrevert:\n    Simulate a reverted transfer.\ndecline:\n    Simulate a declined transfer.\nfail:\n    Simulate a failed transfer.\n</code></pre> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The updated transfer information.</p> Source code in <code>pyrevolut/api/simulations/endpoint/synchronous.py</code> <pre><code>def simulate_transfer_state_update(\n    self,\n    transfer_id: UUID,\n    action: Literal[\"complete\", \"revert\", \"decline\", \"fail\"],\n    **kwargs,\n) -&gt; dict | SimulateTransferStateUpdate.Response:\n    \"\"\"\n    Simulate a transfer state change in the Sandbox environment.\n\n    For example, after you make a transfer in Sandbox, you can change its\n    state to completed.\n\n    The resulting state is final and cannot be changed.\n\n    Parameters\n    ----------\n    transfer_id : UUID\n        The ID of the transfer whose state you want to update.\n    action : Literal[\"complete\", \"revert\", \"decline\", \"fail\"]\n        The action you want to perform on the transfer. Possible values:\n\n            complete:\n                Simulate a completed transfer.\n            revert:\n                Simulate a reverted transfer.\n            decline:\n                Simulate a declined transfer.\n            fail:\n                Simulate a failed transfer.\n\n    Returns\n    -------\n    dict | SimulateTransferStateUpdate.Response\n        The updated transfer information.\n    \"\"\"\n    self.__check_sandbox()\n    assert action in [\"complete\", \"revert\", \"decline\", \"fail\"], \"Invalid action\"\n    endpoint = SimulateTransferStateUpdate\n    path = endpoint.ROUTE.format(transfer_id=transfer_id, action=action)\n    body = endpoint.Body()\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/team_members/asynchronous/","title":"Team Members Asynchronous Endpoints","text":"<p>This <code>Team Members</code> endpoint provides asynchronous methods to interact with the team members of the authenticated user.</p> <p>Example usage of the Team Members endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        members = await client.TeamMembers.get_team_members()\n        print(members)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/team_members/asynchronous/#pyrevolut.api.team_members.endpoint.EndpointTeamMembersAsync","title":"<code>EndpointTeamMembersAsync</code>","text":"<p>               Bases: <code>BaseEndpointAsync</code></p> <p>The async Team Members API</p> <p>Retrieve information on existing team members of your organisation and invite new members.</p> <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> Source code in <code>pyrevolut/api/team_members/endpoint/asynchronous.py</code> <pre><code>class EndpointTeamMembersAsync(BaseEndpointAsync):\n    \"\"\"The async Team Members API\n\n    Retrieve information on existing team members of your organisation and invite new members.\n\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n    \"\"\"\n\n    async def get_team_members(\n        self,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        limit: int | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfTeamMembers.Response]:\n        \"\"\"\n        Get information about all the team members of your business.\n\n        The results are paginated and sorted by the created_at date in reverse chronological order.\n\n        Note\n        ----\n        This feature is available in the UK, US and the EEA.\n\n        This feature is not available in Sandbox.\n\n        Parameters\n        ----------\n        created_before : datetime | DateTime | str | int | float | None\n            Retrieves team members with created_at &lt; created_before.\n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n        limit : int | None\n            The maximum number of team members returned per page.\n            To get to the next page, make a new request and use the\n            created_at date of the last team member returned in the previous\n            response as the value for created_before.\n\n            If not provided, the default value is 100.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfTeamMembers.Response]\n            The list of all team members in your organisation.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = RetrieveListOfTeamMembers\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            created_before=created_before,\n            limit=limit,\n        )\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def get_team_roles(\n        self,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        limit: int | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveTeamRoles.Response]:\n        \"\"\"\n        Get the list of roles for your business.\n\n        The results are paginated and sorted by the created_at date in reverse chronological order.\n\n        This feature is available in the UK, US and the EEA.\n\n        This feature is not available in Sandbox.\n\n        Parameters\n        ----------\n        created_before : datetime | DateTime | str | int | float | None\n            Retrieves team roles with created_at &lt; created_before.\n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n        limit : int | None\n            The maximum number of team roles returned per page.\n            To get to the next page, make a new request and use the\n            created_at date of the last role returned in the previous\n            response as the value for created_before.\n\n            If not provided, the default value is 100.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveTeamRoles.Response]\n            The list of all team roles in your organisation.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = RetrieveTeamRoles\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            created_before=created_before,\n            limit=limit,\n        )\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def invite_team_member(\n        self,\n        email: str,\n        role_id: UUID | str,\n        **kwargs,\n    ) -&gt; dict | InviteTeamMember.Response:\n        \"\"\"\n        Invite a new member to your business account.\n\n        When you invite a new team member to your business account,\n        an invitation is sent to their email address that you provided in this request.\n        To join your business account, the new team member has to accept this invitation.\n\n        Note\n        ----\n        This feature is available in the UK, US and the EEA.\n\n        This feature is not available in Sandbox.\n\n        Parameters\n        ----------\n        email : str\n            The email address of the invited member.\n        role_id : UUID | str\n            The ID of the role to assign to the new member.\n\n        Returns\n        -------\n        dict | InviteTeamMember.Response\n            The response model.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = InviteTeamMember\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            email=email,\n            role_id=role_id,\n        )\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def __check_sandbox(self):\n        \"\"\"\n        Check if the sandbox is enabled.\n\n        Raises\n        ------\n        PyRevolutInvalidEnvironment\n            If the sandbox is enabled.\n        \"\"\"\n        if self.client.sandbox:\n            raise PyRevolutInvalidEnvironment(\n                \"This feature is not available in Sandbox.\"\n            )\n</code></pre>"},{"location":"code_reference/api/team_members/asynchronous/#pyrevolut.api.team_members.endpoint.EndpointTeamMembersAsync.__check_sandbox","title":"<code>__check_sandbox()</code>","text":"<p>Check if the sandbox is enabled.</p> <p>Raises:</p> Type Description <code>PyRevolutInvalidEnvironment</code> <p>If the sandbox is enabled.</p> Source code in <code>pyrevolut/api/team_members/endpoint/asynchronous.py</code> <pre><code>def __check_sandbox(self):\n    \"\"\"\n    Check if the sandbox is enabled.\n\n    Raises\n    ------\n    PyRevolutInvalidEnvironment\n        If the sandbox is enabled.\n    \"\"\"\n    if self.client.sandbox:\n        raise PyRevolutInvalidEnvironment(\n            \"This feature is not available in Sandbox.\"\n        )\n</code></pre>"},{"location":"code_reference/api/team_members/asynchronous/#pyrevolut.api.team_members.endpoint.EndpointTeamMembersAsync.get_team_members","title":"<code>get_team_members(created_before=None, limit=None, **kwargs)</code>  <code>async</code>","text":"<p>Get information about all the team members of your business.</p> <p>The results are paginated and sorted by the created_at date in reverse chronological order.</p> Note <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> <p>Parameters:</p> Name Type Description Default <code>created_before</code> <code>datetime | DateTime | str | int | float | None</code> <p>Retrieves team members with created_at &lt; created_before. The default value is the current date and time at which you are calling the endpoint. Provided in ISO 8601 format.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>The maximum number of team members returned per page. To get to the next page, make a new request and use the created_at date of the last team member returned in the previous response as the value for created_before.</p> <p>If not provided, the default value is 100.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all team members in your organisation.</p> Source code in <code>pyrevolut/api/team_members/endpoint/asynchronous.py</code> <pre><code>async def get_team_members(\n    self,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    limit: int | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfTeamMembers.Response]:\n    \"\"\"\n    Get information about all the team members of your business.\n\n    The results are paginated and sorted by the created_at date in reverse chronological order.\n\n    Note\n    ----\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n\n    Parameters\n    ----------\n    created_before : datetime | DateTime | str | int | float | None\n        Retrieves team members with created_at &lt; created_before.\n        The default value is the current date and time at which you are calling the endpoint.\n        Provided in ISO 8601 format.\n    limit : int | None\n        The maximum number of team members returned per page.\n        To get to the next page, make a new request and use the\n        created_at date of the last team member returned in the previous\n        response as the value for created_before.\n\n        If not provided, the default value is 100.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfTeamMembers.Response]\n        The list of all team members in your organisation.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = RetrieveListOfTeamMembers\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        created_before=created_before,\n        limit=limit,\n    )\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/team_members/asynchronous/#pyrevolut.api.team_members.endpoint.EndpointTeamMembersAsync.get_team_roles","title":"<code>get_team_roles(created_before=None, limit=None, **kwargs)</code>  <code>async</code>","text":"<p>Get the list of roles for your business.</p> <p>The results are paginated and sorted by the created_at date in reverse chronological order.</p> <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> <p>Parameters:</p> Name Type Description Default <code>created_before</code> <code>datetime | DateTime | str | int | float | None</code> <p>Retrieves team roles with created_at &lt; created_before. The default value is the current date and time at which you are calling the endpoint. Provided in ISO 8601 format.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>The maximum number of team roles returned per page. To get to the next page, make a new request and use the created_at date of the last role returned in the previous response as the value for created_before.</p> <p>If not provided, the default value is 100.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all team roles in your organisation.</p> Source code in <code>pyrevolut/api/team_members/endpoint/asynchronous.py</code> <pre><code>async def get_team_roles(\n    self,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    limit: int | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveTeamRoles.Response]:\n    \"\"\"\n    Get the list of roles for your business.\n\n    The results are paginated and sorted by the created_at date in reverse chronological order.\n\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n\n    Parameters\n    ----------\n    created_before : datetime | DateTime | str | int | float | None\n        Retrieves team roles with created_at &lt; created_before.\n        The default value is the current date and time at which you are calling the endpoint.\n        Provided in ISO 8601 format.\n    limit : int | None\n        The maximum number of team roles returned per page.\n        To get to the next page, make a new request and use the\n        created_at date of the last role returned in the previous\n        response as the value for created_before.\n\n        If not provided, the default value is 100.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveTeamRoles.Response]\n        The list of all team roles in your organisation.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = RetrieveTeamRoles\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        created_before=created_before,\n        limit=limit,\n    )\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/team_members/asynchronous/#pyrevolut.api.team_members.endpoint.EndpointTeamMembersAsync.invite_team_member","title":"<code>invite_team_member(email, role_id, **kwargs)</code>  <code>async</code>","text":"<p>Invite a new member to your business account.</p> <p>When you invite a new team member to your business account, an invitation is sent to their email address that you provided in this request. To join your business account, the new team member has to accept this invitation.</p> Note <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The email address of the invited member.</p> required <code>role_id</code> <code>UUID | str</code> <p>The ID of the role to assign to the new member.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The response model.</p> Source code in <code>pyrevolut/api/team_members/endpoint/asynchronous.py</code> <pre><code>async def invite_team_member(\n    self,\n    email: str,\n    role_id: UUID | str,\n    **kwargs,\n) -&gt; dict | InviteTeamMember.Response:\n    \"\"\"\n    Invite a new member to your business account.\n\n    When you invite a new team member to your business account,\n    an invitation is sent to their email address that you provided in this request.\n    To join your business account, the new team member has to accept this invitation.\n\n    Note\n    ----\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n\n    Parameters\n    ----------\n    email : str\n        The email address of the invited member.\n    role_id : UUID | str\n        The ID of the role to assign to the new member.\n\n    Returns\n    -------\n    dict | InviteTeamMember.Response\n        The response model.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = InviteTeamMember\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        email=email,\n        role_id=role_id,\n    )\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/team_members/pydantic/","title":"Team Members Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Team Members</code> endpoint.</p>"},{"location":"code_reference/api/team_members/pydantic/#pyrevolut.api.team_members.get.RetrieveListOfTeamMembers","title":"<code>RetrieveListOfTeamMembers</code>","text":"<p>Get information about all the team members of your business.</p> <p>The results are paginated and sorted by the created_at date in reverse chronological order.</p> Note <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> Source code in <code>pyrevolut/api/team_members/get/retrieve_list_of_team_members.py</code> <pre><code>class RetrieveListOfTeamMembers:\n    \"\"\"\n    Get information about all the team members of your business.\n\n    The results are paginated and sorted by the created_at date in reverse chronological order.\n\n    Note\n    ----\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n    \"\"\"\n\n    ROUTE = \"/1.0/team-members\"\n\n    class Params(BaseModel):\n        \"\"\"The parameters of the request.\"\"\"\n\n        created_before: Annotated[\n            DateTime | None,\n            Field(\n                description=\"\"\"\n                Retrieves team members with created_at &lt; created_before. \n                The default value is the current date and time at which you are calling the endpoint.\n                Provided in ISO 8601 format.\n                \"\"\"\n            ),\n        ] = None\n        limit: Annotated[\n            int | None,\n            Field(\n                description=\"\"\"\n                The maximum number of team members returned per page.\n                To get to the next page, make a new request and use the \n                created_at date of the last team member returned in the previous \n                response as the value for created_before.              \n\n                If not provided, the default value is 100.  \n                \"\"\",\n                ge=1,\n                le=100,\n            ),\n        ] = None\n\n    class Response(BaseModel):\n        \"\"\"The response model.\"\"\"\n\n        id: Annotated[UUID, Field(description=\"The ID of the team member.\")]\n        email: Annotated[\n            EmailStr, Field(description=\"The email address of the team member.\")\n        ]\n        first_name: Annotated[\n            str | None, Field(description=\"The team member's first name.\")\n        ] = None\n        last_name: Annotated[\n            str | None, Field(description=\"The team member's last name.\")\n        ] = None\n        state: Annotated[\n            EnumTeamMemberState,\n            Field(description=\"The state that the team member is in.\"),\n        ]\n        role_id: Annotated[\n            UUID | str,\n            Field(\n                description=\"The ID of the team member's role. This can be a UUID or other default role such as Owner.\"\n            ),\n        ]\n        created_at: Annotated[\n            DateTime,\n            Field(\n                description=\"The date and time the team member was created in ISO 8601 format.\"\n            ),\n        ]\n        updated_at: Annotated[\n            DateTime,\n            Field(\n                description=\"The date and time the team member was last updated in ISO 8601 format.\"\n            ),\n        ]\n</code></pre>"},{"location":"code_reference/api/team_members/pydantic/#pyrevolut.api.team_members.get.RetrieveListOfTeamMembers.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The parameters of the request.</p> Source code in <code>pyrevolut/api/team_members/get/retrieve_list_of_team_members.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"The parameters of the request.\"\"\"\n\n    created_before: Annotated[\n        DateTime | None,\n        Field(\n            description=\"\"\"\n            Retrieves team members with created_at &lt; created_before. \n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n            \"\"\"\n        ),\n    ] = None\n    limit: Annotated[\n        int | None,\n        Field(\n            description=\"\"\"\n            The maximum number of team members returned per page.\n            To get to the next page, make a new request and use the \n            created_at date of the last team member returned in the previous \n            response as the value for created_before.              \n\n            If not provided, the default value is 100.  \n            \"\"\",\n            ge=1,\n            le=100,\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/team_members/pydantic/#pyrevolut.api.team_members.get.RetrieveListOfTeamMembers.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model.</p> Source code in <code>pyrevolut/api/team_members/get/retrieve_list_of_team_members.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"The response model.\"\"\"\n\n    id: Annotated[UUID, Field(description=\"The ID of the team member.\")]\n    email: Annotated[\n        EmailStr, Field(description=\"The email address of the team member.\")\n    ]\n    first_name: Annotated[\n        str | None, Field(description=\"The team member's first name.\")\n    ] = None\n    last_name: Annotated[\n        str | None, Field(description=\"The team member's last name.\")\n    ] = None\n    state: Annotated[\n        EnumTeamMemberState,\n        Field(description=\"The state that the team member is in.\"),\n    ]\n    role_id: Annotated[\n        UUID | str,\n        Field(\n            description=\"The ID of the team member's role. This can be a UUID or other default role such as Owner.\"\n        ),\n    ]\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the team member was created in ISO 8601 format.\"\n        ),\n    ]\n    updated_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the team member was last updated in ISO 8601 format.\"\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/team_members/pydantic/#pyrevolut.api.team_members.get.RetrieveTeamRoles","title":"<code>RetrieveTeamRoles</code>","text":"<p>Get the list of roles for your business.</p> <p>The results are paginated and sorted by the created_at date in reverse chronological order.</p> <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> Source code in <code>pyrevolut/api/team_members/get/retrieve_team_roles.py</code> <pre><code>class RetrieveTeamRoles:\n    \"\"\"\n    Get the list of roles for your business.\n\n    The results are paginated and sorted by the created_at date in reverse chronological order.\n\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n    \"\"\"\n\n    ROUTE = \"/1.0/roles\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The query parameters of the request.\n        \"\"\"\n\n        created_before: Annotated[\n            DateTime | None,\n            Field(\n                description=\"\"\"\n                Retrieves roles with created_at &lt; created_before. \n                The default value is the current date and time at which you are calling the endpoint.\n                Provided in ISO 8601 format.\n                \"\"\"\n            ),\n        ] = None\n        limit: Annotated[\n            int | None,\n            Field(\n                description=\"\"\"\n                The maximum number of roles returned per page.\n                To get to the next page, make a new request and use the \n                created_at date of the last role returned in the previous \n                response as the value for created_before.              \n\n                If not provided, the default value is 100.  \n                \"\"\",\n                ge=1,\n                le=100,\n            ),\n        ] = None\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model.\n        \"\"\"\n\n        id: Annotated[\n            UUID | str,\n            Field(\n                description=\"The ID of the role. This can be a UUID or other default role such as OWNER.\"\n            ),\n        ]\n        name: Annotated[str, Field(description=\"The name of the role.\")]\n        created_at: Annotated[\n            DateTime,\n            Field(\n                description=\"The date and time the role was created in ISO 8601 format.\"\n            ),\n        ]\n        updated_at: Annotated[\n            DateTime,\n            Field(\n                description=\"The date and time the role was last updated in ISO 8601 format.\"\n            ),\n        ]\n</code></pre>"},{"location":"code_reference/api/team_members/pydantic/#pyrevolut.api.team_members.get.RetrieveTeamRoles.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The query parameters of the request.</p> Source code in <code>pyrevolut/api/team_members/get/retrieve_team_roles.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The query parameters of the request.\n    \"\"\"\n\n    created_before: Annotated[\n        DateTime | None,\n        Field(\n            description=\"\"\"\n            Retrieves roles with created_at &lt; created_before. \n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n            \"\"\"\n        ),\n    ] = None\n    limit: Annotated[\n        int | None,\n        Field(\n            description=\"\"\"\n            The maximum number of roles returned per page.\n            To get to the next page, make a new request and use the \n            created_at date of the last role returned in the previous \n            response as the value for created_before.              \n\n            If not provided, the default value is 100.  \n            \"\"\",\n            ge=1,\n            le=100,\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/team_members/pydantic/#pyrevolut.api.team_members.get.RetrieveTeamRoles.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model.</p> Source code in <code>pyrevolut/api/team_members/get/retrieve_team_roles.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model.\n    \"\"\"\n\n    id: Annotated[\n        UUID | str,\n        Field(\n            description=\"The ID of the role. This can be a UUID or other default role such as OWNER.\"\n        ),\n    ]\n    name: Annotated[str, Field(description=\"The name of the role.\")]\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the role was created in ISO 8601 format.\"\n        ),\n    ]\n    updated_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the role was last updated in ISO 8601 format.\"\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/team_members/pydantic/#pyrevolut.api.team_members.post.InviteTeamMember","title":"<code>InviteTeamMember</code>","text":"<p>Invite a new member to your business account.</p> <p>When you invite a new team member to your business account, an invitation is sent to their email address that you provided in this request. To join your business account, the new team member has to accept this invitation.</p> Note <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> Source code in <code>pyrevolut/api/team_members/post/invite_team_member.py</code> <pre><code>class InviteTeamMember:\n    \"\"\"\n    Invite a new member to your business account.\n\n    When you invite a new team member to your business account,\n    an invitation is sent to their email address that you provided in this request.\n    To join your business account, the new team member has to accept this invitation.\n\n    Note\n    ----\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n    \"\"\"\n\n    ROUTE = \"/1.0/team-members\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The body of the request.\n        \"\"\"\n\n        email: Annotated[\n            EmailStr, Field(description=\"The email address of the invited member.\")\n        ]\n        role_id: Annotated[\n            UUID | str,\n            Field(description=\"The ID of the role to assign to the new member.\"),\n        ]\n\n    class Response(BaseModel):\n        \"\"\"The response model.\"\"\"\n\n        email: Annotated[\n            EmailStr, Field(description=\"The email address of the invited member.\")\n        ]\n        id: Annotated[UUID, Field(description=\"The ID of the invited member.\")]\n        role_id: Annotated[\n            UUID | str,\n            Field(description=\"The ID of the role assigned to the member.\"),\n        ]\n        created_at: Annotated[\n            DateTime,\n            Field(description=\"The date and time when the member was created.\"),\n        ]\n        updated_at: Annotated[\n            DateTime,\n            Field(description=\"The date and time when the member was last updated.\"),\n        ]\n</code></pre>"},{"location":"code_reference/api/team_members/pydantic/#pyrevolut.api.team_members.post.InviteTeamMember.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The body of the request.</p> Source code in <code>pyrevolut/api/team_members/post/invite_team_member.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The body of the request.\n    \"\"\"\n\n    email: Annotated[\n        EmailStr, Field(description=\"The email address of the invited member.\")\n    ]\n    role_id: Annotated[\n        UUID | str,\n        Field(description=\"The ID of the role to assign to the new member.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/team_members/pydantic/#pyrevolut.api.team_members.post.InviteTeamMember.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model.</p> Source code in <code>pyrevolut/api/team_members/post/invite_team_member.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"The response model.\"\"\"\n\n    email: Annotated[\n        EmailStr, Field(description=\"The email address of the invited member.\")\n    ]\n    id: Annotated[UUID, Field(description=\"The ID of the invited member.\")]\n    role_id: Annotated[\n        UUID | str,\n        Field(description=\"The ID of the role assigned to the member.\"),\n    ]\n    created_at: Annotated[\n        DateTime,\n        Field(description=\"The date and time when the member was created.\"),\n    ]\n    updated_at: Annotated[\n        DateTime,\n        Field(description=\"The date and time when the member was last updated.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/team_members/synchronous/","title":"Team Members Synchronous Endpoints","text":"<p>This <code>Team Members</code> endpoint provides methods to interact with the team members of the authenticated user.</p> <p>Example usage of the Team Members endpoint object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    members = client.TeamMembers.get_team_members()\n    print(members)\n</code></pre>"},{"location":"code_reference/api/team_members/synchronous/#pyrevolut.api.team_members.endpoint.EndpointTeamMembersSync","title":"<code>EndpointTeamMembersSync</code>","text":"<p>               Bases: <code>BaseEndpointSync</code></p> <p>The Team Members API</p> <p>Retrieve information on existing team members of your organisation and invite new members.</p> <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> Source code in <code>pyrevolut/api/team_members/endpoint/synchronous.py</code> <pre><code>class EndpointTeamMembersSync(BaseEndpointSync):\n    \"\"\"The Team Members API\n\n    Retrieve information on existing team members of your organisation and invite new members.\n\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n    \"\"\"\n\n    def get_team_members(\n        self,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        limit: int | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfTeamMembers.Response]:\n        \"\"\"\n        Get information about all the team members of your business.\n\n        The results are paginated and sorted by the created_at date in reverse chronological order.\n\n        Note\n        ----\n        This feature is available in the UK, US and the EEA.\n\n        This feature is not available in Sandbox.\n\n        Parameters\n        ----------\n        created_before : datetime | DateTime | str | int | float | None\n            Retrieves team members with created_at &lt; created_before.\n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n        limit : int | None\n            The maximum number of team members returned per page.\n            To get to the next page, make a new request and use the\n            created_at date of the last team member returned in the previous\n            response as the value for created_before.\n\n            If not provided, the default value is 100.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfTeamMembers.Response]\n            The list of all team members in your organisation.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = RetrieveListOfTeamMembers\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            created_before=created_before,\n            limit=limit,\n        )\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_team_roles(\n        self,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        limit: int | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveTeamRoles.Response]:\n        \"\"\"\n        Get the list of roles for your business.\n\n        The results are paginated and sorted by the created_at date in reverse chronological order.\n\n        This feature is available in the UK, US and the EEA.\n\n        This feature is not available in Sandbox.\n\n        Parameters\n        ----------\n        created_before : datetime | DateTime | str | int | float | None\n            Retrieves team roles with created_at &lt; created_before.\n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n        limit : int | None\n            The maximum number of team roles returned per page.\n            To get to the next page, make a new request and use the\n            created_at date of the last role returned in the previous\n            response as the value for created_before.\n\n            If not provided, the default value is 100.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveTeamRoles.Response]\n            The list of all team roles in your organisation.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = RetrieveTeamRoles\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            created_before=created_before,\n            limit=limit,\n        )\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def invite_team_member(\n        self,\n        email: str,\n        role_id: UUID | str,\n        **kwargs,\n    ) -&gt; dict | InviteTeamMember.Response:\n        \"\"\"\n        Invite a new member to your business account.\n\n        When you invite a new team member to your business account,\n        an invitation is sent to their email address that you provided in this request.\n        To join your business account, the new team member has to accept this invitation.\n\n        Note\n        ----\n        This feature is available in the UK, US and the EEA.\n\n        This feature is not available in Sandbox.\n\n        Parameters\n        ----------\n        email : str\n            The email address of the invited member.\n        role_id : UUID | str\n            The ID of the role to assign to the new member.\n\n        Returns\n        -------\n        dict | InviteTeamMember.Response\n            The response model.\n        \"\"\"\n        self.__check_sandbox()\n        endpoint = InviteTeamMember\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            email=email,\n            role_id=role_id,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def __check_sandbox(self):\n        \"\"\"\n        Check if the sandbox is enabled.\n\n        Raises\n        ------\n        PyRevolutInvalidEnvironment\n            If the sandbox is enabled.\n        \"\"\"\n        if self.client.sandbox:\n            raise PyRevolutInvalidEnvironment(\n                \"This feature is not available in Sandbox.\"\n            )\n</code></pre>"},{"location":"code_reference/api/team_members/synchronous/#pyrevolut.api.team_members.endpoint.EndpointTeamMembersSync.__check_sandbox","title":"<code>__check_sandbox()</code>","text":"<p>Check if the sandbox is enabled.</p> <p>Raises:</p> Type Description <code>PyRevolutInvalidEnvironment</code> <p>If the sandbox is enabled.</p> Source code in <code>pyrevolut/api/team_members/endpoint/synchronous.py</code> <pre><code>def __check_sandbox(self):\n    \"\"\"\n    Check if the sandbox is enabled.\n\n    Raises\n    ------\n    PyRevolutInvalidEnvironment\n        If the sandbox is enabled.\n    \"\"\"\n    if self.client.sandbox:\n        raise PyRevolutInvalidEnvironment(\n            \"This feature is not available in Sandbox.\"\n        )\n</code></pre>"},{"location":"code_reference/api/team_members/synchronous/#pyrevolut.api.team_members.endpoint.EndpointTeamMembersSync.get_team_members","title":"<code>get_team_members(created_before=None, limit=None, **kwargs)</code>","text":"<p>Get information about all the team members of your business.</p> <p>The results are paginated and sorted by the created_at date in reverse chronological order.</p> Note <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> <p>Parameters:</p> Name Type Description Default <code>created_before</code> <code>datetime | DateTime | str | int | float | None</code> <p>Retrieves team members with created_at &lt; created_before. The default value is the current date and time at which you are calling the endpoint. Provided in ISO 8601 format.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>The maximum number of team members returned per page. To get to the next page, make a new request and use the created_at date of the last team member returned in the previous response as the value for created_before.</p> <p>If not provided, the default value is 100.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all team members in your organisation.</p> Source code in <code>pyrevolut/api/team_members/endpoint/synchronous.py</code> <pre><code>def get_team_members(\n    self,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    limit: int | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfTeamMembers.Response]:\n    \"\"\"\n    Get information about all the team members of your business.\n\n    The results are paginated and sorted by the created_at date in reverse chronological order.\n\n    Note\n    ----\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n\n    Parameters\n    ----------\n    created_before : datetime | DateTime | str | int | float | None\n        Retrieves team members with created_at &lt; created_before.\n        The default value is the current date and time at which you are calling the endpoint.\n        Provided in ISO 8601 format.\n    limit : int | None\n        The maximum number of team members returned per page.\n        To get to the next page, make a new request and use the\n        created_at date of the last team member returned in the previous\n        response as the value for created_before.\n\n        If not provided, the default value is 100.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfTeamMembers.Response]\n        The list of all team members in your organisation.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = RetrieveListOfTeamMembers\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        created_before=created_before,\n        limit=limit,\n    )\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/team_members/synchronous/#pyrevolut.api.team_members.endpoint.EndpointTeamMembersSync.get_team_roles","title":"<code>get_team_roles(created_before=None, limit=None, **kwargs)</code>","text":"<p>Get the list of roles for your business.</p> <p>The results are paginated and sorted by the created_at date in reverse chronological order.</p> <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> <p>Parameters:</p> Name Type Description Default <code>created_before</code> <code>datetime | DateTime | str | int | float | None</code> <p>Retrieves team roles with created_at &lt; created_before. The default value is the current date and time at which you are calling the endpoint. Provided in ISO 8601 format.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>The maximum number of team roles returned per page. To get to the next page, make a new request and use the created_at date of the last role returned in the previous response as the value for created_before.</p> <p>If not provided, the default value is 100.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all team roles in your organisation.</p> Source code in <code>pyrevolut/api/team_members/endpoint/synchronous.py</code> <pre><code>def get_team_roles(\n    self,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    limit: int | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveTeamRoles.Response]:\n    \"\"\"\n    Get the list of roles for your business.\n\n    The results are paginated and sorted by the created_at date in reverse chronological order.\n\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n\n    Parameters\n    ----------\n    created_before : datetime | DateTime | str | int | float | None\n        Retrieves team roles with created_at &lt; created_before.\n        The default value is the current date and time at which you are calling the endpoint.\n        Provided in ISO 8601 format.\n    limit : int | None\n        The maximum number of team roles returned per page.\n        To get to the next page, make a new request and use the\n        created_at date of the last role returned in the previous\n        response as the value for created_before.\n\n        If not provided, the default value is 100.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveTeamRoles.Response]\n        The list of all team roles in your organisation.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = RetrieveTeamRoles\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        created_before=created_before,\n        limit=limit,\n    )\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/team_members/synchronous/#pyrevolut.api.team_members.endpoint.EndpointTeamMembersSync.invite_team_member","title":"<code>invite_team_member(email, role_id, **kwargs)</code>","text":"<p>Invite a new member to your business account.</p> <p>When you invite a new team member to your business account, an invitation is sent to their email address that you provided in this request. To join your business account, the new team member has to accept this invitation.</p> Note <p>This feature is available in the UK, US and the EEA.</p> <p>This feature is not available in Sandbox.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The email address of the invited member.</p> required <code>role_id</code> <code>UUID | str</code> <p>The ID of the role to assign to the new member.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The response model.</p> Source code in <code>pyrevolut/api/team_members/endpoint/synchronous.py</code> <pre><code>def invite_team_member(\n    self,\n    email: str,\n    role_id: UUID | str,\n    **kwargs,\n) -&gt; dict | InviteTeamMember.Response:\n    \"\"\"\n    Invite a new member to your business account.\n\n    When you invite a new team member to your business account,\n    an invitation is sent to their email address that you provided in this request.\n    To join your business account, the new team member has to accept this invitation.\n\n    Note\n    ----\n    This feature is available in the UK, US and the EEA.\n\n    This feature is not available in Sandbox.\n\n    Parameters\n    ----------\n    email : str\n        The email address of the invited member.\n    role_id : UUID | str\n        The ID of the role to assign to the new member.\n\n    Returns\n    -------\n    dict | InviteTeamMember.Response\n        The response model.\n    \"\"\"\n    self.__check_sandbox()\n    endpoint = InviteTeamMember\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        email=email,\n        role_id=role_id,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/transactions/asynchronous/","title":"Transactions Asynchronous Endpoints","text":"<p>This <code>Transactions</code> endpoint provides asynchronous methods to interact with the transactions of the authenticated user.</p> <p>Example usage of the Transactions endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        transactions = await client.Transactions.get_all_transactions()\n        print(transactions)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/transactions/asynchronous/#pyrevolut.api.transactions.endpoint.EndpointTransactionsAsync","title":"<code>EndpointTransactionsAsync</code>","text":"<p>               Bases: <code>BaseEndpointAsync</code></p> <p>The async Transactions API</p> <p>Get the details of your transactions.</p> Note <p>An incoming or outgoing payment is represented as a transaction.</p> Source code in <code>pyrevolut/api/transactions/endpoint/asynchronous.py</code> <pre><code>class EndpointTransactionsAsync(BaseEndpointAsync):\n    \"\"\"The async Transactions API\n\n    Get the details of your transactions.\n\n    Note\n    ----\n    An incoming or outgoing payment is represented as a transaction.\n    \"\"\"\n\n    async def get_all_transactions(\n        self,\n        from_datetime: datetime | DateTime | str | int | float | None = None,\n        to_datetime: datetime | DateTime | str | int | float | None = None,\n        account_id: UUID | None = None,\n        limit: int | None = None,\n        transaction_type: EnumTransactionType | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfTransactions.Response]:\n        \"\"\"\n        Retrieve the historical transactions based on the provided query criteria.\n\n        The transactions are sorted by the created_at date in reverse chronological order,\n        and they're paginated. The maximum number of transactions returned per page is specified by the\n        count parameter. To get the next page of results, make a new request and use the created_at date\n        from the last item of the previous page as the value for the to parameter.\n\n        Note\n        ----\n        The API returns a maximum of 1,000 transactions per request.\n\n        Note\n        ----\n        To be compliant with PSD2 SCA regulations, businesses on the Revolut Business Freelancer\n        plans can only access information older than 90 days within 5 minutes of the first authorisation.\n\n        Parameters\n        ----------\n        from_datetime : datetime | DateTime | str | int | float, optional\n            The date and time you retrieve the historical transactions from, including\n            this date-time.\n            Corresponds to the created_at value of the transaction.\n            Provided in ISO 8601 format.\n\n            Used also for pagination. To get back to the previous page of results,\n            make a new request and use the created_at date from the first item of the\n            current page as the value for the from parameter.\n        to_datetime : datetime | DateTime | str | int | float, optional\n            The date and time you retrieve the historical transactions to, excluding\n            this date-time.\n            Corresponds to the created_at value of the transaction.\n            Provided in ISO 8601 format.\n            The default value is the date and time at which you're calling the endpoint.\n\n            Used also for pagination.\n            To get the next page of results, make a new request and use the created_at\n            date from the last item of the previous (current) page as the value for the\n            to parameter.\n        account_id : UUID, optional\n            The ID of the account for which you want to retrieve the transactions.\n        limit : int, optional\n            The maximum number of transactions returned per page.\n            To get the next page of results, make a new request and use the created_at\n            date from the last item of the previous page as the value for the to parameter.\n        transaction_type : EnumTransactionType, optional\n            The type of the transaction.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfTransactions.Response]\n            A list of transactions.\n        \"\"\"\n        endpoint = RetrieveListOfTransactions\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            from_=from_datetime,\n            to=to_datetime,\n            account=account_id,\n            count=limit,\n            type=transaction_type,\n        )\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def get_transaction(\n        self,\n        transaction_id: UUID | None = None,\n        request_id: str | None = None,\n        **kwargs,\n    ) -&gt; dict | RetrieveTransaction.Response:\n        \"\"\"\n        Retrieve the details of a specific transaction.\n        The details can include, for example, cardholder details for card payments.\n\n        You can retrieve a transaction with its details either by its transaction ID\n        or by the request ID that was provided for this transaction at the time of its\n        creation, for example, when you created a payment.\n\n        To retrieve a transaction by its transaction ID, use:\n\n            /transaction/{transaction_id}\n\n        To retrieve a transaction by a request ID provided at transaction creation, use:\n\n            /transaction/{request_id}?id_type=request_id\n\n        Parameters\n        ----------\n        transaction_id : UUID, optional\n            The ID of the transaction.\n            Specify either transaction_id or request_id.\n        request_id : str, optional\n            The request ID of the transaction.\n            Specify either transaction_id or request_id.\n\n        Returns\n        -------\n        dict | RetrieveTransaction.Response\n            The details of the transaction.\n        \"\"\"\n        assert (\n            transaction_id or request_id\n        ), \"Either transaction_id or request_id must be provided.\"\n        assert not (\n            transaction_id and request_id\n        ), \"Either transaction_id or request_id must be provided, not both.\"\n\n        endpoint = RetrieveTransaction\n        path = endpoint.ROUTE.format(id=transaction_id or request_id)\n        params = endpoint.Params(id_type=\"request_id\" if request_id else None)\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/transactions/asynchronous/#pyrevolut.api.transactions.endpoint.EndpointTransactionsAsync.get_all_transactions","title":"<code>get_all_transactions(from_datetime=None, to_datetime=None, account_id=None, limit=None, transaction_type=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the historical transactions based on the provided query criteria.</p> <p>The transactions are sorted by the created_at date in reverse chronological order, and they're paginated. The maximum number of transactions returned per page is specified by the count parameter. To get the next page of results, make a new request and use the created_at date from the last item of the previous page as the value for the to parameter.</p> Note <p>The API returns a maximum of 1,000 transactions per request.</p> Note <p>To be compliant with PSD2 SCA regulations, businesses on the Revolut Business Freelancer plans can only access information older than 90 days within 5 minutes of the first authorisation.</p> <p>Parameters:</p> Name Type Description Default <code>from_datetime</code> <code>datetime | DateTime | str | int | float</code> <p>The date and time you retrieve the historical transactions from, including this date-time. Corresponds to the created_at value of the transaction. Provided in ISO 8601 format.</p> <p>Used also for pagination. To get back to the previous page of results, make a new request and use the created_at date from the first item of the current page as the value for the from parameter.</p> <code>None</code> <code>to_datetime</code> <code>datetime | DateTime | str | int | float</code> <p>The date and time you retrieve the historical transactions to, excluding this date-time. Corresponds to the created_at value of the transaction. Provided in ISO 8601 format. The default value is the date and time at which you're calling the endpoint.</p> <p>Used also for pagination. To get the next page of results, make a new request and use the created_at date from the last item of the previous (current) page as the value for the to parameter.</p> <code>None</code> <code>account_id</code> <code>UUID</code> <p>The ID of the account for which you want to retrieve the transactions.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of transactions returned per page. To get the next page of results, make a new request and use the created_at date from the last item of the previous page as the value for the to parameter.</p> <code>None</code> <code>transaction_type</code> <code>EnumTransactionType</code> <p>The type of the transaction.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>A list of transactions.</p> Source code in <code>pyrevolut/api/transactions/endpoint/asynchronous.py</code> <pre><code>async def get_all_transactions(\n    self,\n    from_datetime: datetime | DateTime | str | int | float | None = None,\n    to_datetime: datetime | DateTime | str | int | float | None = None,\n    account_id: UUID | None = None,\n    limit: int | None = None,\n    transaction_type: EnumTransactionType | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfTransactions.Response]:\n    \"\"\"\n    Retrieve the historical transactions based on the provided query criteria.\n\n    The transactions are sorted by the created_at date in reverse chronological order,\n    and they're paginated. The maximum number of transactions returned per page is specified by the\n    count parameter. To get the next page of results, make a new request and use the created_at date\n    from the last item of the previous page as the value for the to parameter.\n\n    Note\n    ----\n    The API returns a maximum of 1,000 transactions per request.\n\n    Note\n    ----\n    To be compliant with PSD2 SCA regulations, businesses on the Revolut Business Freelancer\n    plans can only access information older than 90 days within 5 minutes of the first authorisation.\n\n    Parameters\n    ----------\n    from_datetime : datetime | DateTime | str | int | float, optional\n        The date and time you retrieve the historical transactions from, including\n        this date-time.\n        Corresponds to the created_at value of the transaction.\n        Provided in ISO 8601 format.\n\n        Used also for pagination. To get back to the previous page of results,\n        make a new request and use the created_at date from the first item of the\n        current page as the value for the from parameter.\n    to_datetime : datetime | DateTime | str | int | float, optional\n        The date and time you retrieve the historical transactions to, excluding\n        this date-time.\n        Corresponds to the created_at value of the transaction.\n        Provided in ISO 8601 format.\n        The default value is the date and time at which you're calling the endpoint.\n\n        Used also for pagination.\n        To get the next page of results, make a new request and use the created_at\n        date from the last item of the previous (current) page as the value for the\n        to parameter.\n    account_id : UUID, optional\n        The ID of the account for which you want to retrieve the transactions.\n    limit : int, optional\n        The maximum number of transactions returned per page.\n        To get the next page of results, make a new request and use the created_at\n        date from the last item of the previous page as the value for the to parameter.\n    transaction_type : EnumTransactionType, optional\n        The type of the transaction.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfTransactions.Response]\n        A list of transactions.\n    \"\"\"\n    endpoint = RetrieveListOfTransactions\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        from_=from_datetime,\n        to=to_datetime,\n        account=account_id,\n        count=limit,\n        type=transaction_type,\n    )\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/transactions/asynchronous/#pyrevolut.api.transactions.endpoint.EndpointTransactionsAsync.get_transaction","title":"<code>get_transaction(transaction_id=None, request_id=None, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the details of a specific transaction. The details can include, for example, cardholder details for card payments.</p> <p>You can retrieve a transaction with its details either by its transaction ID or by the request ID that was provided for this transaction at the time of its creation, for example, when you created a payment.</p> <p>To retrieve a transaction by its transaction ID, use:</p> <pre><code>/transaction/{transaction_id}\n</code></pre> <p>To retrieve a transaction by a request ID provided at transaction creation, use:</p> <pre><code>/transaction/{request_id}?id_type=request_id\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>transaction_id</code> <code>UUID</code> <p>The ID of the transaction. Specify either transaction_id or request_id.</p> <code>None</code> <code>request_id</code> <code>str</code> <p>The request ID of the transaction. Specify either transaction_id or request_id.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The details of the transaction.</p> Source code in <code>pyrevolut/api/transactions/endpoint/asynchronous.py</code> <pre><code>async def get_transaction(\n    self,\n    transaction_id: UUID | None = None,\n    request_id: str | None = None,\n    **kwargs,\n) -&gt; dict | RetrieveTransaction.Response:\n    \"\"\"\n    Retrieve the details of a specific transaction.\n    The details can include, for example, cardholder details for card payments.\n\n    You can retrieve a transaction with its details either by its transaction ID\n    or by the request ID that was provided for this transaction at the time of its\n    creation, for example, when you created a payment.\n\n    To retrieve a transaction by its transaction ID, use:\n\n        /transaction/{transaction_id}\n\n    To retrieve a transaction by a request ID provided at transaction creation, use:\n\n        /transaction/{request_id}?id_type=request_id\n\n    Parameters\n    ----------\n    transaction_id : UUID, optional\n        The ID of the transaction.\n        Specify either transaction_id or request_id.\n    request_id : str, optional\n        The request ID of the transaction.\n        Specify either transaction_id or request_id.\n\n    Returns\n    -------\n    dict | RetrieveTransaction.Response\n        The details of the transaction.\n    \"\"\"\n    assert (\n        transaction_id or request_id\n    ), \"Either transaction_id or request_id must be provided.\"\n    assert not (\n        transaction_id and request_id\n    ), \"Either transaction_id or request_id must be provided, not both.\"\n\n    endpoint = RetrieveTransaction\n    path = endpoint.ROUTE.format(id=transaction_id or request_id)\n    params = endpoint.Params(id_type=\"request_id\" if request_id else None)\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/","title":"Transactions Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Transactions</code> endpoint.</p>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.resources.ResourceTransaction","title":"<code>ResourceTransaction</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Transaction resource model.</p> Source code in <code>pyrevolut/api/transactions/resources/transaction.py</code> <pre><code>class ResourceTransaction(BaseModel):\n    \"\"\"\n    Transaction resource model.\n    \"\"\"\n\n    class ModelMerchant(BaseModel):\n        \"\"\"The information about the merchant (only for card transfers)\"\"\"\n\n        name: Annotated[str, Field(description=\"The name of the merchant.\")]\n        city: Annotated[str, Field(description=\"The city of the merchant.\")]\n        category_code: Annotated[\n            str, Field(description=\"The category code of the merchant.\")\n        ]\n        country: Annotated[\n            CountryAlpha2 | CountryAlpha3,\n            Field(\n                description=\"The country of the merchant as the 2-letter ISO 3166 code.\"\n            ),\n        ]\n\n    class ModelLeg(BaseModel):\n        \"\"\"\n        The legs of the transaction:\n\n            - For transactions between your Revolut accounts,\n            there can be 2 legs, for example, an internal transfer made out of\n            the GBP account and into the EUR account.\n\n            - For transactions in other cases, there is only 1 leg.\n        \"\"\"\n\n        class ModelCounterparty(BaseModel):\n            \"\"\"The counterparty of the transaction.\"\"\"\n\n            account_id: Annotated[\n                UUID | None,\n                Field(description=\"The ID of the counterparty account.\"),\n            ] = None\n            account_type: Annotated[\n                EnumAccountType,\n                Field(description=\"Indicates the type of the account.\"),\n            ]\n            id: Annotated[\n                UUID | None,\n                Field(description=\"The ID of the counterparty.\"),\n            ] = None\n\n        leg_id: Annotated[UUID, Field(description=\"The ID of the leg.\")]\n        amount: Annotated[\n            float,\n            Field(description=\"The amount of the transaction leg.\"),\n        ]\n        fee: Annotated[\n            float | None,\n            Field(description=\"The amount of the transaction leg fee.\"),\n        ] = None\n        currency: Annotated[\n            Currency,\n            Field(description=\"ISO 4217 currency code in upper case.\"),\n        ]\n        bill_amount: Annotated[\n            float | None,\n            Field(description=\"The billing amount for cross-currency payments.\"),\n        ] = None\n        bill_currency: Annotated[\n            Currency | None,\n            Field(description=\"The billing currency for cross-currency payments.\"),\n        ] = None\n        account_id: Annotated[\n            UUID,\n            Field(\n                description=\"The ID of the account that the transaction leg is associated with.\"\n            ),\n        ]\n        counterparty: Annotated[\n            ModelCounterparty | None,\n            Field(description=\"The counterparty of the transaction leg.\"),\n        ] = None\n        description: Annotated[\n            str | None,\n            Field(description=\"The transaction leg purpose.\"),\n        ] = None\n        balance: Annotated[\n            float | None,\n            Field(\n                description=\"The total balance of the account that the transaction is associated with.\"\n            ),\n        ] = None\n\n    class ModelCard(BaseModel):\n        \"\"\"The card details (only for card transfers).\"\"\"\n\n        card_number: Annotated[\n            str,\n            Field(description=\"The masked card number.\"),\n        ]\n        first_name: Annotated[\n            str | None,\n            Field(description=\"The first name of the cardholder.\"),\n        ] = None\n        last_name: Annotated[\n            str | None,\n            Field(description=\"The last name of the cardholder.\"),\n        ] = None\n        phone: Annotated[\n            PhoneNumber | None,\n            Field(\n                description=\"The phone number of the cardholder in the E.164 format.\"\n            ),\n        ] = None\n\n    id: Annotated[UUID, Field(description=\"The ID of the transaction.\")]\n    type: Annotated[\n        EnumTransactionType, Field(description=\"Indicates the transaction type.\")\n    ]\n    request_id: Annotated[\n        str | None,\n        Field(\n            description=\"The request ID that you provided previously.\",\n        ),\n    ] = None\n    state: Annotated[\n        EnumTransactionState, Field(description=\"Indicates the transaction state.\")\n    ]\n    reason_code: Annotated[\n        str | None,\n        Field(\n            description=\"The reason code when the transaction state is declined or failed.\"\n        ),\n    ] = None\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the transaction was created in ISO 8601 format.\"\n        ),\n    ]\n    updated_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the transaction was last updated in ISO 8601 format.\"\n        ),\n    ]\n    completed_at: Annotated[\n        DateTime | None,\n        Field(\n            description=\"\"\"\n            The date and time the transaction was completed in ISO 8601 format. \n            This is required when the transaction state is completed.\n            \"\"\"\n        ),\n    ] = None\n    scheduled_for: Annotated[\n        Date | None,\n        Field(\n            description=\"\"\"\n            The scheduled date of the payment, if applicable. Provided in ISO 8601 format.\n            \"\"\"\n        ),\n    ] = None\n    related_transaction_id: Annotated[\n        UUID | None,\n        Field(description=\"The ID of the original transaction that has been refunded.\"),\n    ] = None\n    merchant: Annotated[\n        ModelMerchant | None,\n        Field(\n            description=\"The information about the merchant (only for card transfers).\"\n        ),\n    ] = None\n    reference: Annotated[\n        str | None,\n        Field(description=\"The reference of the transaction.\"),\n    ] = None\n    legs: Annotated[\n        list[ModelLeg],\n        Field(\n            description=\"\"\"\n            The legs of the transaction:\n\n            - For transactions between your Revolut accounts,\n            there can be 2 legs, for example, an internal transfer made out of\n            the GBP account and into the EUR account.\n\n            - For transactions in other cases, there is only 1 leg.\n            \"\"\"\n        ),\n    ]\n    card: Annotated[\n        ModelCard | None,\n        Field(description=\"The card details (only for card transfers).\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.resources.ResourceTransaction.ModelCard","title":"<code>ModelCard</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The card details (only for card transfers).</p> Source code in <code>pyrevolut/api/transactions/resources/transaction.py</code> <pre><code>class ModelCard(BaseModel):\n    \"\"\"The card details (only for card transfers).\"\"\"\n\n    card_number: Annotated[\n        str,\n        Field(description=\"The masked card number.\"),\n    ]\n    first_name: Annotated[\n        str | None,\n        Field(description=\"The first name of the cardholder.\"),\n    ] = None\n    last_name: Annotated[\n        str | None,\n        Field(description=\"The last name of the cardholder.\"),\n    ] = None\n    phone: Annotated[\n        PhoneNumber | None,\n        Field(\n            description=\"The phone number of the cardholder in the E.164 format.\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.resources.ResourceTransaction.ModelLeg","title":"<code>ModelLeg</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The legs of the transaction:</p> <pre><code>- For transactions between your Revolut accounts,\nthere can be 2 legs, for example, an internal transfer made out of\nthe GBP account and into the EUR account.\n\n- For transactions in other cases, there is only 1 leg.\n</code></pre> Source code in <code>pyrevolut/api/transactions/resources/transaction.py</code> <pre><code>class ModelLeg(BaseModel):\n    \"\"\"\n    The legs of the transaction:\n\n        - For transactions between your Revolut accounts,\n        there can be 2 legs, for example, an internal transfer made out of\n        the GBP account and into the EUR account.\n\n        - For transactions in other cases, there is only 1 leg.\n    \"\"\"\n\n    class ModelCounterparty(BaseModel):\n        \"\"\"The counterparty of the transaction.\"\"\"\n\n        account_id: Annotated[\n            UUID | None,\n            Field(description=\"The ID of the counterparty account.\"),\n        ] = None\n        account_type: Annotated[\n            EnumAccountType,\n            Field(description=\"Indicates the type of the account.\"),\n        ]\n        id: Annotated[\n            UUID | None,\n            Field(description=\"The ID of the counterparty.\"),\n        ] = None\n\n    leg_id: Annotated[UUID, Field(description=\"The ID of the leg.\")]\n    amount: Annotated[\n        float,\n        Field(description=\"The amount of the transaction leg.\"),\n    ]\n    fee: Annotated[\n        float | None,\n        Field(description=\"The amount of the transaction leg fee.\"),\n    ] = None\n    currency: Annotated[\n        Currency,\n        Field(description=\"ISO 4217 currency code in upper case.\"),\n    ]\n    bill_amount: Annotated[\n        float | None,\n        Field(description=\"The billing amount for cross-currency payments.\"),\n    ] = None\n    bill_currency: Annotated[\n        Currency | None,\n        Field(description=\"The billing currency for cross-currency payments.\"),\n    ] = None\n    account_id: Annotated[\n        UUID,\n        Field(\n            description=\"The ID of the account that the transaction leg is associated with.\"\n        ),\n    ]\n    counterparty: Annotated[\n        ModelCounterparty | None,\n        Field(description=\"The counterparty of the transaction leg.\"),\n    ] = None\n    description: Annotated[\n        str | None,\n        Field(description=\"The transaction leg purpose.\"),\n    ] = None\n    balance: Annotated[\n        float | None,\n        Field(\n            description=\"The total balance of the account that the transaction is associated with.\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.resources.ResourceTransaction.ModelLeg.ModelCounterparty","title":"<code>ModelCounterparty</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The counterparty of the transaction.</p> Source code in <code>pyrevolut/api/transactions/resources/transaction.py</code> <pre><code>class ModelCounterparty(BaseModel):\n    \"\"\"The counterparty of the transaction.\"\"\"\n\n    account_id: Annotated[\n        UUID | None,\n        Field(description=\"The ID of the counterparty account.\"),\n    ] = None\n    account_type: Annotated[\n        EnumAccountType,\n        Field(description=\"Indicates the type of the account.\"),\n    ]\n    id: Annotated[\n        UUID | None,\n        Field(description=\"The ID of the counterparty.\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.resources.ResourceTransaction.ModelMerchant","title":"<code>ModelMerchant</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The information about the merchant (only for card transfers)</p> Source code in <code>pyrevolut/api/transactions/resources/transaction.py</code> <pre><code>class ModelMerchant(BaseModel):\n    \"\"\"The information about the merchant (only for card transfers)\"\"\"\n\n    name: Annotated[str, Field(description=\"The name of the merchant.\")]\n    city: Annotated[str, Field(description=\"The city of the merchant.\")]\n    category_code: Annotated[\n        str, Field(description=\"The category code of the merchant.\")\n    ]\n    country: Annotated[\n        CountryAlpha2 | CountryAlpha3,\n        Field(\n            description=\"The country of the merchant as the 2-letter ISO 3166 code.\"\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.get.RetrieveListOfTransactions","title":"<code>RetrieveListOfTransactions</code>","text":"<p>Retrieve the historical transactions based on the provided query criteria.</p> <p>The transactions are sorted by the created_at date in reverse chronological order, and they're paginated. The maximum number of transactions returned per page is specified by the count parameter. To get the next page of results, make a new request and use the created_at date from the last item of the previous page as the value for the to parameter.</p> Note <p>The API returns a maximum of 1,000 transactions per request.</p> Note <p>To be compliant with PSD2 SCA regulations, businesses on the Revolut Business Freelancer plans can only access information older than 90 days within 5 minutes of the first authorisation.</p> Source code in <code>pyrevolut/api/transactions/get/retrieve_list_of_transactions.py</code> <pre><code>class RetrieveListOfTransactions:\n    \"\"\"\n    Retrieve the historical transactions based on the provided query criteria.\n\n    The transactions are sorted by the created_at date in reverse chronological order,\n    and they're paginated. The maximum number of transactions returned per page is specified by the\n    count parameter. To get the next page of results, make a new request and use the created_at date\n    from the last item of the previous page as the value for the to parameter.\n\n    Note\n    ----\n    The API returns a maximum of 1,000 transactions per request.\n\n    Note\n    ----\n    To be compliant with PSD2 SCA regulations, businesses on the Revolut Business Freelancer\n    plans can only access information older than 90 days within 5 minutes of the first authorisation.\n    \"\"\"\n\n    ROUTE = \"/1.0/transactions\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The query parameters for the request.\n        \"\"\"\n\n        model_config = ConfigDict(\n            populate_by_name=True,\n            from_attributes=True,\n        )\n\n        from_: Annotated[\n            DateTime | Date | None,\n            Field(\n                description=\"\"\"\n                The date and time you retrieve the historical transactions from, including \n                this date-time. \n                Corresponds to the created_at value of the transaction. \n                Provided in ISO 8601 format.\n\n                Used also for pagination. To get back to the previous page of results, \n                make a new request and use the created_at date from the first item of the \n                current page as the value for the from parameter.\n                \"\"\"\n            ),\n        ] = None\n        to: Annotated[\n            DateTime | Date | None,\n            Field(\n                description=\"\"\"\n                The date and time you retrieve the historical transactions to, excluding \n                this date-time. \n                Corresponds to the created_at value of the transaction. \n                Provided in ISO 8601 format. \n                The default value is the date and time at which you're calling the endpoint.\n\n                Used also for pagination. \n                To get the next page of results, make a new request and use the created_at \n                date from the last item of the previous (current) page as the value for the \n                to parameter.  \n                \"\"\"\n            ),\n        ] = None\n        account: Annotated[\n            UUID | None,\n            Field(\n                description=\"\"\"\n                The ID of the account\n                \"\"\"\n            ),\n        ] = None\n        count: Annotated[\n            int | None,\n            Field(\n                description=\"\"\"\n                The maximum number of the historical transactions to retrieve per page.\n\n                To get the next page of results, make a new request and use \n                the created_at date from the last item of the previous page as the \n                value for the to parameter.   \n\n                If not provided, the default value is 100.             \n                \"\"\",\n                le=1000,\n                ge=1,\n            ),\n        ] = None\n        type: Annotated[\n            EnumTransactionType | None,\n            Field(\n                description=\"\"\"\n                The type of the historical transactions to retrieve.\n                \"\"\"\n            ),\n        ] = None\n\n    class Response(ResourceTransaction):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.get.RetrieveListOfTransactions.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The query parameters for the request.</p> Source code in <code>pyrevolut/api/transactions/get/retrieve_list_of_transactions.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The query parameters for the request.\n    \"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        from_attributes=True,\n    )\n\n    from_: Annotated[\n        DateTime | Date | None,\n        Field(\n            description=\"\"\"\n            The date and time you retrieve the historical transactions from, including \n            this date-time. \n            Corresponds to the created_at value of the transaction. \n            Provided in ISO 8601 format.\n\n            Used also for pagination. To get back to the previous page of results, \n            make a new request and use the created_at date from the first item of the \n            current page as the value for the from parameter.\n            \"\"\"\n        ),\n    ] = None\n    to: Annotated[\n        DateTime | Date | None,\n        Field(\n            description=\"\"\"\n            The date and time you retrieve the historical transactions to, excluding \n            this date-time. \n            Corresponds to the created_at value of the transaction. \n            Provided in ISO 8601 format. \n            The default value is the date and time at which you're calling the endpoint.\n\n            Used also for pagination. \n            To get the next page of results, make a new request and use the created_at \n            date from the last item of the previous (current) page as the value for the \n            to parameter.  \n            \"\"\"\n        ),\n    ] = None\n    account: Annotated[\n        UUID | None,\n        Field(\n            description=\"\"\"\n            The ID of the account\n            \"\"\"\n        ),\n    ] = None\n    count: Annotated[\n        int | None,\n        Field(\n            description=\"\"\"\n            The maximum number of the historical transactions to retrieve per page.\n\n            To get the next page of results, make a new request and use \n            the created_at date from the last item of the previous page as the \n            value for the to parameter.   \n\n            If not provided, the default value is 100.             \n            \"\"\",\n            le=1000,\n            ge=1,\n        ),\n    ] = None\n    type: Annotated[\n        EnumTransactionType | None,\n        Field(\n            description=\"\"\"\n            The type of the historical transactions to retrieve.\n            \"\"\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.get.RetrieveListOfTransactions.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceTransaction</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/transactions/get/retrieve_list_of_transactions.py</code> <pre><code>class Response(ResourceTransaction):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.get.RetrieveTransaction","title":"<code>RetrieveTransaction</code>","text":"<p>Retrieve the details of a specific transaction. The details can include, for example, cardholder details for card payments.</p> <p>You can retrieve a transaction with its details either by its transaction ID or by the request ID that was provided for this transaction at the time of its creation, for example, when you created a payment.</p> <p>To retrieve a transaction by its transaction ID, use:</p> <pre><code>/transaction/{transaction_id}\n</code></pre> <p>To retrieve a transaction by a request ID provided at transaction creation, use:</p> <pre><code>/transaction/{request_id}?id_type=request_id\n</code></pre> Source code in <code>pyrevolut/api/transactions/get/retrieve_transaction.py</code> <pre><code>class RetrieveTransaction:\n    \"\"\"\n    Retrieve the details of a specific transaction.\n    The details can include, for example, cardholder details for card payments.\n\n    You can retrieve a transaction with its details either by its transaction ID\n    or by the request ID that was provided for this transaction at the time of its\n    creation, for example, when you created a payment.\n\n    To retrieve a transaction by its transaction ID, use:\n\n        /transaction/{transaction_id}\n\n    To retrieve a transaction by a request ID provided at transaction creation, use:\n\n        /transaction/{request_id}?id_type=request_id\n    \"\"\"\n\n    ROUTE = \"/1.0/transaction/{id}\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The query parameters for the request.\n        \"\"\"\n\n        id_type: Annotated[\n            Literal[\"request_id\"] | None,\n            Field(\n                description=\"\"\"\n                The type of the ID you're providing for the transaction retrieval.\n                The default value is None, which means that the transaction ID is provided.\n                \"\"\",\n            ),\n        ] = None\n\n    class Response(ResourceTransaction):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.get.RetrieveTransaction.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The query parameters for the request.</p> Source code in <code>pyrevolut/api/transactions/get/retrieve_transaction.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The query parameters for the request.\n    \"\"\"\n\n    id_type: Annotated[\n        Literal[\"request_id\"] | None,\n        Field(\n            description=\"\"\"\n            The type of the ID you're providing for the transaction retrieval.\n            The default value is None, which means that the transaction ID is provided.\n            \"\"\",\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/transactions/pydantic/#pyrevolut.api.transactions.get.RetrieveTransaction.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceTransaction</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/transactions/get/retrieve_transaction.py</code> <pre><code>class Response(ResourceTransaction):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/transactions/synchronous/","title":"Transactions Synchronous Endpoints","text":"<p>This <code>Transactions</code> endpoint provides methods to interact with the transactions of the authenticated user.</p> <p>Example usage of the Transactions endpoint object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    transactions = client.Transactions.get_all_transactions()\n    print(transactions)\n</code></pre>"},{"location":"code_reference/api/transactions/synchronous/#pyrevolut.api.transactions.endpoint.EndpointTransactionsSync","title":"<code>EndpointTransactionsSync</code>","text":"<p>               Bases: <code>BaseEndpointSync</code></p> <p>The Transactions API</p> <p>Get the details of your transactions.</p> Note <p>An incoming or outgoing payment is represented as a transaction.</p> Source code in <code>pyrevolut/api/transactions/endpoint/synchronous.py</code> <pre><code>class EndpointTransactionsSync(BaseEndpointSync):\n    \"\"\"The Transactions API\n\n    Get the details of your transactions.\n\n    Note\n    ----\n    An incoming or outgoing payment is represented as a transaction.\n    \"\"\"\n\n    def get_all_transactions(\n        self,\n        from_datetime: datetime | DateTime | str | int | float | None = None,\n        to_datetime: datetime | DateTime | str | int | float | None = None,\n        account_id: UUID | None = None,\n        limit: int | None = None,\n        transaction_type: EnumTransactionType | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfTransactions.Response]:\n        \"\"\"\n        Retrieve the historical transactions based on the provided query criteria.\n\n        The transactions are sorted by the created_at date in reverse chronological order,\n        and they're paginated. The maximum number of transactions returned per page is specified by the\n        count parameter. To get the next page of results, make a new request and use the created_at date\n        from the last item of the previous page as the value for the to parameter.\n\n        Note\n        ----\n        The API returns a maximum of 1,000 transactions per request.\n\n        Note\n        ----\n        To be compliant with PSD2 SCA regulations, businesses on the Revolut Business Freelancer\n        plans can only access information older than 90 days within 5 minutes of the first authorisation.\n\n        Parameters\n        ----------\n        from_datetime : datetime | DateTime | str | int | float, optional\n            The date and time you retrieve the historical transactions from, including\n            this date-time.\n            Corresponds to the created_at value of the transaction.\n            Provided in ISO 8601 format.\n\n            Used also for pagination. To get back to the previous page of results,\n            make a new request and use the created_at date from the first item of the\n            current page as the value for the from parameter.\n        to_datetime : datetime | DateTime | str | int | float, optional\n            The date and time you retrieve the historical transactions to, excluding\n            this date-time.\n            Corresponds to the created_at value of the transaction.\n            Provided in ISO 8601 format.\n            The default value is the date and time at which you're calling the endpoint.\n\n            Used also for pagination.\n            To get the next page of results, make a new request and use the created_at\n            date from the last item of the previous (current) page as the value for the\n            to parameter.\n        account_id : UUID, optional\n            The ID of the account for which you want to retrieve the transactions.\n        limit : int, optional\n            The maximum number of transactions returned per page.\n            To get the next page of results, make a new request and use the created_at\n            date from the last item of the previous page as the value for the to parameter.\n        transaction_type : EnumTransactionType, optional\n            The type of the transaction.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfTransactions.Response]\n            A list of transactions.\n        \"\"\"\n        endpoint = RetrieveListOfTransactions\n        path = endpoint.ROUTE\n        params = endpoint.Params(\n            from_=from_datetime,\n            to=to_datetime,\n            account=account_id,\n            count=limit,\n            type=transaction_type,\n        )\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_transaction(\n        self,\n        transaction_id: UUID | None = None,\n        request_id: str | None = None,\n        **kwargs,\n    ) -&gt; dict | RetrieveTransaction.Response:\n        \"\"\"\n        Retrieve the details of a specific transaction.\n        The details can include, for example, cardholder details for card payments.\n\n        You can retrieve a transaction with its details either by its transaction ID\n        or by the request ID that was provided for this transaction at the time of its\n        creation, for example, when you created a payment.\n\n        To retrieve a transaction by its transaction ID, use:\n\n            /transaction/{transaction_id}\n\n        To retrieve a transaction by a request ID provided at transaction creation, use:\n\n            /transaction/{request_id}?id_type=request_id\n\n        Parameters\n        ----------\n        transaction_id : UUID, optional\n            The ID of the transaction.\n            Specify either transaction_id or request_id.\n        request_id : str, optional\n            The request ID of the transaction.\n            Specify either transaction_id or request_id.\n\n        Returns\n        -------\n        dict | RetrieveTransaction.Response\n            The details of the transaction.\n        \"\"\"\n        assert (\n            transaction_id or request_id\n        ), \"Either transaction_id or request_id must be provided.\"\n        assert not (\n            transaction_id and request_id\n        ), \"Either transaction_id or request_id must be provided, not both.\"\n\n        endpoint = RetrieveTransaction\n        path = endpoint.ROUTE.format(id=transaction_id or request_id)\n        params = endpoint.Params(id_type=\"request_id\" if request_id else None)\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/transactions/synchronous/#pyrevolut.api.transactions.endpoint.EndpointTransactionsSync.get_all_transactions","title":"<code>get_all_transactions(from_datetime=None, to_datetime=None, account_id=None, limit=None, transaction_type=None, **kwargs)</code>","text":"<p>Retrieve the historical transactions based on the provided query criteria.</p> <p>The transactions are sorted by the created_at date in reverse chronological order, and they're paginated. The maximum number of transactions returned per page is specified by the count parameter. To get the next page of results, make a new request and use the created_at date from the last item of the previous page as the value for the to parameter.</p> Note <p>The API returns a maximum of 1,000 transactions per request.</p> Note <p>To be compliant with PSD2 SCA regulations, businesses on the Revolut Business Freelancer plans can only access information older than 90 days within 5 minutes of the first authorisation.</p> <p>Parameters:</p> Name Type Description Default <code>from_datetime</code> <code>datetime | DateTime | str | int | float</code> <p>The date and time you retrieve the historical transactions from, including this date-time. Corresponds to the created_at value of the transaction. Provided in ISO 8601 format.</p> <p>Used also for pagination. To get back to the previous page of results, make a new request and use the created_at date from the first item of the current page as the value for the from parameter.</p> <code>None</code> <code>to_datetime</code> <code>datetime | DateTime | str | int | float</code> <p>The date and time you retrieve the historical transactions to, excluding this date-time. Corresponds to the created_at value of the transaction. Provided in ISO 8601 format. The default value is the date and time at which you're calling the endpoint.</p> <p>Used also for pagination. To get the next page of results, make a new request and use the created_at date from the last item of the previous (current) page as the value for the to parameter.</p> <code>None</code> <code>account_id</code> <code>UUID</code> <p>The ID of the account for which you want to retrieve the transactions.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of transactions returned per page. To get the next page of results, make a new request and use the created_at date from the last item of the previous page as the value for the to parameter.</p> <code>None</code> <code>transaction_type</code> <code>EnumTransactionType</code> <p>The type of the transaction.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>A list of transactions.</p> Source code in <code>pyrevolut/api/transactions/endpoint/synchronous.py</code> <pre><code>def get_all_transactions(\n    self,\n    from_datetime: datetime | DateTime | str | int | float | None = None,\n    to_datetime: datetime | DateTime | str | int | float | None = None,\n    account_id: UUID | None = None,\n    limit: int | None = None,\n    transaction_type: EnumTransactionType | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfTransactions.Response]:\n    \"\"\"\n    Retrieve the historical transactions based on the provided query criteria.\n\n    The transactions are sorted by the created_at date in reverse chronological order,\n    and they're paginated. The maximum number of transactions returned per page is specified by the\n    count parameter. To get the next page of results, make a new request and use the created_at date\n    from the last item of the previous page as the value for the to parameter.\n\n    Note\n    ----\n    The API returns a maximum of 1,000 transactions per request.\n\n    Note\n    ----\n    To be compliant with PSD2 SCA regulations, businesses on the Revolut Business Freelancer\n    plans can only access information older than 90 days within 5 minutes of the first authorisation.\n\n    Parameters\n    ----------\n    from_datetime : datetime | DateTime | str | int | float, optional\n        The date and time you retrieve the historical transactions from, including\n        this date-time.\n        Corresponds to the created_at value of the transaction.\n        Provided in ISO 8601 format.\n\n        Used also for pagination. To get back to the previous page of results,\n        make a new request and use the created_at date from the first item of the\n        current page as the value for the from parameter.\n    to_datetime : datetime | DateTime | str | int | float, optional\n        The date and time you retrieve the historical transactions to, excluding\n        this date-time.\n        Corresponds to the created_at value of the transaction.\n        Provided in ISO 8601 format.\n        The default value is the date and time at which you're calling the endpoint.\n\n        Used also for pagination.\n        To get the next page of results, make a new request and use the created_at\n        date from the last item of the previous (current) page as the value for the\n        to parameter.\n    account_id : UUID, optional\n        The ID of the account for which you want to retrieve the transactions.\n    limit : int, optional\n        The maximum number of transactions returned per page.\n        To get the next page of results, make a new request and use the created_at\n        date from the last item of the previous page as the value for the to parameter.\n    transaction_type : EnumTransactionType, optional\n        The type of the transaction.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfTransactions.Response]\n        A list of transactions.\n    \"\"\"\n    endpoint = RetrieveListOfTransactions\n    path = endpoint.ROUTE\n    params = endpoint.Params(\n        from_=from_datetime,\n        to=to_datetime,\n        account=account_id,\n        count=limit,\n        type=transaction_type,\n    )\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/transactions/synchronous/#pyrevolut.api.transactions.endpoint.EndpointTransactionsSync.get_transaction","title":"<code>get_transaction(transaction_id=None, request_id=None, **kwargs)</code>","text":"<p>Retrieve the details of a specific transaction. The details can include, for example, cardholder details for card payments.</p> <p>You can retrieve a transaction with its details either by its transaction ID or by the request ID that was provided for this transaction at the time of its creation, for example, when you created a payment.</p> <p>To retrieve a transaction by its transaction ID, use:</p> <pre><code>/transaction/{transaction_id}\n</code></pre> <p>To retrieve a transaction by a request ID provided at transaction creation, use:</p> <pre><code>/transaction/{request_id}?id_type=request_id\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>transaction_id</code> <code>UUID</code> <p>The ID of the transaction. Specify either transaction_id or request_id.</p> <code>None</code> <code>request_id</code> <code>str</code> <p>The request ID of the transaction. Specify either transaction_id or request_id.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The details of the transaction.</p> Source code in <code>pyrevolut/api/transactions/endpoint/synchronous.py</code> <pre><code>def get_transaction(\n    self,\n    transaction_id: UUID | None = None,\n    request_id: str | None = None,\n    **kwargs,\n) -&gt; dict | RetrieveTransaction.Response:\n    \"\"\"\n    Retrieve the details of a specific transaction.\n    The details can include, for example, cardholder details for card payments.\n\n    You can retrieve a transaction with its details either by its transaction ID\n    or by the request ID that was provided for this transaction at the time of its\n    creation, for example, when you created a payment.\n\n    To retrieve a transaction by its transaction ID, use:\n\n        /transaction/{transaction_id}\n\n    To retrieve a transaction by a request ID provided at transaction creation, use:\n\n        /transaction/{request_id}?id_type=request_id\n\n    Parameters\n    ----------\n    transaction_id : UUID, optional\n        The ID of the transaction.\n        Specify either transaction_id or request_id.\n    request_id : str, optional\n        The request ID of the transaction.\n        Specify either transaction_id or request_id.\n\n    Returns\n    -------\n    dict | RetrieveTransaction.Response\n        The details of the transaction.\n    \"\"\"\n    assert (\n        transaction_id or request_id\n    ), \"Either transaction_id or request_id must be provided.\"\n    assert not (\n        transaction_id and request_id\n    ), \"Either transaction_id or request_id must be provided, not both.\"\n\n    endpoint = RetrieveTransaction\n    path = endpoint.ROUTE.format(id=transaction_id or request_id)\n    params = endpoint.Params(id_type=\"request_id\" if request_id else None)\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/transfers/asynchronous/","title":"Transfers Asynchronous Endpoints","text":"<p>This <code>Transfers</code> endpoint provides asynchronous methods to interact with the transfers of the authenticated user.</p> <p>Example usage of the Transfers endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        reasons = await client.Transfers.get_transfer_reasons()\n        print(reasons)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/transfers/asynchronous/#pyrevolut.api.transfers.endpoint.EndpointTransfersAsync","title":"<code>EndpointTransfersAsync</code>","text":"<p>               Bases: <code>BaseEndpointAsync</code></p> <p>The async Transfers API</p> <p>Move funds in the same currency between accounts of your business, or make payments to your counterparties.</p> Source code in <code>pyrevolut/api/transfers/endpoint/asynchronous.py</code> <pre><code>class EndpointTransfersAsync(BaseEndpointAsync):\n    \"\"\"The async Transfers API\n\n    Move funds in the same currency between accounts of your business,\n    or make payments to your counterparties.\n    \"\"\"\n\n    async def get_transfer_reasons(\n        self,\n        **kwargs,\n    ) -&gt; list[dict] | list[GetTransferReasons.Response]:\n        \"\"\"\n        In order to initiate a transfer in certain currencies and countries,\n        you must provide a transfer reason.\n        With this endpoint you can retrieve all transfer reasons available to your business account\n        per country and currency.\n\n        After you retrieve the results, use the appropriate reason code in the transfer_reason_code\n        field when making a transfer to a counterparty or creating a payout link.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        list[dict] | list[GetTransferReasons.Response]\n            A list of transfer reasons.\n        \"\"\"\n        endpoint = GetTransferReasons\n        path = endpoint.ROUTE\n        params = endpoint.Params()\n\n        return await self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    async def create_transfer_to_another_account(\n        self,\n        request_id: str,\n        account_id: UUID,\n        counterparty_id: UUID,\n        amount: float,\n        currency: str,\n        counterparty_account_id: UUID | None = None,\n        counterparty_card_id: UUID | None = None,\n        reference: str | None = None,\n        charge_bearer: EnumChargeBearer | None = None,\n        transfer_reason_code: EnumTransferReasonCode | None = None,\n        **kwargs,\n    ) -&gt; dict | CreateTransferToAnotherAccount.Response:\n        \"\"\"\n        Make a payment to a counterparty.\n        The resulting transaction has the type transfer.\n\n        If you make the payment to another Revolut account, either business or personal,\n        the transaction is executed instantly.\n\n        If the counterparty has multiple payment methods available, for example, 2 accounts,\n        or 1 account and 1 card, you must specify the account or card to which you want to\n        transfer the money (receiver.account_id or receiver.card_id respectively).\n\n        Caution\n        -------\n        Due to PSD2 Strong Customer Authentication regulations, this endpoint is\n        only available for customers on Revolut Business Company plans. If you're a\n        freelancer and wish to make payments via our API, we advise that you instead\n        leverage our Payment drafts (/payment-drafts) endpoint.\n\n        Parameters\n        ----------\n        request_id : str\n            The ID of the request, provided by you.\n            It helps you identify the transaction in your system.\n            To ensure that a transfer is not processed multiple times if\n            there are network or system errors, the same request_id should be used\n            for requests related to the same transfer.\n        account_id : UUID\n            The ID of the account that you transfer the funds from.\n        counterparty_id : UUID\n            The ID of the receiving counterparty.\n        amount : float\n            The amount of money to transfer.\n        currency : str\n            The currency of the transfer.\n        counterparty_account_id : UUID, optional\n            The ID of the receiving counterparty's account, which can be own account.\n            Used for bank transfers.\n            If the counterparty has multiple payment methods available, use it to\n            specify the account to which you want to send the money.\n        counterparty_card_id : UUID, optional\n            The ID of the receiving counterparty's card. Used for card transfers.\n            If the counterparty has multiple payment methods available, use it to\n            specify the card to which you want to send the money.\n        reference : str, optional\n            A reference for the transfer.\n        charge_bearer : EnumChargeBearer, optional\n            The party to which any transaction fees are charged if the resulting\n            transaction route has associated fees. Some transactions with fees might\n            not be possible with the specified option, in which case error 3287 is returned.\n\n            Possible values:\n            - shared: The transaction fees are shared between the sender and the receiver.\n            - debtor: The sender pays the transaction fees.\n        transfer_reason_code : EnumTransferReasonCode, optional\n            The reason code for the transaction.\n            Transactions to certain countries and currencies might require\n            you to provide a transfer reason.\n            You can check available reason codes with the getTransferReasons operation.\n\n            If a transfer reason is not required for the given currency and country,\n            this field is ignored.\n\n        Returns\n        -------\n        dict | CreateTransferToAnotherAccount.Response\n            The details of the transfer.\n        \"\"\"\n        endpoint = CreateTransferToAnotherAccount\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            request_id=request_id,\n            account_id=account_id,\n            receiver=endpoint.Body.ModelReceiver(\n                counterparty_id=counterparty_id,\n                account_id=counterparty_account_id,\n                card_id=counterparty_card_id,\n            ),\n            amount=amount,\n            currency=currency,\n            reference=reference,\n            charge_bearer=charge_bearer,\n            transfer_reason_code=transfer_reason_code,\n        )\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    async def move_money_between_accounts(\n        self,\n        request_id: str,\n        source_account_id: UUID,\n        target_account_id: UUID,\n        amount: float,\n        currency: str,\n        reference: str | None = None,\n        **kwargs,\n    ) -&gt; dict | MoveMoneyBetweenAccounts.Response:\n        \"\"\"\n        Move money between the Revolut accounts of the business in the same currency.\n\n        The resulting transaction has the type transfer.\n\n        Parameters\n        ----------\n        request_id : str\n            The ID of the request, provided by you.\n            It helps you identify the transaction in your system.\n            To ensure that a transfer is not processed multiple times if\n            there are network or system errors, the same request_id should be used\n            for requests related to the same transfer.\n        source_account_id : UUID\n            The ID of the source account that you transfer the funds from.\n        target_account_id : UUID\n            The ID of the target account that you transfer the funds to.\n        amount : float\n            The amount of the funds to be transferred.\n        currency : str\n            The ISO 4217 currency of the funds to be transferred.\n        reference : str, optional\n            The reference for the funds transfer.\n\n        Returns\n        -------\n        dict | MoveMoneyBetweenAccounts.Response\n            The details of the transfer.\n        \"\"\"\n        endpoint = MoveMoneyBetweenAccounts\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            request_id=request_id,\n            source_account_id=source_account_id,\n            target_account_id=target_account_id,\n            amount=amount,\n            currency=currency,\n            reference=reference,\n        )\n\n        return await self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/transfers/asynchronous/#pyrevolut.api.transfers.endpoint.EndpointTransfersAsync.create_transfer_to_another_account","title":"<code>create_transfer_to_another_account(request_id, account_id, counterparty_id, amount, currency, counterparty_account_id=None, counterparty_card_id=None, reference=None, charge_bearer=None, transfer_reason_code=None, **kwargs)</code>  <code>async</code>","text":"<p>Make a payment to a counterparty. The resulting transaction has the type transfer.</p> <p>If you make the payment to another Revolut account, either business or personal, the transaction is executed instantly.</p> <p>If the counterparty has multiple payment methods available, for example, 2 accounts, or 1 account and 1 card, you must specify the account or card to which you want to transfer the money (receiver.account_id or receiver.card_id respectively).</p> Caution <p>Due to PSD2 Strong Customer Authentication regulations, this endpoint is only available for customers on Revolut Business Company plans. If you're a freelancer and wish to make payments via our API, we advise that you instead leverage our Payment drafts (/payment-drafts) endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>request_id</code> <code>str</code> <p>The ID of the request, provided by you. It helps you identify the transaction in your system. To ensure that a transfer is not processed multiple times if there are network or system errors, the same request_id should be used for requests related to the same transfer.</p> required <code>account_id</code> <code>UUID</code> <p>The ID of the account that you transfer the funds from.</p> required <code>counterparty_id</code> <code>UUID</code> <p>The ID of the receiving counterparty.</p> required <code>amount</code> <code>float</code> <p>The amount of money to transfer.</p> required <code>currency</code> <code>str</code> <p>The currency of the transfer.</p> required <code>counterparty_account_id</code> <code>UUID</code> <p>The ID of the receiving counterparty's account, which can be own account. Used for bank transfers. If the counterparty has multiple payment methods available, use it to specify the account to which you want to send the money.</p> <code>None</code> <code>counterparty_card_id</code> <code>UUID</code> <p>The ID of the receiving counterparty's card. Used for card transfers. If the counterparty has multiple payment methods available, use it to specify the card to which you want to send the money.</p> <code>None</code> <code>reference</code> <code>str</code> <p>A reference for the transfer.</p> <code>None</code> <code>charge_bearer</code> <code>EnumChargeBearer</code> <p>The party to which any transaction fees are charged if the resulting transaction route has associated fees. Some transactions with fees might not be possible with the specified option, in which case error 3287 is returned.</p> <p>Possible values: - shared: The transaction fees are shared between the sender and the receiver. - debtor: The sender pays the transaction fees.</p> <code>None</code> <code>transfer_reason_code</code> <code>EnumTransferReasonCode</code> <p>The reason code for the transaction. Transactions to certain countries and currencies might require you to provide a transfer reason. You can check available reason codes with the getTransferReasons operation.</p> <p>If a transfer reason is not required for the given currency and country, this field is ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The details of the transfer.</p> Source code in <code>pyrevolut/api/transfers/endpoint/asynchronous.py</code> <pre><code>async def create_transfer_to_another_account(\n    self,\n    request_id: str,\n    account_id: UUID,\n    counterparty_id: UUID,\n    amount: float,\n    currency: str,\n    counterparty_account_id: UUID | None = None,\n    counterparty_card_id: UUID | None = None,\n    reference: str | None = None,\n    charge_bearer: EnumChargeBearer | None = None,\n    transfer_reason_code: EnumTransferReasonCode | None = None,\n    **kwargs,\n) -&gt; dict | CreateTransferToAnotherAccount.Response:\n    \"\"\"\n    Make a payment to a counterparty.\n    The resulting transaction has the type transfer.\n\n    If you make the payment to another Revolut account, either business or personal,\n    the transaction is executed instantly.\n\n    If the counterparty has multiple payment methods available, for example, 2 accounts,\n    or 1 account and 1 card, you must specify the account or card to which you want to\n    transfer the money (receiver.account_id or receiver.card_id respectively).\n\n    Caution\n    -------\n    Due to PSD2 Strong Customer Authentication regulations, this endpoint is\n    only available for customers on Revolut Business Company plans. If you're a\n    freelancer and wish to make payments via our API, we advise that you instead\n    leverage our Payment drafts (/payment-drafts) endpoint.\n\n    Parameters\n    ----------\n    request_id : str\n        The ID of the request, provided by you.\n        It helps you identify the transaction in your system.\n        To ensure that a transfer is not processed multiple times if\n        there are network or system errors, the same request_id should be used\n        for requests related to the same transfer.\n    account_id : UUID\n        The ID of the account that you transfer the funds from.\n    counterparty_id : UUID\n        The ID of the receiving counterparty.\n    amount : float\n        The amount of money to transfer.\n    currency : str\n        The currency of the transfer.\n    counterparty_account_id : UUID, optional\n        The ID of the receiving counterparty's account, which can be own account.\n        Used for bank transfers.\n        If the counterparty has multiple payment methods available, use it to\n        specify the account to which you want to send the money.\n    counterparty_card_id : UUID, optional\n        The ID of the receiving counterparty's card. Used for card transfers.\n        If the counterparty has multiple payment methods available, use it to\n        specify the card to which you want to send the money.\n    reference : str, optional\n        A reference for the transfer.\n    charge_bearer : EnumChargeBearer, optional\n        The party to which any transaction fees are charged if the resulting\n        transaction route has associated fees. Some transactions with fees might\n        not be possible with the specified option, in which case error 3287 is returned.\n\n        Possible values:\n        - shared: The transaction fees are shared between the sender and the receiver.\n        - debtor: The sender pays the transaction fees.\n    transfer_reason_code : EnumTransferReasonCode, optional\n        The reason code for the transaction.\n        Transactions to certain countries and currencies might require\n        you to provide a transfer reason.\n        You can check available reason codes with the getTransferReasons operation.\n\n        If a transfer reason is not required for the given currency and country,\n        this field is ignored.\n\n    Returns\n    -------\n    dict | CreateTransferToAnotherAccount.Response\n        The details of the transfer.\n    \"\"\"\n    endpoint = CreateTransferToAnotherAccount\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        request_id=request_id,\n        account_id=account_id,\n        receiver=endpoint.Body.ModelReceiver(\n            counterparty_id=counterparty_id,\n            account_id=counterparty_account_id,\n            card_id=counterparty_card_id,\n        ),\n        amount=amount,\n        currency=currency,\n        reference=reference,\n        charge_bearer=charge_bearer,\n        transfer_reason_code=transfer_reason_code,\n    )\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/transfers/asynchronous/#pyrevolut.api.transfers.endpoint.EndpointTransfersAsync.get_transfer_reasons","title":"<code>get_transfer_reasons(**kwargs)</code>  <code>async</code>","text":"<p>In order to initiate a transfer in certain currencies and countries, you must provide a transfer reason. With this endpoint you can retrieve all transfer reasons available to your business account per country and currency.</p> <p>After you retrieve the results, use the appropriate reason code in the transfer_reason_code field when making a transfer to a counterparty or creating a payout link.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>A list of transfer reasons.</p> Source code in <code>pyrevolut/api/transfers/endpoint/asynchronous.py</code> <pre><code>async def get_transfer_reasons(\n    self,\n    **kwargs,\n) -&gt; list[dict] | list[GetTransferReasons.Response]:\n    \"\"\"\n    In order to initiate a transfer in certain currencies and countries,\n    you must provide a transfer reason.\n    With this endpoint you can retrieve all transfer reasons available to your business account\n    per country and currency.\n\n    After you retrieve the results, use the appropriate reason code in the transfer_reason_code\n    field when making a transfer to a counterparty or creating a payout link.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    list[dict] | list[GetTransferReasons.Response]\n        A list of transfer reasons.\n    \"\"\"\n    endpoint = GetTransferReasons\n    path = endpoint.ROUTE\n    params = endpoint.Params()\n\n    return await self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/transfers/asynchronous/#pyrevolut.api.transfers.endpoint.EndpointTransfersAsync.move_money_between_accounts","title":"<code>move_money_between_accounts(request_id, source_account_id, target_account_id, amount, currency, reference=None, **kwargs)</code>  <code>async</code>","text":"<p>Move money between the Revolut accounts of the business in the same currency.</p> <p>The resulting transaction has the type transfer.</p> <p>Parameters:</p> Name Type Description Default <code>request_id</code> <code>str</code> <p>The ID of the request, provided by you. It helps you identify the transaction in your system. To ensure that a transfer is not processed multiple times if there are network or system errors, the same request_id should be used for requests related to the same transfer.</p> required <code>source_account_id</code> <code>UUID</code> <p>The ID of the source account that you transfer the funds from.</p> required <code>target_account_id</code> <code>UUID</code> <p>The ID of the target account that you transfer the funds to.</p> required <code>amount</code> <code>float</code> <p>The amount of the funds to be transferred.</p> required <code>currency</code> <code>str</code> <p>The ISO 4217 currency of the funds to be transferred.</p> required <code>reference</code> <code>str</code> <p>The reference for the funds transfer.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The details of the transfer.</p> Source code in <code>pyrevolut/api/transfers/endpoint/asynchronous.py</code> <pre><code>async def move_money_between_accounts(\n    self,\n    request_id: str,\n    source_account_id: UUID,\n    target_account_id: UUID,\n    amount: float,\n    currency: str,\n    reference: str | None = None,\n    **kwargs,\n) -&gt; dict | MoveMoneyBetweenAccounts.Response:\n    \"\"\"\n    Move money between the Revolut accounts of the business in the same currency.\n\n    The resulting transaction has the type transfer.\n\n    Parameters\n    ----------\n    request_id : str\n        The ID of the request, provided by you.\n        It helps you identify the transaction in your system.\n        To ensure that a transfer is not processed multiple times if\n        there are network or system errors, the same request_id should be used\n        for requests related to the same transfer.\n    source_account_id : UUID\n        The ID of the source account that you transfer the funds from.\n    target_account_id : UUID\n        The ID of the target account that you transfer the funds to.\n    amount : float\n        The amount of the funds to be transferred.\n    currency : str\n        The ISO 4217 currency of the funds to be transferred.\n    reference : str, optional\n        The reference for the funds transfer.\n\n    Returns\n    -------\n    dict | MoveMoneyBetweenAccounts.Response\n        The details of the transfer.\n    \"\"\"\n    endpoint = MoveMoneyBetweenAccounts\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        request_id=request_id,\n        source_account_id=source_account_id,\n        target_account_id=target_account_id,\n        amount=amount,\n        currency=currency,\n        reference=reference,\n    )\n\n    return await self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/","title":"Transfers Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Transfers</code> endpoint.</p>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.resources.ResourceTransfer","title":"<code>ResourceTransfer</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Transfer resource model.</p> Source code in <code>pyrevolut/api/transfers/resources/transfer.py</code> <pre><code>class ResourceTransfer(BaseModel):\n    \"\"\"\n    Transfer resource model.\n    \"\"\"\n\n    id: Annotated[str, Field(description=\"The ID of the transaction created.\")]\n    state: Annotated[\n        EnumTransactionState,\n        Field(\n            description=\"\"\"\n            Indicates the transaction state. Possible values:\n\n            created:\n                The transaction has been created and is either processed asynchronously\n                or scheduled for a later time.\n            pending:\n                The transaction is pending until it's being processed.\n                If the transfer is made between Revolut accounts,\n                this state is skipped and the transaction is executed instantly.\n            completed:\n                The transaction was successful.\n            declined:\n                The transaction was unsuccessful. This can happen for a variety of reasons,\n                for example, insufficient account balance, wrong receiver information, etc.\n            failed:\n                The transaction was unsuccessful. This can happen for a variety of reasons,\n                for example, invalid API calls, blocked payments, etc.\n            reverted:\n                The transaction was reverted. This can happen for a variety of reasons,\n                for example, the receiver being inaccessible.\n            \"\"\"\n        ),\n    ]\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the transaction was created in ISO 8601 format.\"\n        ),\n    ]\n    completed_at: Annotated[\n        DateTime | None,\n        Field(\n            description=\"The date and time the transaction was completed in ISO 8601 format.\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.get.GetTransferReasons","title":"<code>GetTransferReasons</code>","text":"<p>In order to initiate a transfer in certain currencies and countries, you must provide a transfer reason. With this endpoint you can retrieve all transfer reasons available to your business account per country and currency.</p> <p>After you retrieve the results, use the appropriate reason code in the transfer_reason_code field when making a transfer to a counterparty or creating a payout link.</p> Source code in <code>pyrevolut/api/transfers/get/get_transfer_reasons.py</code> <pre><code>class GetTransferReasons:\n    \"\"\"\n    In order to initiate a transfer in certain currencies and countries,\n    you must provide a transfer reason.\n    With this endpoint you can retrieve all transfer reasons available to your business account\n    per country and currency.\n\n    After you retrieve the results, use the appropriate reason code in the transfer_reason_code\n    field when making a transfer to a counterparty or creating a payout link.\n    \"\"\"\n\n    ROUTE = \"/1.0/transfer-reasons\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The query parameters for the request.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        country: Annotated[\n            CountryAlpha2,\n            Field(\n                description=\"\"\"\n                The bank country of the counterparty as the 2-letter ISO 3166 code.\n                \"\"\",\n            ),\n        ]\n        currency: Annotated[\n            Currency,\n            Field(\n                description=\"\"\"\n                ISO 4217 currency code in upper case.\n                \"\"\",\n            ),\n        ]\n        code: Annotated[\n            EnumTransferReasonCode,\n            Field(\n                description=\"\"\"\n                Category name of the transfer reason.\n                \"\"\",\n            ),\n        ]\n        description: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                The description of the given transfer reason.\n                \"\"\",\n            ),\n        ]\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.get.GetTransferReasons.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The query parameters for the request.</p> Source code in <code>pyrevolut/api/transfers/get/get_transfer_reasons.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The query parameters for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.get.GetTransferReasons.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/transfers/get/get_transfer_reasons.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    country: Annotated[\n        CountryAlpha2,\n        Field(\n            description=\"\"\"\n            The bank country of the counterparty as the 2-letter ISO 3166 code.\n            \"\"\",\n        ),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(\n            description=\"\"\"\n            ISO 4217 currency code in upper case.\n            \"\"\",\n        ),\n    ]\n    code: Annotated[\n        EnumTransferReasonCode,\n        Field(\n            description=\"\"\"\n            Category name of the transfer reason.\n            \"\"\",\n        ),\n    ]\n    description: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            The description of the given transfer reason.\n            \"\"\",\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.post.CreateTransferToAnotherAccount","title":"<code>CreateTransferToAnotherAccount</code>","text":"<p>Make a payment to a counterparty. The resulting transaction has the type transfer.</p> <p>If you make the payment to another Revolut account, either business or personal, the transaction is executed instantly.</p> <p>If the counterparty has multiple payment methods available, for example, 2 accounts, or 1 account and 1 card, you must specify the account or card to which you want to transfer the money (receiver.account_id or receiver.card_id respectively).</p> Caution <p>Due to PSD2 Strong Customer Authentication regulations, this endpoint is only available for customers on Revolut Business Company plans. If you're a freelancer and wish to make payments via our API, we advise that you instead leverage our Payment drafts (/payment-drafts) endpoint.</p> Source code in <code>pyrevolut/api/transfers/post/create_transfer_to_another_account.py</code> <pre><code>class CreateTransferToAnotherAccount:\n    \"\"\"\n    Make a payment to a counterparty.\n    The resulting transaction has the type transfer.\n\n    If you make the payment to another Revolut account, either business or personal,\n    the transaction is executed instantly.\n\n    If the counterparty has multiple payment methods available, for example, 2 accounts,\n    or 1 account and 1 card, you must specify the account or card to which you want to\n    transfer the money (receiver.account_id or receiver.card_id respectively).\n\n    Caution\n    -------\n    Due to PSD2 Strong Customer Authentication regulations, this endpoint is\n    only available for customers on Revolut Business Company plans. If you're a\n    freelancer and wish to make payments via our API, we advise that you instead\n    leverage our Payment drafts (/payment-drafts) endpoint.\n    \"\"\"\n\n    ROUTE = \"/1.0/pay\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The body of the request.\n        \"\"\"\n\n        class ModelReceiver(BaseModel):\n            \"\"\"\n            The details of the transfer recipient.\n\n            If the counterparty has multiple payment methods available\n            (e.g. 2 accounts, or 1 account and 1 card), you must specify the account\n            (account_id) or card (card_id) to which you want to transfer the money.\n            \"\"\"\n\n            counterparty_id: Annotated[\n                UUID,\n                Field(description=\"The ID of the receiving counterparty.\"),\n            ]\n            account_id: Annotated[\n                UUID | None,\n                Field(\n                    description=\"\"\"\n                    The ID of the receiving counterparty's account, which can be own account. \n                    Used for bank transfers.\n\n                    If the counterparty has multiple payment methods available, use it to \n                    specify the account to which you want to send the money.\n                    \"\"\",\n                ),\n            ] = None\n            card_id: Annotated[\n                UUID | None,\n                Field(\n                    description=\"\"\"\n                    The ID of the receiving counterparty's card. Used for card transfers.\n\n                    If the counterparty has multiple payment methods available, use it to \n                    specify the card to which you want to send the money.\n                    \"\"\",\n                ),\n            ] = None\n\n        request_id: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                The ID of the request, provided by you. \n                It helps you identify the transaction in your system.\n                To ensure that a transfer is not processed multiple times if \n                there are network or system errors, the same request_id should be used \n                for requests related to the same transfer.\n                \"\"\",\n                max_length=40,\n            ),\n        ]\n        account_id: Annotated[\n            UUID,\n            Field(description=\"The ID of the account that you send the funds from.\"),\n        ]\n        receiver: Annotated[\n            ModelReceiver,\n            Field(\n                description=\"\"\"\n                The details of the transfer recipient.\n\n                If the counterparty has multiple payment methods available\n                (e.g. 2 accounts, or 1 account and 1 card), you must specify the account\n                (account_id) or card (card_id) to which you want to transfer the money.\n                \"\"\"\n            ),\n        ]\n        amount: Annotated[\n            float,\n            Field(\n                description=\"The amount of the funds to be transferred.\",\n                gt=0,\n            ),\n        ]\n        currency: Annotated[\n            Currency,\n            Field(description=\"The ISO 4217 currency of the funds to be transferred.\"),\n        ]\n        reference: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The reference for the transaction.\n                \"\"\",\n            ),\n        ] = None\n        charge_bearer: Annotated[\n            EnumChargeBearer | None,\n            Field(\n                description=\"\"\"\n                The party to which any transaction fees are charged if the resulting \n                transaction route has associated fees. Some transactions with fees might \n                not be possible with the specified option, in which case error 3287 is returned.\n\n                Possible values:\n                - shared: The transaction fees are shared between the sender and the receiver.\n                - debtor: The sender pays the transaction fees.\n                \"\"\",\n            ),\n        ] = None\n        transfer_reason_code: Annotated[\n            EnumTransferReasonCode | None,\n            Field(\n                description=\"\"\"\n                The reason code for the transaction. \n                Transactions to certain countries and currencies might require \n                you to provide a transfer reason. \n                You can check available reason codes with the getTransferReasons operation.\n\n                If a transfer reason is not required for the given currency and country, \n                this field is ignored.\n                \"\"\",\n            ),\n        ] = None\n\n    class Response(ResourceTransfer):\n        \"\"\"\n        The response model of the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.post.CreateTransferToAnotherAccount.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The body of the request.</p> Source code in <code>pyrevolut/api/transfers/post/create_transfer_to_another_account.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The body of the request.\n    \"\"\"\n\n    class ModelReceiver(BaseModel):\n        \"\"\"\n        The details of the transfer recipient.\n\n        If the counterparty has multiple payment methods available\n        (e.g. 2 accounts, or 1 account and 1 card), you must specify the account\n        (account_id) or card (card_id) to which you want to transfer the money.\n        \"\"\"\n\n        counterparty_id: Annotated[\n            UUID,\n            Field(description=\"The ID of the receiving counterparty.\"),\n        ]\n        account_id: Annotated[\n            UUID | None,\n            Field(\n                description=\"\"\"\n                The ID of the receiving counterparty's account, which can be own account. \n                Used for bank transfers.\n\n                If the counterparty has multiple payment methods available, use it to \n                specify the account to which you want to send the money.\n                \"\"\",\n            ),\n        ] = None\n        card_id: Annotated[\n            UUID | None,\n            Field(\n                description=\"\"\"\n                The ID of the receiving counterparty's card. Used for card transfers.\n\n                If the counterparty has multiple payment methods available, use it to \n                specify the card to which you want to send the money.\n                \"\"\",\n            ),\n        ] = None\n\n    request_id: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            The ID of the request, provided by you. \n            It helps you identify the transaction in your system.\n            To ensure that a transfer is not processed multiple times if \n            there are network or system errors, the same request_id should be used \n            for requests related to the same transfer.\n            \"\"\",\n            max_length=40,\n        ),\n    ]\n    account_id: Annotated[\n        UUID,\n        Field(description=\"The ID of the account that you send the funds from.\"),\n    ]\n    receiver: Annotated[\n        ModelReceiver,\n        Field(\n            description=\"\"\"\n            The details of the transfer recipient.\n\n            If the counterparty has multiple payment methods available\n            (e.g. 2 accounts, or 1 account and 1 card), you must specify the account\n            (account_id) or card (card_id) to which you want to transfer the money.\n            \"\"\"\n        ),\n    ]\n    amount: Annotated[\n        float,\n        Field(\n            description=\"The amount of the funds to be transferred.\",\n            gt=0,\n        ),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(description=\"The ISO 4217 currency of the funds to be transferred.\"),\n    ]\n    reference: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The reference for the transaction.\n            \"\"\",\n        ),\n    ] = None\n    charge_bearer: Annotated[\n        EnumChargeBearer | None,\n        Field(\n            description=\"\"\"\n            The party to which any transaction fees are charged if the resulting \n            transaction route has associated fees. Some transactions with fees might \n            not be possible with the specified option, in which case error 3287 is returned.\n\n            Possible values:\n            - shared: The transaction fees are shared between the sender and the receiver.\n            - debtor: The sender pays the transaction fees.\n            \"\"\",\n        ),\n    ] = None\n    transfer_reason_code: Annotated[\n        EnumTransferReasonCode | None,\n        Field(\n            description=\"\"\"\n            The reason code for the transaction. \n            Transactions to certain countries and currencies might require \n            you to provide a transfer reason. \n            You can check available reason codes with the getTransferReasons operation.\n\n            If a transfer reason is not required for the given currency and country, \n            this field is ignored.\n            \"\"\",\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.post.CreateTransferToAnotherAccount.Body.ModelReceiver","title":"<code>ModelReceiver</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The details of the transfer recipient.</p> <p>If the counterparty has multiple payment methods available (e.g. 2 accounts, or 1 account and 1 card), you must specify the account (account_id) or card (card_id) to which you want to transfer the money.</p> Source code in <code>pyrevolut/api/transfers/post/create_transfer_to_another_account.py</code> <pre><code>class ModelReceiver(BaseModel):\n    \"\"\"\n    The details of the transfer recipient.\n\n    If the counterparty has multiple payment methods available\n    (e.g. 2 accounts, or 1 account and 1 card), you must specify the account\n    (account_id) or card (card_id) to which you want to transfer the money.\n    \"\"\"\n\n    counterparty_id: Annotated[\n        UUID,\n        Field(description=\"The ID of the receiving counterparty.\"),\n    ]\n    account_id: Annotated[\n        UUID | None,\n        Field(\n            description=\"\"\"\n            The ID of the receiving counterparty's account, which can be own account. \n            Used for bank transfers.\n\n            If the counterparty has multiple payment methods available, use it to \n            specify the account to which you want to send the money.\n            \"\"\",\n        ),\n    ] = None\n    card_id: Annotated[\n        UUID | None,\n        Field(\n            description=\"\"\"\n            The ID of the receiving counterparty's card. Used for card transfers.\n\n            If the counterparty has multiple payment methods available, use it to \n            specify the card to which you want to send the money.\n            \"\"\",\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.post.CreateTransferToAnotherAccount.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceTransfer</code></p> <p>The response model of the request.</p> Source code in <code>pyrevolut/api/transfers/post/create_transfer_to_another_account.py</code> <pre><code>class Response(ResourceTransfer):\n    \"\"\"\n    The response model of the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.post.MoveMoneyBetweenAccounts","title":"<code>MoveMoneyBetweenAccounts</code>","text":"<p>Move money between the Revolut accounts of the business in the same currency.</p> <p>The resulting transaction has the type transfer.</p> Source code in <code>pyrevolut/api/transfers/post/move_money_between_accounts.py</code> <pre><code>class MoveMoneyBetweenAccounts:\n    \"\"\"\n    Move money between the Revolut accounts of the business in the same currency.\n\n    The resulting transaction has the type transfer.\n    \"\"\"\n\n    ROUTE = \"/1.0/transfer\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The body of the request.\n        \"\"\"\n\n        request_id: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                The ID of the request, provided by you. \n                It helps you identify the transaction in your system.\n                To ensure that a transfer is not processed multiple times if \n                there are network or system errors, the same request_id should be used \n                for requests related to the same transfer.\n                \"\"\",\n                max_length=40,\n            ),\n        ]\n        source_account_id: Annotated[\n            UUID,\n            Field(\n                description=\"The ID of the source account that you transfer the funds from.\"\n            ),\n        ]\n        target_account_id: Annotated[\n            UUID,\n            Field(\n                description=\"The ID of the target account that you transfer the funds to.\"\n            ),\n        ]\n        amount: Annotated[\n            float,\n            Field(\n                description=\"The amount of the funds to be transferred.\",\n                gt=0,\n            ),\n        ]\n        currency: Annotated[\n            Currency,\n            Field(description=\"The ISO 4217 currency of the funds to be transferred.\"),\n        ]\n        reference: Annotated[\n            str | None,\n            Field(\n                description=\"\"\"\n                The reference for the funds transfer.\n                \"\"\",\n            ),\n        ] = None\n\n    class Response(ResourceTransfer):\n        \"\"\"\n        The response model of the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.post.MoveMoneyBetweenAccounts.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The body of the request.</p> Source code in <code>pyrevolut/api/transfers/post/move_money_between_accounts.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The body of the request.\n    \"\"\"\n\n    request_id: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            The ID of the request, provided by you. \n            It helps you identify the transaction in your system.\n            To ensure that a transfer is not processed multiple times if \n            there are network or system errors, the same request_id should be used \n            for requests related to the same transfer.\n            \"\"\",\n            max_length=40,\n        ),\n    ]\n    source_account_id: Annotated[\n        UUID,\n        Field(\n            description=\"The ID of the source account that you transfer the funds from.\"\n        ),\n    ]\n    target_account_id: Annotated[\n        UUID,\n        Field(\n            description=\"The ID of the target account that you transfer the funds to.\"\n        ),\n    ]\n    amount: Annotated[\n        float,\n        Field(\n            description=\"The amount of the funds to be transferred.\",\n            gt=0,\n        ),\n    ]\n    currency: Annotated[\n        Currency,\n        Field(description=\"The ISO 4217 currency of the funds to be transferred.\"),\n    ]\n    reference: Annotated[\n        str | None,\n        Field(\n            description=\"\"\"\n            The reference for the funds transfer.\n            \"\"\",\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/transfers/pydantic/#pyrevolut.api.transfers.post.MoveMoneyBetweenAccounts.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceTransfer</code></p> <p>The response model of the request.</p> Source code in <code>pyrevolut/api/transfers/post/move_money_between_accounts.py</code> <pre><code>class Response(ResourceTransfer):\n    \"\"\"\n    The response model of the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/transfers/synchronous/","title":"Transfers Synchronous Endpoints","text":"<p>This <code>Transfers</code> endpoint provides methods to interact with the transfers of the authenticated user.</p> <p>Example usage of the Transfers endpoint object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    reasons = client.Transfers.get_transfer_reasons()\n    print(reasons)\n</code></pre>"},{"location":"code_reference/api/transfers/synchronous/#pyrevolut.api.transfers.endpoint.EndpointTransfersSync","title":"<code>EndpointTransfersSync</code>","text":"<p>               Bases: <code>BaseEndpointSync</code></p> <p>The Transfers API</p> <p>Move funds in the same currency between accounts of your business, or make payments to your counterparties.</p> Source code in <code>pyrevolut/api/transfers/endpoint/synchronous.py</code> <pre><code>class EndpointTransfersSync(BaseEndpointSync):\n    \"\"\"The Transfers API\n\n    Move funds in the same currency between accounts of your business,\n    or make payments to your counterparties.\n    \"\"\"\n\n    def get_transfer_reasons(\n        self,\n        **kwargs,\n    ) -&gt; list[dict] | list[GetTransferReasons.Response]:\n        \"\"\"\n        In order to initiate a transfer in certain currencies and countries,\n        you must provide a transfer reason.\n        With this endpoint you can retrieve all transfer reasons available to your business account\n        per country and currency.\n\n        After you retrieve the results, use the appropriate reason code in the transfer_reason_code\n        field when making a transfer to a counterparty or creating a payout link.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        list[dict] | list[GetTransferReasons.Response]\n            A list of transfer reasons.\n        \"\"\"\n        endpoint = GetTransferReasons\n        path = endpoint.ROUTE\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def create_transfer_to_another_account(\n        self,\n        request_id: str,\n        account_id: UUID,\n        counterparty_id: UUID,\n        amount: float,\n        currency: str,\n        counterparty_account_id: UUID | None = None,\n        counterparty_card_id: UUID | None = None,\n        reference: str | None = None,\n        charge_bearer: EnumChargeBearer | None = None,\n        transfer_reason_code: EnumTransferReasonCode | None = None,\n        **kwargs,\n    ) -&gt; dict | CreateTransferToAnotherAccount.Response:\n        \"\"\"\n        Make a payment to a counterparty.\n        The resulting transaction has the type transfer.\n\n        If you make the payment to another Revolut account, either business or personal,\n        the transaction is executed instantly.\n\n        If the counterparty has multiple payment methods available, for example, 2 accounts,\n        or 1 account and 1 card, you must specify the account or card to which you want to\n        transfer the money (receiver.account_id or receiver.card_id respectively).\n\n        Caution\n        -------\n        Due to PSD2 Strong Customer Authentication regulations, this endpoint is\n        only available for customers on Revolut Business Company plans. If you're a\n        freelancer and wish to make payments via our API, we advise that you instead\n        leverage our Payment drafts (/payment-drafts) endpoint.\n\n        Parameters\n        ----------\n        request_id : str\n            The ID of the request, provided by you.\n            It helps you identify the transaction in your system.\n            To ensure that a transfer is not processed multiple times if\n            there are network or system errors, the same request_id should be used\n            for requests related to the same transfer.\n        account_id : UUID\n            The ID of the account that you transfer the funds from.\n        counterparty_id : UUID\n            The ID of the receiving counterparty.\n        amount : float\n            The amount of money to transfer.\n        currency : str\n            The currency of the transfer.\n        counterparty_account_id : UUID, optional\n            The ID of the receiving counterparty's account, which can be own account.\n            Used for bank transfers.\n            If the counterparty has multiple payment methods available, use it to\n            specify the account to which you want to send the money.\n        counterparty_card_id : UUID, optional\n            The ID of the receiving counterparty's card. Used for card transfers.\n            If the counterparty has multiple payment methods available, use it to\n            specify the card to which you want to send the money.\n        reference : str, optional\n            A reference for the transfer.\n        charge_bearer : EnumChargeBearer, optional\n            The party to which any transaction fees are charged if the resulting\n            transaction route has associated fees. Some transactions with fees might\n            not be possible with the specified option, in which case error 3287 is returned.\n\n            Possible values:\n            - shared: The transaction fees are shared between the sender and the receiver.\n            - debtor: The sender pays the transaction fees.\n        transfer_reason_code : EnumTransferReasonCode, optional\n            The reason code for the transaction.\n            Transactions to certain countries and currencies might require\n            you to provide a transfer reason.\n            You can check available reason codes with the getTransferReasons operation.\n\n            If a transfer reason is not required for the given currency and country,\n            this field is ignored.\n\n        Returns\n        -------\n        dict | CreateTransferToAnotherAccount.Response\n            The details of the transfer.\n        \"\"\"\n        endpoint = CreateTransferToAnotherAccount\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            request_id=request_id,\n            account_id=account_id,\n            receiver=endpoint.Body.ModelReceiver(\n                counterparty_id=counterparty_id,\n                account_id=counterparty_account_id,\n                card_id=counterparty_card_id,\n            ),\n            amount=amount,\n            currency=currency,\n            reference=reference,\n            charge_bearer=charge_bearer,\n            transfer_reason_code=transfer_reason_code,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def move_money_between_accounts(\n        self,\n        request_id: str,\n        source_account_id: UUID,\n        target_account_id: UUID,\n        amount: float,\n        currency: str,\n        reference: str | None = None,\n        **kwargs,\n    ) -&gt; dict | MoveMoneyBetweenAccounts.Response:\n        \"\"\"\n        Move money between the Revolut accounts of the business in the same currency.\n\n        The resulting transaction has the type transfer.\n\n        Parameters\n        ----------\n        request_id : str\n            The ID of the request, provided by you.\n            It helps you identify the transaction in your system.\n            To ensure that a transfer is not processed multiple times if\n            there are network or system errors, the same request_id should be used\n            for requests related to the same transfer.\n        source_account_id : UUID\n            The ID of the source account that you transfer the funds from.\n        target_account_id : UUID\n            The ID of the target account that you transfer the funds to.\n        amount : float\n            The amount of the funds to be transferred.\n        currency : str\n            The ISO 4217 currency of the funds to be transferred.\n        reference : str, optional\n            The reference for the funds transfer.\n\n        Returns\n        -------\n        dict | MoveMoneyBetweenAccounts.Response\n            The details of the transfer.\n        \"\"\"\n        endpoint = MoveMoneyBetweenAccounts\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            request_id=request_id,\n            source_account_id=source_account_id,\n            target_account_id=target_account_id,\n            amount=amount,\n            currency=currency,\n            reference=reference,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/transfers/synchronous/#pyrevolut.api.transfers.endpoint.EndpointTransfersSync.create_transfer_to_another_account","title":"<code>create_transfer_to_another_account(request_id, account_id, counterparty_id, amount, currency, counterparty_account_id=None, counterparty_card_id=None, reference=None, charge_bearer=None, transfer_reason_code=None, **kwargs)</code>","text":"<p>Make a payment to a counterparty. The resulting transaction has the type transfer.</p> <p>If you make the payment to another Revolut account, either business or personal, the transaction is executed instantly.</p> <p>If the counterparty has multiple payment methods available, for example, 2 accounts, or 1 account and 1 card, you must specify the account or card to which you want to transfer the money (receiver.account_id or receiver.card_id respectively).</p> Caution <p>Due to PSD2 Strong Customer Authentication regulations, this endpoint is only available for customers on Revolut Business Company plans. If you're a freelancer and wish to make payments via our API, we advise that you instead leverage our Payment drafts (/payment-drafts) endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>request_id</code> <code>str</code> <p>The ID of the request, provided by you. It helps you identify the transaction in your system. To ensure that a transfer is not processed multiple times if there are network or system errors, the same request_id should be used for requests related to the same transfer.</p> required <code>account_id</code> <code>UUID</code> <p>The ID of the account that you transfer the funds from.</p> required <code>counterparty_id</code> <code>UUID</code> <p>The ID of the receiving counterparty.</p> required <code>amount</code> <code>float</code> <p>The amount of money to transfer.</p> required <code>currency</code> <code>str</code> <p>The currency of the transfer.</p> required <code>counterparty_account_id</code> <code>UUID</code> <p>The ID of the receiving counterparty's account, which can be own account. Used for bank transfers. If the counterparty has multiple payment methods available, use it to specify the account to which you want to send the money.</p> <code>None</code> <code>counterparty_card_id</code> <code>UUID</code> <p>The ID of the receiving counterparty's card. Used for card transfers. If the counterparty has multiple payment methods available, use it to specify the card to which you want to send the money.</p> <code>None</code> <code>reference</code> <code>str</code> <p>A reference for the transfer.</p> <code>None</code> <code>charge_bearer</code> <code>EnumChargeBearer</code> <p>The party to which any transaction fees are charged if the resulting transaction route has associated fees. Some transactions with fees might not be possible with the specified option, in which case error 3287 is returned.</p> <p>Possible values: - shared: The transaction fees are shared between the sender and the receiver. - debtor: The sender pays the transaction fees.</p> <code>None</code> <code>transfer_reason_code</code> <code>EnumTransferReasonCode</code> <p>The reason code for the transaction. Transactions to certain countries and currencies might require you to provide a transfer reason. You can check available reason codes with the getTransferReasons operation.</p> <p>If a transfer reason is not required for the given currency and country, this field is ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The details of the transfer.</p> Source code in <code>pyrevolut/api/transfers/endpoint/synchronous.py</code> <pre><code>def create_transfer_to_another_account(\n    self,\n    request_id: str,\n    account_id: UUID,\n    counterparty_id: UUID,\n    amount: float,\n    currency: str,\n    counterparty_account_id: UUID | None = None,\n    counterparty_card_id: UUID | None = None,\n    reference: str | None = None,\n    charge_bearer: EnumChargeBearer | None = None,\n    transfer_reason_code: EnumTransferReasonCode | None = None,\n    **kwargs,\n) -&gt; dict | CreateTransferToAnotherAccount.Response:\n    \"\"\"\n    Make a payment to a counterparty.\n    The resulting transaction has the type transfer.\n\n    If you make the payment to another Revolut account, either business or personal,\n    the transaction is executed instantly.\n\n    If the counterparty has multiple payment methods available, for example, 2 accounts,\n    or 1 account and 1 card, you must specify the account or card to which you want to\n    transfer the money (receiver.account_id or receiver.card_id respectively).\n\n    Caution\n    -------\n    Due to PSD2 Strong Customer Authentication regulations, this endpoint is\n    only available for customers on Revolut Business Company plans. If you're a\n    freelancer and wish to make payments via our API, we advise that you instead\n    leverage our Payment drafts (/payment-drafts) endpoint.\n\n    Parameters\n    ----------\n    request_id : str\n        The ID of the request, provided by you.\n        It helps you identify the transaction in your system.\n        To ensure that a transfer is not processed multiple times if\n        there are network or system errors, the same request_id should be used\n        for requests related to the same transfer.\n    account_id : UUID\n        The ID of the account that you transfer the funds from.\n    counterparty_id : UUID\n        The ID of the receiving counterparty.\n    amount : float\n        The amount of money to transfer.\n    currency : str\n        The currency of the transfer.\n    counterparty_account_id : UUID, optional\n        The ID of the receiving counterparty's account, which can be own account.\n        Used for bank transfers.\n        If the counterparty has multiple payment methods available, use it to\n        specify the account to which you want to send the money.\n    counterparty_card_id : UUID, optional\n        The ID of the receiving counterparty's card. Used for card transfers.\n        If the counterparty has multiple payment methods available, use it to\n        specify the card to which you want to send the money.\n    reference : str, optional\n        A reference for the transfer.\n    charge_bearer : EnumChargeBearer, optional\n        The party to which any transaction fees are charged if the resulting\n        transaction route has associated fees. Some transactions with fees might\n        not be possible with the specified option, in which case error 3287 is returned.\n\n        Possible values:\n        - shared: The transaction fees are shared between the sender and the receiver.\n        - debtor: The sender pays the transaction fees.\n    transfer_reason_code : EnumTransferReasonCode, optional\n        The reason code for the transaction.\n        Transactions to certain countries and currencies might require\n        you to provide a transfer reason.\n        You can check available reason codes with the getTransferReasons operation.\n\n        If a transfer reason is not required for the given currency and country,\n        this field is ignored.\n\n    Returns\n    -------\n    dict | CreateTransferToAnotherAccount.Response\n        The details of the transfer.\n    \"\"\"\n    endpoint = CreateTransferToAnotherAccount\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        request_id=request_id,\n        account_id=account_id,\n        receiver=endpoint.Body.ModelReceiver(\n            counterparty_id=counterparty_id,\n            account_id=counterparty_account_id,\n            card_id=counterparty_card_id,\n        ),\n        amount=amount,\n        currency=currency,\n        reference=reference,\n        charge_bearer=charge_bearer,\n        transfer_reason_code=transfer_reason_code,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/transfers/synchronous/#pyrevolut.api.transfers.endpoint.EndpointTransfersSync.get_transfer_reasons","title":"<code>get_transfer_reasons(**kwargs)</code>","text":"<p>In order to initiate a transfer in certain currencies and countries, you must provide a transfer reason. With this endpoint you can retrieve all transfer reasons available to your business account per country and currency.</p> <p>After you retrieve the results, use the appropriate reason code in the transfer_reason_code field when making a transfer to a counterparty or creating a payout link.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>A list of transfer reasons.</p> Source code in <code>pyrevolut/api/transfers/endpoint/synchronous.py</code> <pre><code>def get_transfer_reasons(\n    self,\n    **kwargs,\n) -&gt; list[dict] | list[GetTransferReasons.Response]:\n    \"\"\"\n    In order to initiate a transfer in certain currencies and countries,\n    you must provide a transfer reason.\n    With this endpoint you can retrieve all transfer reasons available to your business account\n    per country and currency.\n\n    After you retrieve the results, use the appropriate reason code in the transfer_reason_code\n    field when making a transfer to a counterparty or creating a payout link.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    list[dict] | list[GetTransferReasons.Response]\n        A list of transfer reasons.\n    \"\"\"\n    endpoint = GetTransferReasons\n    path = endpoint.ROUTE\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/transfers/synchronous/#pyrevolut.api.transfers.endpoint.EndpointTransfersSync.move_money_between_accounts","title":"<code>move_money_between_accounts(request_id, source_account_id, target_account_id, amount, currency, reference=None, **kwargs)</code>","text":"<p>Move money between the Revolut accounts of the business in the same currency.</p> <p>The resulting transaction has the type transfer.</p> <p>Parameters:</p> Name Type Description Default <code>request_id</code> <code>str</code> <p>The ID of the request, provided by you. It helps you identify the transaction in your system. To ensure that a transfer is not processed multiple times if there are network or system errors, the same request_id should be used for requests related to the same transfer.</p> required <code>source_account_id</code> <code>UUID</code> <p>The ID of the source account that you transfer the funds from.</p> required <code>target_account_id</code> <code>UUID</code> <p>The ID of the target account that you transfer the funds to.</p> required <code>amount</code> <code>float</code> <p>The amount of the funds to be transferred.</p> required <code>currency</code> <code>str</code> <p>The ISO 4217 currency of the funds to be transferred.</p> required <code>reference</code> <code>str</code> <p>The reference for the funds transfer.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The details of the transfer.</p> Source code in <code>pyrevolut/api/transfers/endpoint/synchronous.py</code> <pre><code>def move_money_between_accounts(\n    self,\n    request_id: str,\n    source_account_id: UUID,\n    target_account_id: UUID,\n    amount: float,\n    currency: str,\n    reference: str | None = None,\n    **kwargs,\n) -&gt; dict | MoveMoneyBetweenAccounts.Response:\n    \"\"\"\n    Move money between the Revolut accounts of the business in the same currency.\n\n    The resulting transaction has the type transfer.\n\n    Parameters\n    ----------\n    request_id : str\n        The ID of the request, provided by you.\n        It helps you identify the transaction in your system.\n        To ensure that a transfer is not processed multiple times if\n        there are network or system errors, the same request_id should be used\n        for requests related to the same transfer.\n    source_account_id : UUID\n        The ID of the source account that you transfer the funds from.\n    target_account_id : UUID\n        The ID of the target account that you transfer the funds to.\n    amount : float\n        The amount of the funds to be transferred.\n    currency : str\n        The ISO 4217 currency of the funds to be transferred.\n    reference : str, optional\n        The reference for the funds transfer.\n\n    Returns\n    -------\n    dict | MoveMoneyBetweenAccounts.Response\n        The details of the transfer.\n    \"\"\"\n    endpoint = MoveMoneyBetweenAccounts\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        request_id=request_id,\n        source_account_id=source_account_id,\n        target_account_id=target_account_id,\n        amount=amount,\n        currency=currency,\n        reference=reference,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/asynchronous/","title":"Webhooks Asynchronous Endpoints","text":"<p>This <code>Webhooks</code> endpoint provides asynchronous methods to interact with the webhooks of the authenticated user.</p> <p>Example usage of the Webhooks endpoint object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n    async with client:\n        webhooks = await client.Webhooks.get_all_webhooks()\n        print(webhooks)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/api/webhooks/asynchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync","title":"<code>EndpointWebhooksSync</code>","text":"<p>               Bases: <code>BaseEndpointWebhooks</code></p> <p>The Webhooks API</p> <p>A webhook (also called a web callback) allows your system to receive updates about your account to an HTTPS endpoint that you provide. When a supported event occurs, a notification is posted via HTTP POST method to the specified endpoint.</p> <p>If the receiver returns an HTTP error response, Revolut will retry the webhook event three more times, each with a 10-minute interval.</p> <p>The following events are supported:</p> <p>TransactionCreated TransactionStateChanged PayoutLinkCreated PayoutLinkStateChanged</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>class EndpointWebhooksSync(BaseEndpointWebhooks):\n    \"\"\"The Webhooks API\n\n    A webhook (also called a web callback) allows your system to receive\n    updates about your account to an HTTPS endpoint that you provide.\n    When a supported event occurs, a notification is posted via HTTP POST method\n    to the specified endpoint.\n\n    If the receiver returns an HTTP error response, Revolut will retry the webhook\n    event three more times, each with a 10-minute interval.\n\n    The following events are supported:\n\n    TransactionCreated\n    TransactionStateChanged\n    PayoutLinkCreated\n    PayoutLinkStateChanged\n    \"\"\"\n\n    def get_all_webhooks(\n        self,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfWebhooks.Response]:\n        \"\"\"\n        Get the list of all your existing webhooks and their details.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfWebhooks.Response]\n            The list of all your existing webhooks and their details.\n        \"\"\"\n        endpoint = RetrieveListOfWebhooks\n        path = endpoint.ROUTE\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_webhook(\n        self,\n        webhook_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveWebhook.Response:\n        \"\"\"\n        Get the information about a specific webhook by ID.\n\n        Parameters\n        ----------\n        webhook_id : UUID\n            The ID of the webhook.\n\n        Returns\n        -------\n        dict | RetrieveWebhook.Response\n            The information about the webhook.\n        \"\"\"\n        endpoint = RetrieveWebhook\n        path = endpoint.ROUTE.format(webhook_id=webhook_id)\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_failed_webhook_events(\n        self,\n        webhook_id: UUID,\n        limit: int | None = None,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfFailedWebhooks.Response]:\n        \"\"\"\n        Get the list of all your failed webhook events, or use the query\n        parameters to filter the results.\n\n        The events are sorted by the created_at date in reverse chronological order.\n\n        The returned failed events are paginated. The maximum number of events returned\n        per page is specified by the limit parameter.\n        To get to the next page, make a new request and use the created_at date of the\n        last event returned in the previous response.\n\n        Parameters\n        ----------\n        webhook_id : UUID\n            The ID of the webhook.\n        limit : int, optional\n            The maximum number of events returned per page.\n            To get to the next page, make a new request and use the created_at date of\n            the last event returned in the previous response as value for created_before.\n            If not specified, the default value is 100.\n        created_before : datetime | DateTime | str | int | float, optional\n            Retrieves events with created_at &lt; created_before.\n            Cannot be older than the current date minus 21 days.\n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfFailedWebhooks.Response]\n            The list of all your failed webhook events.\n        \"\"\"\n        endpoint = RetrieveListOfFailedWebhooks\n        path = endpoint.ROUTE.format(webhook_id=webhook_id)\n        params = endpoint.Params(\n            limit=limit,\n            created_before=created_before,\n        )\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def create_webhook(\n        self,\n        url: str,\n        events: list[EnumWebhookEvent] | None = None,\n        **kwargs,\n    ) -&gt; dict | CreateWebhook.Response:\n        \"\"\"\n        Create a new webhook to receive event notifications to the specified URL.\n        Provide a list of event types that you want to subscribe to and a URL for the webhook.\n        Only HTTPS URLs are supported.\n\n        Parameters\n        ----------\n        url : str\n            A valid webhook URL to which to send event notifications.\n            The supported protocol is https.\n        events : list[EnumWebhookEvent], optional\n            A list of event types to subscribe to.\n            If you don't provide it, you're automatically subscribed to the default event types:\n            - TransactionCreated\n            - TransactionStateChanged\n\n        Returns\n        -------\n        dict | CreateWebhook.Response\n            The response model for the request.\n        \"\"\"\n        endpoint = CreateWebhook\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            url=url,\n            events=events,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def rotate_webhook_secret(\n        self,\n        webhook_id: UUID,\n        expiration_period: Duration | None = None,\n        **kwargs,\n    ) -&gt; dict | RotateWebhookSecret.Response:\n        \"\"\"\n        Rotate a signing secret for a specific webhook.\n\n        Parameters\n        ----------\n        webhook_id : UUID\n            The ID of the webhook.\n        expiration_period : Duration, optional\n            The expiration period for the signing secret in ISO 8601 format.\n            If set, when you rotate the secret, it continues to be valid until the\n            expiration period has passed.\n            Otherwise, on rotation, the secret is invalidated immediately.\n            The maximum value is 7 days.\n\n        Returns\n        -------\n        dict | RotateWebhookSecret.Response\n            The response model for the request.\n        \"\"\"\n        endpoint = RotateWebhookSecret\n        path = endpoint.ROUTE.format(webhook_id=webhook_id)\n        body = endpoint.Body(\n            expiration_period=expiration_period,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def update_webhook(\n        self,\n        webhook_id: UUID,\n        url: str | None = None,\n        events: list[EnumWebhookEvent] | None = None,\n        **kwargs,\n    ) -&gt; dict | UpdateWebhook.Response:\n        \"\"\"\n        Update an existing webhook. Change the URL to which event notifications are\n        sent or the list of event types to be notified about.\n\n        You must specify at least one of these two.\n        The fields that you don't specify are not updated.\n\n        Parameters\n        ----------\n        webhook_id : UUID\n            The ID of the webhook.\n        url : str, optional\n            A valid webhook URL to which to send event notifications.\n            The supported protocol is https.\n        events : list[EnumWebhookEvent], optional\n            A list of event types to subscribe to.\n\n        Returns\n        -------\n        dict | UpdateWebhook.Response\n            The response model for the request.\n        \"\"\"\n        endpoint = UpdateWebhook\n        path = endpoint.ROUTE.format(webhook_id=webhook_id)\n        body = endpoint.Body(\n            url=url,\n            events=events,\n        )\n\n        return self.client.patch(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def delete_webhook(\n        self,\n        webhook_id: UUID,\n        **kwargs,\n    ) -&gt; dict | DeleteWebhook.Response:\n        \"\"\"\n        Delete a specific webhook.\n\n        A successful response does not get any content in return.\n\n        Parameters\n        ----------\n        webhook_id : UUID\n            The ID of the webhook.\n\n        Returns\n        -------\n        dict | DeleteWebhook.Response\n            An empty dictionary.\n        \"\"\"\n        endpoint = DeleteWebhook\n        path = endpoint.ROUTE.format(webhook_id=webhook_id)\n        params = endpoint.Params()\n\n        return self.client.delete(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/webhooks/asynchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.create_webhook","title":"<code>create_webhook(url, events=None, **kwargs)</code>","text":"<p>Create a new webhook to receive event notifications to the specified URL. Provide a list of event types that you want to subscribe to and a URL for the webhook. Only HTTPS URLs are supported.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A valid webhook URL to which to send event notifications. The supported protocol is https.</p> required <code>events</code> <code>list[EnumWebhookEvent]</code> <p>A list of event types to subscribe to. If you don't provide it, you're automatically subscribed to the default event types: - TransactionCreated - TransactionStateChanged</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def create_webhook(\n    self,\n    url: str,\n    events: list[EnumWebhookEvent] | None = None,\n    **kwargs,\n) -&gt; dict | CreateWebhook.Response:\n    \"\"\"\n    Create a new webhook to receive event notifications to the specified URL.\n    Provide a list of event types that you want to subscribe to and a URL for the webhook.\n    Only HTTPS URLs are supported.\n\n    Parameters\n    ----------\n    url : str\n        A valid webhook URL to which to send event notifications.\n        The supported protocol is https.\n    events : list[EnumWebhookEvent], optional\n        A list of event types to subscribe to.\n        If you don't provide it, you're automatically subscribed to the default event types:\n        - TransactionCreated\n        - TransactionStateChanged\n\n    Returns\n    -------\n    dict | CreateWebhook.Response\n        The response model for the request.\n    \"\"\"\n    endpoint = CreateWebhook\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        url=url,\n        events=events,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/asynchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.delete_webhook","title":"<code>delete_webhook(webhook_id, **kwargs)</code>","text":"<p>Delete a specific webhook.</p> <p>A successful response does not get any content in return.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>UUID</code> <p>The ID of the webhook.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dictionary.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def delete_webhook(\n    self,\n    webhook_id: UUID,\n    **kwargs,\n) -&gt; dict | DeleteWebhook.Response:\n    \"\"\"\n    Delete a specific webhook.\n\n    A successful response does not get any content in return.\n\n    Parameters\n    ----------\n    webhook_id : UUID\n        The ID of the webhook.\n\n    Returns\n    -------\n    dict | DeleteWebhook.Response\n        An empty dictionary.\n    \"\"\"\n    endpoint = DeleteWebhook\n    path = endpoint.ROUTE.format(webhook_id=webhook_id)\n    params = endpoint.Params()\n\n    return self.client.delete(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/asynchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.get_all_webhooks","title":"<code>get_all_webhooks(**kwargs)</code>","text":"<p>Get the list of all your existing webhooks and their details.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all your existing webhooks and their details.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def get_all_webhooks(\n    self,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfWebhooks.Response]:\n    \"\"\"\n    Get the list of all your existing webhooks and their details.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfWebhooks.Response]\n        The list of all your existing webhooks and their details.\n    \"\"\"\n    endpoint = RetrieveListOfWebhooks\n    path = endpoint.ROUTE\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/asynchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.get_failed_webhook_events","title":"<code>get_failed_webhook_events(webhook_id, limit=None, created_before=None, **kwargs)</code>","text":"<p>Get the list of all your failed webhook events, or use the query parameters to filter the results.</p> <p>The events are sorted by the created_at date in reverse chronological order.</p> <p>The returned failed events are paginated. The maximum number of events returned per page is specified by the limit parameter. To get to the next page, make a new request and use the created_at date of the last event returned in the previous response.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>UUID</code> <p>The ID of the webhook.</p> required <code>limit</code> <code>int</code> <p>The maximum number of events returned per page. To get to the next page, make a new request and use the created_at date of the last event returned in the previous response as value for created_before. If not specified, the default value is 100.</p> <code>None</code> <code>created_before</code> <code>datetime | DateTime | str | int | float</code> <p>Retrieves events with created_at &lt; created_before. Cannot be older than the current date minus 21 days. The default value is the current date and time at which you are calling the endpoint. Provided in ISO 8601 format.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all your failed webhook events.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def get_failed_webhook_events(\n    self,\n    webhook_id: UUID,\n    limit: int | None = None,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfFailedWebhooks.Response]:\n    \"\"\"\n    Get the list of all your failed webhook events, or use the query\n    parameters to filter the results.\n\n    The events are sorted by the created_at date in reverse chronological order.\n\n    The returned failed events are paginated. The maximum number of events returned\n    per page is specified by the limit parameter.\n    To get to the next page, make a new request and use the created_at date of the\n    last event returned in the previous response.\n\n    Parameters\n    ----------\n    webhook_id : UUID\n        The ID of the webhook.\n    limit : int, optional\n        The maximum number of events returned per page.\n        To get to the next page, make a new request and use the created_at date of\n        the last event returned in the previous response as value for created_before.\n        If not specified, the default value is 100.\n    created_before : datetime | DateTime | str | int | float, optional\n        Retrieves events with created_at &lt; created_before.\n        Cannot be older than the current date minus 21 days.\n        The default value is the current date and time at which you are calling the endpoint.\n        Provided in ISO 8601 format.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfFailedWebhooks.Response]\n        The list of all your failed webhook events.\n    \"\"\"\n    endpoint = RetrieveListOfFailedWebhooks\n    path = endpoint.ROUTE.format(webhook_id=webhook_id)\n    params = endpoint.Params(\n        limit=limit,\n        created_before=created_before,\n    )\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/asynchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.get_webhook","title":"<code>get_webhook(webhook_id, **kwargs)</code>","text":"<p>Get the information about a specific webhook by ID.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>UUID</code> <p>The ID of the webhook.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The information about the webhook.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def get_webhook(\n    self,\n    webhook_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveWebhook.Response:\n    \"\"\"\n    Get the information about a specific webhook by ID.\n\n    Parameters\n    ----------\n    webhook_id : UUID\n        The ID of the webhook.\n\n    Returns\n    -------\n    dict | RetrieveWebhook.Response\n        The information about the webhook.\n    \"\"\"\n    endpoint = RetrieveWebhook\n    path = endpoint.ROUTE.format(webhook_id=webhook_id)\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/asynchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.rotate_webhook_secret","title":"<code>rotate_webhook_secret(webhook_id, expiration_period=None, **kwargs)</code>","text":"<p>Rotate a signing secret for a specific webhook.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>UUID</code> <p>The ID of the webhook.</p> required <code>expiration_period</code> <code>Duration</code> <p>The expiration period for the signing secret in ISO 8601 format. If set, when you rotate the secret, it continues to be valid until the expiration period has passed. Otherwise, on rotation, the secret is invalidated immediately. The maximum value is 7 days.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def rotate_webhook_secret(\n    self,\n    webhook_id: UUID,\n    expiration_period: Duration | None = None,\n    **kwargs,\n) -&gt; dict | RotateWebhookSecret.Response:\n    \"\"\"\n    Rotate a signing secret for a specific webhook.\n\n    Parameters\n    ----------\n    webhook_id : UUID\n        The ID of the webhook.\n    expiration_period : Duration, optional\n        The expiration period for the signing secret in ISO 8601 format.\n        If set, when you rotate the secret, it continues to be valid until the\n        expiration period has passed.\n        Otherwise, on rotation, the secret is invalidated immediately.\n        The maximum value is 7 days.\n\n    Returns\n    -------\n    dict | RotateWebhookSecret.Response\n        The response model for the request.\n    \"\"\"\n    endpoint = RotateWebhookSecret\n    path = endpoint.ROUTE.format(webhook_id=webhook_id)\n    body = endpoint.Body(\n        expiration_period=expiration_period,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/asynchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.update_webhook","title":"<code>update_webhook(webhook_id, url=None, events=None, **kwargs)</code>","text":"<p>Update an existing webhook. Change the URL to which event notifications are sent or the list of event types to be notified about.</p> <p>You must specify at least one of these two. The fields that you don't specify are not updated.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>UUID</code> <p>The ID of the webhook.</p> required <code>url</code> <code>str</code> <p>A valid webhook URL to which to send event notifications. The supported protocol is https.</p> <code>None</code> <code>events</code> <code>list[EnumWebhookEvent]</code> <p>A list of event types to subscribe to.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def update_webhook(\n    self,\n    webhook_id: UUID,\n    url: str | None = None,\n    events: list[EnumWebhookEvent] | None = None,\n    **kwargs,\n) -&gt; dict | UpdateWebhook.Response:\n    \"\"\"\n    Update an existing webhook. Change the URL to which event notifications are\n    sent or the list of event types to be notified about.\n\n    You must specify at least one of these two.\n    The fields that you don't specify are not updated.\n\n    Parameters\n    ----------\n    webhook_id : UUID\n        The ID of the webhook.\n    url : str, optional\n        A valid webhook URL to which to send event notifications.\n        The supported protocol is https.\n    events : list[EnumWebhookEvent], optional\n        A list of event types to subscribe to.\n\n    Returns\n    -------\n    dict | UpdateWebhook.Response\n        The response model for the request.\n    \"\"\"\n    endpoint = UpdateWebhook\n    path = endpoint.ROUTE.format(webhook_id=webhook_id)\n    body = endpoint.Body(\n        url=url,\n        events=events,\n    )\n\n    return self.client.patch(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/","title":"Webhooks Pydantic Models","text":"<p>In order to simplify and standardize the data that is passed between the client and the Revolut Business API, PyRevolut uses Pydantic models to define the structure of the data. Below are the Pydantic models used by the <code>Webhooks</code> endpoint.</p>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.resources.ResourceWebhook","title":"<code>ResourceWebhook</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Webhook resource model.</p> Source code in <code>pyrevolut/api/webhooks/resources/webhook.py</code> <pre><code>class ResourceWebhook(BaseModel):\n    \"\"\"\n    Webhook resource model.\n    \"\"\"\n\n    id: Annotated[UUID, Field(description=\"The ID of the webhook.\")]\n    url: Annotated[\n        HttpUrl,\n        Field(\n            description=\"The valid webhook URL that event notifications are sent to. The supported protocol is https.\"\n        ),\n    ]\n    events: Annotated[\n        list[EnumWebhookEvent],\n        Field(description=\"The list of events that the webhook is subscribed to.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.resources.ResourcePayoutLinkCreated","title":"<code>ResourcePayoutLinkCreated</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Payout Link Created resource model.</p> Source code in <code>pyrevolut/api/webhooks/resources/payout_link_created.py</code> <pre><code>class ResourcePayoutLinkCreated(BaseModel):\n    \"\"\"\n    Payout Link Created resource model.\n    \"\"\"\n\n    id: Annotated[\n        UUID,\n        Field(description=\"The ID of the payout link.\"),\n    ]\n    state: Annotated[\n        EnumPayoutLinkState,\n        Field(description=\"The state of the payout link.\"),\n    ]\n    request_id: Annotated[\n        str | None,\n        Field(description=\"The request ID provided by the client.\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.resources.ResourcePayoutLinkStateChanged","title":"<code>ResourcePayoutLinkStateChanged</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Payout Link State Changed resource model.</p> Source code in <code>pyrevolut/api/webhooks/resources/payout_link_state_changed.py</code> <pre><code>class ResourcePayoutLinkStateChanged(BaseModel):\n    \"\"\"\n    Payout Link State Changed resource model.\n    \"\"\"\n\n    id: Annotated[\n        UUID,\n        Field(description=\"The ID of the payout link.\"),\n    ]\n    request_id: Annotated[\n        str | None,\n        Field(description=\"The request ID provided by the client.\"),\n    ] = None\n    old_state: Annotated[\n        EnumPayoutLinkState,\n        Field(description=\"The previous state of the payout link.\"),\n    ]\n    new_state: Annotated[\n        EnumPayoutLinkState,\n        Field(description=\"The new state of the payout link.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.resources.ResourceTransactionCreated","title":"<code>ResourceTransactionCreated</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Transaction Created resource model.</p> Source code in <code>pyrevolut/api/webhooks/resources/transaction_created.py</code> <pre><code>class ResourceTransactionCreated(BaseModel):\n    \"\"\"\n    Transaction Created resource model.\n    \"\"\"\n\n    class ModelLeg(BaseModel):\n        \"\"\"\n        The legs of the transaction:\n\n            - For transactions between your Revolut accounts,\n            there can be 2 legs, for example, an internal transfer made out of\n            the GBP account and into the EUR account.\n\n            - For transactions in other cases, there is only 1 leg.\n        \"\"\"\n\n        class ModelCounterparty(BaseModel):\n            \"\"\"The counterparty of the transaction.\"\"\"\n\n            account_id: Annotated[\n                UUID | None,\n                Field(description=\"The ID of the counterparty account.\"),\n            ] = None\n            account_type: Annotated[\n                EnumAccountType,\n                Field(description=\"Indicates the type of the account.\"),\n            ]\n            id: Annotated[\n                UUID | None,\n                Field(description=\"The ID of the counterparty.\"),\n            ] = None\n\n        leg_id: Annotated[UUID, Field(description=\"The ID of the leg.\")]\n        account_id: Annotated[\n            UUID,\n            Field(\n                description=\"The ID of the account that the transaction leg is associated with.\"\n            ),\n        ]\n        counterparty: Annotated[\n            ModelCounterparty | None,\n            Field(description=\"The counterparty of the transaction leg.\"),\n        ] = None\n        amount: Annotated[\n            float,\n            Field(description=\"The amount of the transaction leg.\"),\n        ]\n        fee: Annotated[\n            float | None,\n            Field(description=\"The amount of the transaction leg fee.\"),\n        ] = None\n        currency: Annotated[\n            Currency,\n            Field(description=\"ISO 4217 currency code in upper case.\"),\n        ]\n        bill_amount: Annotated[\n            float | None,\n            Field(description=\"The billing amount for cross-currency payments.\"),\n        ] = None\n        bill_currency: Annotated[\n            Currency | None,\n            Field(description=\"The billing currency for cross-currency payments.\"),\n        ] = None\n        description: Annotated[\n            str | None,\n            Field(description=\"The transaction leg purpose.\"),\n        ] = None\n        balance: Annotated[\n            float | None,\n            Field(\n                description=\"The total balance of the account that the transaction is associated with.\"\n            ),\n        ] = None\n\n    id: Annotated[UUID, Field(description=\"The ID of the transaction.\")]\n    type: Annotated[\n        EnumTransactionType, Field(description=\"Indicates the transaction type.\")\n    ]\n    state: Annotated[\n        EnumTransactionState, Field(description=\"Indicates the transaction state.\")\n    ]\n    request_id: Annotated[\n        str | None,\n        Field(\n            description=\"The request ID that you provided previously.\",\n        ),\n    ] = None\n    reason_code: Annotated[\n        str | None,\n        Field(\n            description=\"The reason code when the transaction state is declined or failed.\"\n        ),\n    ] = None\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the transaction was created in ISO 8601 format.\"\n        ),\n    ]\n    updated_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the transaction was last updated in ISO 8601 format.\"\n        ),\n    ]\n    completed_at: Annotated[\n        DateTime | None,\n        Field(\n            description=\"\"\"\n            The date and time the transaction was completed in ISO 8601 format. \n            This is required when the transaction state is completed.\n            \"\"\"\n        ),\n    ] = None\n    scheduled_for: Annotated[\n        Date | None,\n        Field(\n            description=\"\"\"\n            The scheduled date of the payment, if applicable. Provided in ISO 8601 format.\n            \"\"\"\n        ),\n    ] = None\n    reference: Annotated[\n        str | None,\n        Field(description=\"The reference of the transaction.\"),\n    ] = None\n    related_transaction_id: Annotated[\n        UUID | None,\n        Field(description=\"The ID of the original transaction that has been refunded.\"),\n    ] = None\n    legs: Annotated[\n        list[ModelLeg],\n        Field(\n            description=\"The legs of a transaction. There are 2 legs between your Revolut accounts and 1 leg in other cases.\"\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.resources.ResourceTransactionCreated.ModelLeg","title":"<code>ModelLeg</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The legs of the transaction:</p> <pre><code>- For transactions between your Revolut accounts,\nthere can be 2 legs, for example, an internal transfer made out of\nthe GBP account and into the EUR account.\n\n- For transactions in other cases, there is only 1 leg.\n</code></pre> Source code in <code>pyrevolut/api/webhooks/resources/transaction_created.py</code> <pre><code>class ModelLeg(BaseModel):\n    \"\"\"\n    The legs of the transaction:\n\n        - For transactions between your Revolut accounts,\n        there can be 2 legs, for example, an internal transfer made out of\n        the GBP account and into the EUR account.\n\n        - For transactions in other cases, there is only 1 leg.\n    \"\"\"\n\n    class ModelCounterparty(BaseModel):\n        \"\"\"The counterparty of the transaction.\"\"\"\n\n        account_id: Annotated[\n            UUID | None,\n            Field(description=\"The ID of the counterparty account.\"),\n        ] = None\n        account_type: Annotated[\n            EnumAccountType,\n            Field(description=\"Indicates the type of the account.\"),\n        ]\n        id: Annotated[\n            UUID | None,\n            Field(description=\"The ID of the counterparty.\"),\n        ] = None\n\n    leg_id: Annotated[UUID, Field(description=\"The ID of the leg.\")]\n    account_id: Annotated[\n        UUID,\n        Field(\n            description=\"The ID of the account that the transaction leg is associated with.\"\n        ),\n    ]\n    counterparty: Annotated[\n        ModelCounterparty | None,\n        Field(description=\"The counterparty of the transaction leg.\"),\n    ] = None\n    amount: Annotated[\n        float,\n        Field(description=\"The amount of the transaction leg.\"),\n    ]\n    fee: Annotated[\n        float | None,\n        Field(description=\"The amount of the transaction leg fee.\"),\n    ] = None\n    currency: Annotated[\n        Currency,\n        Field(description=\"ISO 4217 currency code in upper case.\"),\n    ]\n    bill_amount: Annotated[\n        float | None,\n        Field(description=\"The billing amount for cross-currency payments.\"),\n    ] = None\n    bill_currency: Annotated[\n        Currency | None,\n        Field(description=\"The billing currency for cross-currency payments.\"),\n    ] = None\n    description: Annotated[\n        str | None,\n        Field(description=\"The transaction leg purpose.\"),\n    ] = None\n    balance: Annotated[\n        float | None,\n        Field(\n            description=\"The total balance of the account that the transaction is associated with.\"\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.resources.ResourceTransactionCreated.ModelLeg.ModelCounterparty","title":"<code>ModelCounterparty</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The counterparty of the transaction.</p> Source code in <code>pyrevolut/api/webhooks/resources/transaction_created.py</code> <pre><code>class ModelCounterparty(BaseModel):\n    \"\"\"The counterparty of the transaction.\"\"\"\n\n    account_id: Annotated[\n        UUID | None,\n        Field(description=\"The ID of the counterparty account.\"),\n    ] = None\n    account_type: Annotated[\n        EnumAccountType,\n        Field(description=\"Indicates the type of the account.\"),\n    ]\n    id: Annotated[\n        UUID | None,\n        Field(description=\"The ID of the counterparty.\"),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.resources.ResourceTransactionStateChanged","title":"<code>ResourceTransactionStateChanged</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Transaction state changed resource model.</p> Source code in <code>pyrevolut/api/webhooks/resources/transaction_state_changed.py</code> <pre><code>class ResourceTransactionStateChanged(BaseModel):\n    \"\"\"\n    Transaction state changed resource model.\n    \"\"\"\n\n    id: Annotated[\n        UUID,\n        Field(description=\"The ID of the transaction.\"),\n    ]\n    request_id: Annotated[\n        str | None,\n        Field(description=\"The request ID provided by the client.\"),\n    ] = None\n    old_state: Annotated[\n        EnumTransactionState,\n        Field(description=\"The old state of the transaction.\"),\n    ]\n    new_state: Annotated[\n        EnumTransactionState,\n        Field(description=\"The new state of the transaction.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.resources.ResourceWebhookPayload","title":"<code>ResourceWebhookPayload</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Webhook payload resource model.</p> Source code in <code>pyrevolut/api/webhooks/resources/webhook_payload.py</code> <pre><code>class ResourceWebhookPayload(BaseModel):\n    \"\"\"\n    Webhook payload resource model.\n    \"\"\"\n\n    event: Annotated[\n        EnumWebhookEvent,\n        Field(description=\"The event type.\"),\n    ]\n    timestamp: Annotated[\n        DateTime,\n        Field(description=\"The event time.\"),\n    ]\n    data: Annotated[\n        ResourcePayoutLinkCreated\n        | ResourcePayoutLinkStateChanged\n        | ResourceTransactionCreated\n        | ResourceTransactionStateChanged,\n        Field(description=\"The event data.\"),\n    ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.get.RetrieveListOfWebhooks","title":"<code>RetrieveListOfWebhooks</code>","text":"<p>Get the list of all your existing webhooks and their details.</p> Source code in <code>pyrevolut/api/webhooks/get/retrieve_list_of_webhooks.py</code> <pre><code>class RetrieveListOfWebhooks:\n    \"\"\"\n    Get the list of all your existing webhooks and their details.\n    \"\"\"\n\n    ROUTE = \"/2.0/webhooks\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The query parameters for the request.\n        \"\"\"\n\n        pass\n\n    class Response(ResourceWebhook):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.get.RetrieveListOfWebhooks.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The query parameters for the request.</p> Source code in <code>pyrevolut/api/webhooks/get/retrieve_list_of_webhooks.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The query parameters for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.get.RetrieveListOfWebhooks.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceWebhook</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/get/retrieve_list_of_webhooks.py</code> <pre><code>class Response(ResourceWebhook):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.get.RetrieveWebhook","title":"<code>RetrieveWebhook</code>","text":"<p>Get the information about a specific webhook by ID.</p> Source code in <code>pyrevolut/api/webhooks/get/retrieve_webhook.py</code> <pre><code>class RetrieveWebhook:\n    \"\"\"\n    Get the information about a specific webhook by ID.\n    \"\"\"\n\n    ROUTE = \"/2.0/webhooks/{webhook_id}\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The query parameters for the request.\n        \"\"\"\n\n        pass\n\n    class Response(ResourceWebhook):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        signing_secret: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                The signing secret for the webhook.\n                \"\"\",\n            ),\n        ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.get.RetrieveWebhook.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The query parameters for the request.</p> Source code in <code>pyrevolut/api/webhooks/get/retrieve_webhook.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The query parameters for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.get.RetrieveWebhook.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceWebhook</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/get/retrieve_webhook.py</code> <pre><code>class Response(ResourceWebhook):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    signing_secret: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            The signing secret for the webhook.\n            \"\"\",\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.get.RetrieveListOfFailedWebhooks","title":"<code>RetrieveListOfFailedWebhooks</code>","text":"<p>Get the list of all your failed webhook events, or use the query parameters to filter the results.</p> <p>The events are sorted by the created_at date in reverse chronological order.</p> <p>The returned failed events are paginated. The maximum number of events returned per page is specified by the limit parameter. To get to the next page, make a new request and use the created_at date of the last event returned in the previous response.</p> Source code in <code>pyrevolut/api/webhooks/get/retrieve_list_of_failed_webhooks.py</code> <pre><code>class RetrieveListOfFailedWebhooks:\n    \"\"\"\n    Get the list of all your failed webhook events, or use the query\n    parameters to filter the results.\n\n    The events are sorted by the created_at date in reverse chronological order.\n\n    The returned failed events are paginated. The maximum number of events returned\n    per page is specified by the limit parameter.\n    To get to the next page, make a new request and use the created_at date of the\n    last event returned in the previous response.\n    \"\"\"\n\n    ROUTE = \"/2.0/webhooks/{webhook_id}/failed-events\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The query parameters for the request.\n        \"\"\"\n\n        limit: Annotated[\n            int | None,\n            Field(\n                description=\"\"\"\n                The maximum number of events returned per page.\n\n                To get to the next page, make a new request and use the created_at date of \n                the last event returned in the previous response as value for created_before.\n\n                If not specified, the default value is 100.\n                \"\"\",\n                ge=1,\n                le=1000,\n            ),\n        ] = None\n        created_before: Annotated[\n            DateTime | None,\n            Field(\n                description=\"\"\"\n                Retrieves events with created_at &lt; created_before. \n                Cannot be older than the current date minus 21 days. \n                The default value is the current date and time at which you are calling the endpoint.\n\n                Provided in ISO 8601 format.\n                \"\"\",\n            ),\n        ] = None\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        id: Annotated[UUID, Field(description=\"The ID of the webhook event.\")]\n        created_at: Annotated[\n            DateTime,\n            Field(\n                description=\"The date and time the event was created in ISO 8601 format.\",\n            ),\n        ]\n        updated_at: Annotated[\n            DateTime,\n            Field(\n                description=\"The date and time the event was last updated in ISO 8601 format.\",\n            ),\n        ]\n        webhook_id: Annotated[\n            UUID,\n            Field(description=\"The ID of the webhook for which the event failed.\"),\n        ]\n        webhook_url: Annotated[\n            HttpUrl,\n            Field(\n                description=\"The valid webhook URL that event notifications are sent to. The supported protocol is https\",\n            ),\n        ]\n        payload: Annotated[\n            ResourceWebhookPayload,\n            Field(description=\"The details of the failed event.\"),\n        ]\n        last_sent_date: Annotated[\n            DateTime,\n            Field(\n                description=\"The date and time the last attempt at the event delivery occurred in ISO 8601 format.\",\n            ),\n        ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.get.RetrieveListOfFailedWebhooks.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The query parameters for the request.</p> Source code in <code>pyrevolut/api/webhooks/get/retrieve_list_of_failed_webhooks.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The query parameters for the request.\n    \"\"\"\n\n    limit: Annotated[\n        int | None,\n        Field(\n            description=\"\"\"\n            The maximum number of events returned per page.\n\n            To get to the next page, make a new request and use the created_at date of \n            the last event returned in the previous response as value for created_before.\n\n            If not specified, the default value is 100.\n            \"\"\",\n            ge=1,\n            le=1000,\n        ),\n    ] = None\n    created_before: Annotated[\n        DateTime | None,\n        Field(\n            description=\"\"\"\n            Retrieves events with created_at &lt; created_before. \n            Cannot be older than the current date minus 21 days. \n            The default value is the current date and time at which you are calling the endpoint.\n\n            Provided in ISO 8601 format.\n            \"\"\",\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.get.RetrieveListOfFailedWebhooks.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/get/retrieve_list_of_failed_webhooks.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    id: Annotated[UUID, Field(description=\"The ID of the webhook event.\")]\n    created_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the event was created in ISO 8601 format.\",\n        ),\n    ]\n    updated_at: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the event was last updated in ISO 8601 format.\",\n        ),\n    ]\n    webhook_id: Annotated[\n        UUID,\n        Field(description=\"The ID of the webhook for which the event failed.\"),\n    ]\n    webhook_url: Annotated[\n        HttpUrl,\n        Field(\n            description=\"The valid webhook URL that event notifications are sent to. The supported protocol is https\",\n        ),\n    ]\n    payload: Annotated[\n        ResourceWebhookPayload,\n        Field(description=\"The details of the failed event.\"),\n    ]\n    last_sent_date: Annotated[\n        DateTime,\n        Field(\n            description=\"The date and time the last attempt at the event delivery occurred in ISO 8601 format.\",\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.post.CreateWebhook","title":"<code>CreateWebhook</code>","text":"<p>Create a new webhook to receive event notifications to the specified URL. Provide a list of event types that you want to subscribe to and a URL for the webhook. Only HTTPS URLs are supported.</p> Source code in <code>pyrevolut/api/webhooks/post/create_webhook.py</code> <pre><code>class CreateWebhook:\n    \"\"\"\n    Create a new webhook to receive event notifications to the specified URL.\n    Provide a list of event types that you want to subscribe to and a URL for the webhook.\n    Only HTTPS URLs are supported.\n    \"\"\"\n\n    ROUTE = \"/2.0/webhooks\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The body of the request.\n        \"\"\"\n\n        url: Annotated[\n            HttpUrl,\n            Field(\n                description=\"\"\"\n                A valid webhook URL to which to send event notifications. \n                The supported protocol is https.\n                \"\"\",\n            ),\n        ]\n        events: Annotated[\n            list[EnumWebhookEvent] | None,\n            Field(\n                description=\"\"\"\n                A list of event types to subscribe to. \n                If you don't provide it, you're automatically subscribed to the default event types:\n                - TransactionCreated\n                - TransactionStateChanged\n                \"\"\",\n            ),\n        ] = None\n\n    class Response(ResourceWebhook):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        signing_secret: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                The signing secret for the webhook.\n                \"\"\",\n            ),\n        ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.post.CreateWebhook.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The body of the request.</p> Source code in <code>pyrevolut/api/webhooks/post/create_webhook.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The body of the request.\n    \"\"\"\n\n    url: Annotated[\n        HttpUrl,\n        Field(\n            description=\"\"\"\n            A valid webhook URL to which to send event notifications. \n            The supported protocol is https.\n            \"\"\",\n        ),\n    ]\n    events: Annotated[\n        list[EnumWebhookEvent] | None,\n        Field(\n            description=\"\"\"\n            A list of event types to subscribe to. \n            If you don't provide it, you're automatically subscribed to the default event types:\n            - TransactionCreated\n            - TransactionStateChanged\n            \"\"\",\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.post.CreateWebhook.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceWebhook</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/post/create_webhook.py</code> <pre><code>class Response(ResourceWebhook):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    signing_secret: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            The signing secret for the webhook.\n            \"\"\",\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.post.RotateWebhookSecret","title":"<code>RotateWebhookSecret</code>","text":"<p>Rotate a signing secret for a specific webhook.</p> Source code in <code>pyrevolut/api/webhooks/post/rotate_webhook_secret.py</code> <pre><code>class RotateWebhookSecret:\n    \"\"\"\n    Rotate a signing secret for a specific webhook.\n    \"\"\"\n\n    ROUTE = \"/2.0/webhooks/{webhook_id}/rotate-signing-secret\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The body of the request.\n        \"\"\"\n\n        expiration_period: Annotated[\n            Duration | None,\n            Field(\n                description=\"\"\"\n                The expiration period for the signing secret in ISO 8601 format. \n                If set, when you rotate the secret, it continues to be valid until the \n                expiration period has passed. Otherwise, on rotation, the secret is \n                invalidated immediately. \n                The maximum value is 7 days.\n                \"\"\",\n            ),\n        ] = None\n\n    class Response(ResourceWebhook):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        signing_secret: Annotated[\n            str,\n            Field(\n                description=\"\"\"\n                The signing secret for the webhook.\n                \"\"\",\n            ),\n        ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.post.RotateWebhookSecret.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The body of the request.</p> Source code in <code>pyrevolut/api/webhooks/post/rotate_webhook_secret.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The body of the request.\n    \"\"\"\n\n    expiration_period: Annotated[\n        Duration | None,\n        Field(\n            description=\"\"\"\n            The expiration period for the signing secret in ISO 8601 format. \n            If set, when you rotate the secret, it continues to be valid until the \n            expiration period has passed. Otherwise, on rotation, the secret is \n            invalidated immediately. \n            The maximum value is 7 days.\n            \"\"\",\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.post.RotateWebhookSecret.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceWebhook</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/post/rotate_webhook_secret.py</code> <pre><code>class Response(ResourceWebhook):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    signing_secret: Annotated[\n        str,\n        Field(\n            description=\"\"\"\n            The signing secret for the webhook.\n            \"\"\",\n        ),\n    ]\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.patch.UpdateWebhook","title":"<code>UpdateWebhook</code>","text":"<p>Update an existing webhook. Change the URL to which event notifications are sent or the list of event types to be notified about.</p> <p>You must specify at least one of these two. The fields that you don't specify are not updated.</p> Source code in <code>pyrevolut/api/webhooks/patch/update_webhook.py</code> <pre><code>class UpdateWebhook:\n    \"\"\"\n    Update an existing webhook. Change the URL to which event notifications are\n    sent or the list of event types to be notified about.\n\n    You must specify at least one of these two.\n    The fields that you don't specify are not updated.\n    \"\"\"\n\n    ROUTE = \"/2.0/webhooks/{webhook_id}\"\n\n    class Body(BaseModel):\n        \"\"\"\n        The body of the request.\n        \"\"\"\n\n        url: Annotated[\n            HttpUrl | None,\n            Field(\n                description=\"\"\"\n                A valid webhook URL to which to send event notifications. \n                The supported protocol is https.\n                \"\"\",\n            ),\n        ] = None\n        events: Annotated[\n            list[EnumWebhookEvent] | None,\n            Field(\n                description=\"\"\"\n                A list of event types to subscribe to. \n                \"\"\",\n            ),\n        ] = None\n\n    class Response(ResourceWebhook):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.patch.UpdateWebhook.Body","title":"<code>Body</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The body of the request.</p> Source code in <code>pyrevolut/api/webhooks/patch/update_webhook.py</code> <pre><code>class Body(BaseModel):\n    \"\"\"\n    The body of the request.\n    \"\"\"\n\n    url: Annotated[\n        HttpUrl | None,\n        Field(\n            description=\"\"\"\n            A valid webhook URL to which to send event notifications. \n            The supported protocol is https.\n            \"\"\",\n        ),\n    ] = None\n    events: Annotated[\n        list[EnumWebhookEvent] | None,\n        Field(\n            description=\"\"\"\n            A list of event types to subscribe to. \n            \"\"\",\n        ),\n    ] = None\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.patch.UpdateWebhook.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>ResourceWebhook</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/patch/update_webhook.py</code> <pre><code>class Response(ResourceWebhook):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.delete.DeleteWebhook","title":"<code>DeleteWebhook</code>","text":"<p>Delete a specific webhook.</p> <p>A successful response does not get any content in return.</p> Source code in <code>pyrevolut/api/webhooks/delete/delete_webhook.py</code> <pre><code>class DeleteWebhook:\n    \"\"\"\n    Delete a specific webhook.\n\n    A successful response does not get any content in return.\n    \"\"\"\n\n    ROUTE = \"/2.0/webhooks/{webhook_id}\"\n\n    class Params(BaseModel):\n        \"\"\"\n        The query params of the request.\n        \"\"\"\n\n        pass\n\n    class Response(BaseModel):\n        \"\"\"\n        The response model for the request.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.delete.DeleteWebhook.Params","title":"<code>Params</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The query params of the request.</p> Source code in <code>pyrevolut/api/webhooks/delete/delete_webhook.py</code> <pre><code>class Params(BaseModel):\n    \"\"\"\n    The query params of the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/webhooks/pydantic/#pyrevolut.api.webhooks.delete.DeleteWebhook.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/delete/delete_webhook.py</code> <pre><code>class Response(BaseModel):\n    \"\"\"\n    The response model for the request.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code_reference/api/webhooks/synchronous/","title":"Webhooks Synchronous Endpoints","text":"<p>This <code>Webhooks</code> endpoint provides methods to interact with the webhooks of the authenticated user.</p> <p>Example usage of the Webhooks endpoint object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    webhooks = client.Webhooks.get_all_webhooks()\n    print(webhooks)\n</code></pre>"},{"location":"code_reference/api/webhooks/synchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync","title":"<code>EndpointWebhooksSync</code>","text":"<p>               Bases: <code>BaseEndpointWebhooks</code></p> <p>The Webhooks API</p> <p>A webhook (also called a web callback) allows your system to receive updates about your account to an HTTPS endpoint that you provide. When a supported event occurs, a notification is posted via HTTP POST method to the specified endpoint.</p> <p>If the receiver returns an HTTP error response, Revolut will retry the webhook event three more times, each with a 10-minute interval.</p> <p>The following events are supported:</p> <p>TransactionCreated TransactionStateChanged PayoutLinkCreated PayoutLinkStateChanged</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>class EndpointWebhooksSync(BaseEndpointWebhooks):\n    \"\"\"The Webhooks API\n\n    A webhook (also called a web callback) allows your system to receive\n    updates about your account to an HTTPS endpoint that you provide.\n    When a supported event occurs, a notification is posted via HTTP POST method\n    to the specified endpoint.\n\n    If the receiver returns an HTTP error response, Revolut will retry the webhook\n    event three more times, each with a 10-minute interval.\n\n    The following events are supported:\n\n    TransactionCreated\n    TransactionStateChanged\n    PayoutLinkCreated\n    PayoutLinkStateChanged\n    \"\"\"\n\n    def get_all_webhooks(\n        self,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfWebhooks.Response]:\n        \"\"\"\n        Get the list of all your existing webhooks and their details.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfWebhooks.Response]\n            The list of all your existing webhooks and their details.\n        \"\"\"\n        endpoint = RetrieveListOfWebhooks\n        path = endpoint.ROUTE\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_webhook(\n        self,\n        webhook_id: UUID,\n        **kwargs,\n    ) -&gt; dict | RetrieveWebhook.Response:\n        \"\"\"\n        Get the information about a specific webhook by ID.\n\n        Parameters\n        ----------\n        webhook_id : UUID\n            The ID of the webhook.\n\n        Returns\n        -------\n        dict | RetrieveWebhook.Response\n            The information about the webhook.\n        \"\"\"\n        endpoint = RetrieveWebhook\n        path = endpoint.ROUTE.format(webhook_id=webhook_id)\n        params = endpoint.Params()\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def get_failed_webhook_events(\n        self,\n        webhook_id: UUID,\n        limit: int | None = None,\n        created_before: datetime | DateTime | str | int | float | None = None,\n        **kwargs,\n    ) -&gt; list[dict] | list[RetrieveListOfFailedWebhooks.Response]:\n        \"\"\"\n        Get the list of all your failed webhook events, or use the query\n        parameters to filter the results.\n\n        The events are sorted by the created_at date in reverse chronological order.\n\n        The returned failed events are paginated. The maximum number of events returned\n        per page is specified by the limit parameter.\n        To get to the next page, make a new request and use the created_at date of the\n        last event returned in the previous response.\n\n        Parameters\n        ----------\n        webhook_id : UUID\n            The ID of the webhook.\n        limit : int, optional\n            The maximum number of events returned per page.\n            To get to the next page, make a new request and use the created_at date of\n            the last event returned in the previous response as value for created_before.\n            If not specified, the default value is 100.\n        created_before : datetime | DateTime | str | int | float, optional\n            Retrieves events with created_at &lt; created_before.\n            Cannot be older than the current date minus 21 days.\n            The default value is the current date and time at which you are calling the endpoint.\n            Provided in ISO 8601 format.\n\n        Returns\n        -------\n        list[dict] | list[RetrieveListOfFailedWebhooks.Response]\n            The list of all your failed webhook events.\n        \"\"\"\n        endpoint = RetrieveListOfFailedWebhooks\n        path = endpoint.ROUTE.format(webhook_id=webhook_id)\n        params = endpoint.Params(\n            limit=limit,\n            created_before=created_before,\n        )\n\n        return self.client.get(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n\n    def create_webhook(\n        self,\n        url: str,\n        events: list[EnumWebhookEvent] | None = None,\n        **kwargs,\n    ) -&gt; dict | CreateWebhook.Response:\n        \"\"\"\n        Create a new webhook to receive event notifications to the specified URL.\n        Provide a list of event types that you want to subscribe to and a URL for the webhook.\n        Only HTTPS URLs are supported.\n\n        Parameters\n        ----------\n        url : str\n            A valid webhook URL to which to send event notifications.\n            The supported protocol is https.\n        events : list[EnumWebhookEvent], optional\n            A list of event types to subscribe to.\n            If you don't provide it, you're automatically subscribed to the default event types:\n            - TransactionCreated\n            - TransactionStateChanged\n\n        Returns\n        -------\n        dict | CreateWebhook.Response\n            The response model for the request.\n        \"\"\"\n        endpoint = CreateWebhook\n        path = endpoint.ROUTE\n        body = endpoint.Body(\n            url=url,\n            events=events,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def rotate_webhook_secret(\n        self,\n        webhook_id: UUID,\n        expiration_period: Duration | None = None,\n        **kwargs,\n    ) -&gt; dict | RotateWebhookSecret.Response:\n        \"\"\"\n        Rotate a signing secret for a specific webhook.\n\n        Parameters\n        ----------\n        webhook_id : UUID\n            The ID of the webhook.\n        expiration_period : Duration, optional\n            The expiration period for the signing secret in ISO 8601 format.\n            If set, when you rotate the secret, it continues to be valid until the\n            expiration period has passed.\n            Otherwise, on rotation, the secret is invalidated immediately.\n            The maximum value is 7 days.\n\n        Returns\n        -------\n        dict | RotateWebhookSecret.Response\n            The response model for the request.\n        \"\"\"\n        endpoint = RotateWebhookSecret\n        path = endpoint.ROUTE.format(webhook_id=webhook_id)\n        body = endpoint.Body(\n            expiration_period=expiration_period,\n        )\n\n        return self.client.post(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def update_webhook(\n        self,\n        webhook_id: UUID,\n        url: str | None = None,\n        events: list[EnumWebhookEvent] | None = None,\n        **kwargs,\n    ) -&gt; dict | UpdateWebhook.Response:\n        \"\"\"\n        Update an existing webhook. Change the URL to which event notifications are\n        sent or the list of event types to be notified about.\n\n        You must specify at least one of these two.\n        The fields that you don't specify are not updated.\n\n        Parameters\n        ----------\n        webhook_id : UUID\n            The ID of the webhook.\n        url : str, optional\n            A valid webhook URL to which to send event notifications.\n            The supported protocol is https.\n        events : list[EnumWebhookEvent], optional\n            A list of event types to subscribe to.\n\n        Returns\n        -------\n        dict | UpdateWebhook.Response\n            The response model for the request.\n        \"\"\"\n        endpoint = UpdateWebhook\n        path = endpoint.ROUTE.format(webhook_id=webhook_id)\n        body = endpoint.Body(\n            url=url,\n            events=events,\n        )\n\n        return self.client.patch(\n            path=path,\n            response_model=endpoint.Response,\n            body=body,\n            **kwargs,\n        )\n\n    def delete_webhook(\n        self,\n        webhook_id: UUID,\n        **kwargs,\n    ) -&gt; dict | DeleteWebhook.Response:\n        \"\"\"\n        Delete a specific webhook.\n\n        A successful response does not get any content in return.\n\n        Parameters\n        ----------\n        webhook_id : UUID\n            The ID of the webhook.\n\n        Returns\n        -------\n        dict | DeleteWebhook.Response\n            An empty dictionary.\n        \"\"\"\n        endpoint = DeleteWebhook\n        path = endpoint.ROUTE.format(webhook_id=webhook_id)\n        params = endpoint.Params()\n\n        return self.client.delete(\n            path=path,\n            response_model=endpoint.Response,\n            params=params,\n            **kwargs,\n        )\n</code></pre>"},{"location":"code_reference/api/webhooks/synchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.create_webhook","title":"<code>create_webhook(url, events=None, **kwargs)</code>","text":"<p>Create a new webhook to receive event notifications to the specified URL. Provide a list of event types that you want to subscribe to and a URL for the webhook. Only HTTPS URLs are supported.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A valid webhook URL to which to send event notifications. The supported protocol is https.</p> required <code>events</code> <code>list[EnumWebhookEvent]</code> <p>A list of event types to subscribe to. If you don't provide it, you're automatically subscribed to the default event types: - TransactionCreated - TransactionStateChanged</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def create_webhook(\n    self,\n    url: str,\n    events: list[EnumWebhookEvent] | None = None,\n    **kwargs,\n) -&gt; dict | CreateWebhook.Response:\n    \"\"\"\n    Create a new webhook to receive event notifications to the specified URL.\n    Provide a list of event types that you want to subscribe to and a URL for the webhook.\n    Only HTTPS URLs are supported.\n\n    Parameters\n    ----------\n    url : str\n        A valid webhook URL to which to send event notifications.\n        The supported protocol is https.\n    events : list[EnumWebhookEvent], optional\n        A list of event types to subscribe to.\n        If you don't provide it, you're automatically subscribed to the default event types:\n        - TransactionCreated\n        - TransactionStateChanged\n\n    Returns\n    -------\n    dict | CreateWebhook.Response\n        The response model for the request.\n    \"\"\"\n    endpoint = CreateWebhook\n    path = endpoint.ROUTE\n    body = endpoint.Body(\n        url=url,\n        events=events,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/synchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.delete_webhook","title":"<code>delete_webhook(webhook_id, **kwargs)</code>","text":"<p>Delete a specific webhook.</p> <p>A successful response does not get any content in return.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>UUID</code> <p>The ID of the webhook.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>An empty dictionary.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def delete_webhook(\n    self,\n    webhook_id: UUID,\n    **kwargs,\n) -&gt; dict | DeleteWebhook.Response:\n    \"\"\"\n    Delete a specific webhook.\n\n    A successful response does not get any content in return.\n\n    Parameters\n    ----------\n    webhook_id : UUID\n        The ID of the webhook.\n\n    Returns\n    -------\n    dict | DeleteWebhook.Response\n        An empty dictionary.\n    \"\"\"\n    endpoint = DeleteWebhook\n    path = endpoint.ROUTE.format(webhook_id=webhook_id)\n    params = endpoint.Params()\n\n    return self.client.delete(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/synchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.get_all_webhooks","title":"<code>get_all_webhooks(**kwargs)</code>","text":"<p>Get the list of all your existing webhooks and their details.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all your existing webhooks and their details.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def get_all_webhooks(\n    self,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfWebhooks.Response]:\n    \"\"\"\n    Get the list of all your existing webhooks and their details.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfWebhooks.Response]\n        The list of all your existing webhooks and their details.\n    \"\"\"\n    endpoint = RetrieveListOfWebhooks\n    path = endpoint.ROUTE\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/synchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.get_failed_webhook_events","title":"<code>get_failed_webhook_events(webhook_id, limit=None, created_before=None, **kwargs)</code>","text":"<p>Get the list of all your failed webhook events, or use the query parameters to filter the results.</p> <p>The events are sorted by the created_at date in reverse chronological order.</p> <p>The returned failed events are paginated. The maximum number of events returned per page is specified by the limit parameter. To get to the next page, make a new request and use the created_at date of the last event returned in the previous response.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>UUID</code> <p>The ID of the webhook.</p> required <code>limit</code> <code>int</code> <p>The maximum number of events returned per page. To get to the next page, make a new request and use the created_at date of the last event returned in the previous response as value for created_before. If not specified, the default value is 100.</p> <code>None</code> <code>created_before</code> <code>datetime | DateTime | str | int | float</code> <p>Retrieves events with created_at &lt; created_before. Cannot be older than the current date minus 21 days. The default value is the current date and time at which you are calling the endpoint. Provided in ISO 8601 format.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict] | list[Response]</code> <p>The list of all your failed webhook events.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def get_failed_webhook_events(\n    self,\n    webhook_id: UUID,\n    limit: int | None = None,\n    created_before: datetime | DateTime | str | int | float | None = None,\n    **kwargs,\n) -&gt; list[dict] | list[RetrieveListOfFailedWebhooks.Response]:\n    \"\"\"\n    Get the list of all your failed webhook events, or use the query\n    parameters to filter the results.\n\n    The events are sorted by the created_at date in reverse chronological order.\n\n    The returned failed events are paginated. The maximum number of events returned\n    per page is specified by the limit parameter.\n    To get to the next page, make a new request and use the created_at date of the\n    last event returned in the previous response.\n\n    Parameters\n    ----------\n    webhook_id : UUID\n        The ID of the webhook.\n    limit : int, optional\n        The maximum number of events returned per page.\n        To get to the next page, make a new request and use the created_at date of\n        the last event returned in the previous response as value for created_before.\n        If not specified, the default value is 100.\n    created_before : datetime | DateTime | str | int | float, optional\n        Retrieves events with created_at &lt; created_before.\n        Cannot be older than the current date minus 21 days.\n        The default value is the current date and time at which you are calling the endpoint.\n        Provided in ISO 8601 format.\n\n    Returns\n    -------\n    list[dict] | list[RetrieveListOfFailedWebhooks.Response]\n        The list of all your failed webhook events.\n    \"\"\"\n    endpoint = RetrieveListOfFailedWebhooks\n    path = endpoint.ROUTE.format(webhook_id=webhook_id)\n    params = endpoint.Params(\n        limit=limit,\n        created_before=created_before,\n    )\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/synchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.get_webhook","title":"<code>get_webhook(webhook_id, **kwargs)</code>","text":"<p>Get the information about a specific webhook by ID.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>UUID</code> <p>The ID of the webhook.</p> required <p>Returns:</p> Type Description <code>dict | Response</code> <p>The information about the webhook.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def get_webhook(\n    self,\n    webhook_id: UUID,\n    **kwargs,\n) -&gt; dict | RetrieveWebhook.Response:\n    \"\"\"\n    Get the information about a specific webhook by ID.\n\n    Parameters\n    ----------\n    webhook_id : UUID\n        The ID of the webhook.\n\n    Returns\n    -------\n    dict | RetrieveWebhook.Response\n        The information about the webhook.\n    \"\"\"\n    endpoint = RetrieveWebhook\n    path = endpoint.ROUTE.format(webhook_id=webhook_id)\n    params = endpoint.Params()\n\n    return self.client.get(\n        path=path,\n        response_model=endpoint.Response,\n        params=params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/synchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.rotate_webhook_secret","title":"<code>rotate_webhook_secret(webhook_id, expiration_period=None, **kwargs)</code>","text":"<p>Rotate a signing secret for a specific webhook.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>UUID</code> <p>The ID of the webhook.</p> required <code>expiration_period</code> <code>Duration</code> <p>The expiration period for the signing secret in ISO 8601 format. If set, when you rotate the secret, it continues to be valid until the expiration period has passed. Otherwise, on rotation, the secret is invalidated immediately. The maximum value is 7 days.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def rotate_webhook_secret(\n    self,\n    webhook_id: UUID,\n    expiration_period: Duration | None = None,\n    **kwargs,\n) -&gt; dict | RotateWebhookSecret.Response:\n    \"\"\"\n    Rotate a signing secret for a specific webhook.\n\n    Parameters\n    ----------\n    webhook_id : UUID\n        The ID of the webhook.\n    expiration_period : Duration, optional\n        The expiration period for the signing secret in ISO 8601 format.\n        If set, when you rotate the secret, it continues to be valid until the\n        expiration period has passed.\n        Otherwise, on rotation, the secret is invalidated immediately.\n        The maximum value is 7 days.\n\n    Returns\n    -------\n    dict | RotateWebhookSecret.Response\n        The response model for the request.\n    \"\"\"\n    endpoint = RotateWebhookSecret\n    path = endpoint.ROUTE.format(webhook_id=webhook_id)\n    body = endpoint.Body(\n        expiration_period=expiration_period,\n    )\n\n    return self.client.post(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/api/webhooks/synchronous/#pyrevolut.api.webhooks.endpoint.EndpointWebhooksSync.update_webhook","title":"<code>update_webhook(webhook_id, url=None, events=None, **kwargs)</code>","text":"<p>Update an existing webhook. Change the URL to which event notifications are sent or the list of event types to be notified about.</p> <p>You must specify at least one of these two. The fields that you don't specify are not updated.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_id</code> <code>UUID</code> <p>The ID of the webhook.</p> required <code>url</code> <code>str</code> <p>A valid webhook URL to which to send event notifications. The supported protocol is https.</p> <code>None</code> <code>events</code> <code>list[EnumWebhookEvent]</code> <p>A list of event types to subscribe to.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>The response model for the request.</p> Source code in <code>pyrevolut/api/webhooks/endpoint/synchronous.py</code> <pre><code>def update_webhook(\n    self,\n    webhook_id: UUID,\n    url: str | None = None,\n    events: list[EnumWebhookEvent] | None = None,\n    **kwargs,\n) -&gt; dict | UpdateWebhook.Response:\n    \"\"\"\n    Update an existing webhook. Change the URL to which event notifications are\n    sent or the list of event types to be notified about.\n\n    You must specify at least one of these two.\n    The fields that you don't specify are not updated.\n\n    Parameters\n    ----------\n    webhook_id : UUID\n        The ID of the webhook.\n    url : str, optional\n        A valid webhook URL to which to send event notifications.\n        The supported protocol is https.\n    events : list[EnumWebhookEvent], optional\n        A list of event types to subscribe to.\n\n    Returns\n    -------\n    dict | UpdateWebhook.Response\n        The response model for the request.\n    \"\"\"\n    endpoint = UpdateWebhook\n    path = endpoint.ROUTE.format(webhook_id=webhook_id)\n    body = endpoint.Body(\n        url=url,\n        events=events,\n    )\n\n    return self.client.patch(\n        path=path,\n        response_model=endpoint.Response,\n        body=body,\n        **kwargs,\n    )\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/","title":"PyRevolut Exceptions","text":"<p>PyRevolut provides a number of exceptions that can be raised during the execution of the client.</p>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.common.PyRevolutBaseException","title":"<code>PyRevolutBaseException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all pyrevolut exceptions.</p> Source code in <code>pyrevolut/exceptions/common.py</code> <pre><code>class PyRevolutBaseException(Exception):\n    \"\"\"Base exception for all pyrevolut exceptions.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"An error occurred while processing your request to Revolut.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.bad_request.PyRevolutBadRequest","title":"<code>PyRevolutBadRequest</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Bad Request -- Your request is invalid.</p> Source code in <code>pyrevolut/exceptions/bad_request.py</code> <pre><code>class PyRevolutBadRequest(PyRevolutBaseException):\n    \"\"\"Bad Request -- Your request is invalid.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"Your request is invalid. Please check the request and try again.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.conflict.PyRevolutConflict","title":"<code>PyRevolutConflict</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Conflict -- Your request conflicts with current state of a resource.</p> Source code in <code>pyrevolut/exceptions/conflict.py</code> <pre><code>class PyRevolutConflict(PyRevolutBaseException):\n    \"\"\"Conflict -- Your request conflicts with current state of a resource.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"Your request conflicts with the current state of a resource. Please check the request and try again.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.forbidden.PyRevolutForbidden","title":"<code>PyRevolutForbidden</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Forbidden -- Access to the requested resource or action is forbidden.</p> Source code in <code>pyrevolut/exceptions/forbidden.py</code> <pre><code>class PyRevolutForbidden(PyRevolutBaseException):\n    \"\"\"Forbidden -- Access to the requested resource or action is forbidden.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"Access to the requested resource or action is forbidden.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.internal_server_error.PyRevolutInternalServerError","title":"<code>PyRevolutInternalServerError</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Internal Server Error -- We had a problem with our server. Try again later.</p> Source code in <code>pyrevolut/exceptions/internal_server_error.py</code> <pre><code>class PyRevolutInternalServerError(PyRevolutBaseException):\n    \"\"\"Internal Server Error -- We had a problem with our server. Try again later.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"The Revolut server had a problem. Please try again later.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.invalid_environment.PyRevolutInvalidEnvironment","title":"<code>PyRevolutInvalidEnvironment</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Raised when the environment is invalid</p> Source code in <code>pyrevolut/exceptions/invalid_environment.py</code> <pre><code>class PyRevolutInvalidEnvironment(PyRevolutBaseException):\n    \"\"\"Raised when the environment is invalid\"\"\"\n\n    def __init__(\n        self,\n        msg=\"This request is not valid for the current environment. Please check the environment and try again.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.invalid_payload.PyRevolutInvalidPayload","title":"<code>PyRevolutInvalidPayload</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Invalid Webhook Payload -- The webhook payload is invalid.</p> Source code in <code>pyrevolut/exceptions/invalid_payload.py</code> <pre><code>class PyRevolutInvalidPayload(PyRevolutBaseException):\n    \"\"\"Invalid Webhook Payload -- The webhook payload is invalid.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"The webhook payload is invalid. Either the payload signature is invalid or the payload timestamp is too old.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.method_not_allowed.PyRevolutMethodNotAllowed","title":"<code>PyRevolutMethodNotAllowed</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Method Not Allowed -- You tried to access an endpoint with an invalid method.</p> Source code in <code>pyrevolut/exceptions/method_not_allowed.py</code> <pre><code>class PyRevolutMethodNotAllowed(PyRevolutBaseException):\n    \"\"\"Method Not Allowed -- You tried to access an endpoint with an invalid method.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"You tried to access an endpoint with an invalid method. Please check the method and try again.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.network_error.PyRevolutNetworkError","title":"<code>PyRevolutNetworkError</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Network Error -- The request failed due to a network error.</p> Source code in <code>pyrevolut/exceptions/network_error.py</code> <pre><code>class PyRevolutNetworkError(PyRevolutBaseException):\n    \"\"\"Network Error -- The request failed due to a network error.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"The request failed due to a network error. Please check your network connection and try again.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.not_acceptable.PyRevolutNotAcceptable","title":"<code>PyRevolutNotAcceptable</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Not Acceptable -- You requested a format that isn't JSON.</p> Source code in <code>pyrevolut/exceptions/not_acceptable.py</code> <pre><code>class PyRevolutNotAcceptable(PyRevolutBaseException):\n    \"\"\"Not Acceptable -- You requested a format that isn't JSON.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"You requested a format that isn't JSON. Please check the request and try again.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.not_found.PyRevolutNotFound","title":"<code>PyRevolutNotFound</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Not Found -- The requested resource could not be found.</p> Source code in <code>pyrevolut/exceptions/not_found.py</code> <pre><code>class PyRevolutNotFound(PyRevolutBaseException):\n    \"\"\"Not Found -- The requested resource could not be found.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"The requested resource could not be found on the Revolut server.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.server_unavailable.PyRevolutServerUnavailable","title":"<code>PyRevolutServerUnavailable</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Service Unavailable -- We're temporarily offline for maintenance. Please try again later.</p> Source code in <code>pyrevolut/exceptions/server_unavailable.py</code> <pre><code>class PyRevolutServerUnavailable(PyRevolutBaseException):\n    \"\"\"Service Unavailable -- We're temporarily offline for maintenance. Please try again later.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"The Revolut server is temporarily offline for maintenance. Please try again later.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.timeout_error.PyRevolutTimeoutError","title":"<code>PyRevolutTimeoutError</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Timeout Error -- The request timed out.</p> Source code in <code>pyrevolut/exceptions/timeout_error.py</code> <pre><code>class PyRevolutTimeoutError(PyRevolutBaseException):\n    \"\"\"Timeout Error -- The request timed out.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"The request timed out. Please try again.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.too_many_requests.PyRevolutTooManyRequests","title":"<code>PyRevolutTooManyRequests</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Too Many Requests -- You're sending too many requests.</p> Source code in <code>pyrevolut/exceptions/too_many_requests.py</code> <pre><code>class PyRevolutTooManyRequests(PyRevolutBaseException):\n    \"\"\"Too Many Requests -- You're sending too many requests.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"You're sending too many requests. Please wait a while and try again.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/exceptions/exceptions/#pyrevolut.exceptions.unauthorized.PyRevolutUnauthorized","title":"<code>PyRevolutUnauthorized</code>","text":"<p>               Bases: <code>PyRevolutBaseException</code></p> <p>Unauthorized -- Your access token is wrong.</p> Source code in <code>pyrevolut/exceptions/unauthorized.py</code> <pre><code>class PyRevolutUnauthorized(PyRevolutBaseException):\n    \"\"\"Unauthorized -- Your access token is wrong.\"\"\"\n\n    def __init__(\n        self,\n        msg=\"Your access token is wrong. Please check the access token and try again.\",\n        *args,\n        **kwargs,\n    ):\n        super().__init__(msg, *args, **kwargs)\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/","title":"PyRevolut Asynchronous Client","text":"<p>PyRevolut provides an asynchronous client that can be used to interact with the Revolut Business API.</p> <p>Example initialization of the client object:</p> <pre><code>import asyncio\nfrom pyrevolut.client import AsyncClient\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = AsyncClient(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nasync def run():\n  async with client:\n      accounts = await client.Accounts.get_all_accounts()\n      print(accounts)\n\nasyncio.run(run())\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient","title":"<code>AsyncClient</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>The asynchronous client for the Revolut API</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>class AsyncClient(BaseClient):\n    \"\"\"The asynchronous client for the Revolut API\"\"\"\n\n    Accounts: EndpointAccountsAsync\n    Cards: EndpointCardsAsync\n    Counterparties: EndpointCounterpartiesAsync\n    ForeignExchange: EndpointForeignExchangeAsync\n    PaymentDrafts: EndpointPaymentDraftsAsync\n    PayoutLinks: EndpointPayoutLinksAsync\n    Simulations: EndpointSimulationsAsync\n    TeamMembers: EndpointTeamMembersAsync\n    Transactions: EndpointTransactionsAsync\n    Transfers: EndpointTransfersAsync\n    Webhooks: EndpointWebhooksAsync\n\n    async def open(self):\n        \"\"\"Opens the client connection\"\"\"\n        if self.client is not None:\n            return\n\n        self.client = HTTPClient()\n\n    async def close(self):\n        \"\"\"Closes the client connection\"\"\"\n        if self.client is None:\n            return\n\n        await self.client.aclose()\n        self.client = None\n\n    async def get(\n        self,\n        path: str,\n        response_model: Type[BaseModel],\n        params: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Send an async GET request to the Revolut API\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        response_model : Type[BaseModel]\n            The model to use for the response\n        params : Type[BaseModel] | None\n            The parameters to send in the request\n\n        Returns\n        -------\n        Response\n            The response from the request\n        \"\"\"\n        resp = await self.client.get(\n            **self._prep_get(\n                path=path,\n                params=params,\n                **kwargs,\n            )\n        )\n        return self.process_response(\n            response=resp,\n            response_model=response_model,\n            return_type=None,\n            error_response=None,\n        )\n\n    async def post(\n        self,\n        path: str,\n        response_model: Type[BaseModel],\n        body: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Send an async POST request to the Revolut API\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        response_model : Type[BaseModel]\n            The model to use for the response\n        body : Type[BaseModel] | None\n            The body to send in the request\n\n        Returns\n        -------\n        Response\n            The response from the request\n        \"\"\"\n        resp = await self.client.post(\n            **self._prep_post(\n                path=path,\n                body=body,\n                **kwargs,\n            )\n        )\n        return self.process_response(\n            response=resp,\n            response_model=response_model,\n            return_type=None,\n            error_response=None,\n        )\n\n    async def patch(\n        self,\n        path: str,\n        response_model: Type[BaseModel],\n        body: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Send an async PATCH request to the Revolut API\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        response_model : Type[BaseModel]\n            The model to use for the response\n        body : Type[BaseModel] | None\n            The body to send in the request\n\n        Returns\n        -------\n        Response\n            The response from the request\n        \"\"\"\n        resp = await self.client.patch(\n            **self._prep_patch(\n                path=path,\n                body=body,\n                **kwargs,\n            )\n        )\n        return self.process_response(\n            response=resp,\n            response_model=response_model,\n            return_type=None,\n            error_response=None,\n        )\n\n    async def delete(\n        self,\n        path: str,\n        response_model: Type[BaseModel],\n        params: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Send an async DELETE request to the Revolut API\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        response_model : Type[BaseModel]\n            The model to use for the response\n        params : Type[BaseModel] | None\n            The parameters to add to the request route\n\n        Returns\n        -------\n        Response\n            The response from the request\n        \"\"\"\n        resp = await self.client.delete(\n            **self._prep_delete(\n                path=path,\n                params=params,\n                **kwargs,\n            )\n        )\n        return self.process_response(\n            response=resp,\n            response_model=response_model,\n            return_type=None,\n            error_response=None,\n        )\n\n    async def put(\n        self,\n        path: str,\n        response_model: Type[BaseModel],\n        body: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Send an async PUT request to the Revolut API\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        response_model : Type[BaseModel]\n            The model to use for the response\n        body : Type[BaseModel] | None\n            The body to send in the request\n\n        Returns\n        -------\n        Response\n            The response from the request\n        \"\"\"\n        resp = await self.client.put(\n            **self._prep_put(\n                path=path,\n                body=body,\n                **kwargs,\n            )\n        )\n        return self.process_response(\n            response=resp,\n            response_model=response_model,\n            return_type=None,\n            error_response=None,\n        )\n\n    def load_endpoints(self):\n        \"\"\"Loads all the endpoints from the api directory\"\"\"\n        self.Accounts = EndpointAccountsAsync(client=self)\n        self.Cards = EndpointCardsAsync(client=self)\n        self.Counterparties = EndpointCounterpartiesAsync(client=self)\n        self.ForeignExchange = EndpointForeignExchangeAsync(client=self)\n        self.PaymentDrafts = EndpointPaymentDraftsAsync(client=self)\n        self.PayoutLinks = EndpointPayoutLinksAsync(client=self)\n        self.Simulations = EndpointSimulationsAsync(client=self)\n        self.TeamMembers = EndpointTeamMembersAsync(client=self)\n        self.Transactions = EndpointTransactionsAsync(client=self)\n        self.Transfers = EndpointTransfersAsync(client=self)\n        self.Webhooks = EndpointWebhooksAsync(client=self)\n\n    async def __aenter__(self):\n        \"\"\"Open the async client connection\"\"\"\n        await self.open()\n        return self\n\n    async def __aexit__(self, *args, **kwargs):\n        \"\"\"Close the async client connection\"\"\"\n        await self.close()\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Open the async client connection</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Open the async client connection\"\"\"\n    await self.open()\n    return self\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient.__aexit__","title":"<code>__aexit__(*args, **kwargs)</code>  <code>async</code>","text":"<p>Close the async client connection</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>async def __aexit__(self, *args, **kwargs):\n    \"\"\"Close the async client connection\"\"\"\n    await self.close()\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Closes the client connection</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>async def close(self):\n    \"\"\"Closes the client connection\"\"\"\n    if self.client is None:\n        return\n\n    await self.client.aclose()\n    self.client = None\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient.delete","title":"<code>delete(path, response_model, params=None, **kwargs)</code>  <code>async</code>","text":"<p>Send an async DELETE request to the Revolut API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to send the request to</p> required <code>response_model</code> <code>Type[BaseModel]</code> <p>The model to use for the response</p> required <code>params</code> <code>Type[BaseModel] | None</code> <p>The parameters to add to the request route</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from the request</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>async def delete(\n    self,\n    path: str,\n    response_model: Type[BaseModel],\n    params: Type[BaseModel] | None = None,\n    **kwargs,\n):\n    \"\"\"Send an async DELETE request to the Revolut API\n\n    Parameters\n    ----------\n    path : str\n        The path to send the request to\n    response_model : Type[BaseModel]\n        The model to use for the response\n    params : Type[BaseModel] | None\n        The parameters to add to the request route\n\n    Returns\n    -------\n    Response\n        The response from the request\n    \"\"\"\n    resp = await self.client.delete(\n        **self._prep_delete(\n            path=path,\n            params=params,\n            **kwargs,\n        )\n    )\n    return self.process_response(\n        response=resp,\n        response_model=response_model,\n        return_type=None,\n        error_response=None,\n    )\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient.get","title":"<code>get(path, response_model, params=None, **kwargs)</code>  <code>async</code>","text":"<p>Send an async GET request to the Revolut API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to send the request to</p> required <code>response_model</code> <code>Type[BaseModel]</code> <p>The model to use for the response</p> required <code>params</code> <code>Type[BaseModel] | None</code> <p>The parameters to send in the request</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from the request</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>async def get(\n    self,\n    path: str,\n    response_model: Type[BaseModel],\n    params: Type[BaseModel] | None = None,\n    **kwargs,\n):\n    \"\"\"Send an async GET request to the Revolut API\n\n    Parameters\n    ----------\n    path : str\n        The path to send the request to\n    response_model : Type[BaseModel]\n        The model to use for the response\n    params : Type[BaseModel] | None\n        The parameters to send in the request\n\n    Returns\n    -------\n    Response\n        The response from the request\n    \"\"\"\n    resp = await self.client.get(\n        **self._prep_get(\n            path=path,\n            params=params,\n            **kwargs,\n        )\n    )\n    return self.process_response(\n        response=resp,\n        response_model=response_model,\n        return_type=None,\n        error_response=None,\n    )\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient.load_endpoints","title":"<code>load_endpoints()</code>","text":"<p>Loads all the endpoints from the api directory</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>def load_endpoints(self):\n    \"\"\"Loads all the endpoints from the api directory\"\"\"\n    self.Accounts = EndpointAccountsAsync(client=self)\n    self.Cards = EndpointCardsAsync(client=self)\n    self.Counterparties = EndpointCounterpartiesAsync(client=self)\n    self.ForeignExchange = EndpointForeignExchangeAsync(client=self)\n    self.PaymentDrafts = EndpointPaymentDraftsAsync(client=self)\n    self.PayoutLinks = EndpointPayoutLinksAsync(client=self)\n    self.Simulations = EndpointSimulationsAsync(client=self)\n    self.TeamMembers = EndpointTeamMembersAsync(client=self)\n    self.Transactions = EndpointTransactionsAsync(client=self)\n    self.Transfers = EndpointTransfersAsync(client=self)\n    self.Webhooks = EndpointWebhooksAsync(client=self)\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient.open","title":"<code>open()</code>  <code>async</code>","text":"<p>Opens the client connection</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>async def open(self):\n    \"\"\"Opens the client connection\"\"\"\n    if self.client is not None:\n        return\n\n    self.client = HTTPClient()\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient.patch","title":"<code>patch(path, response_model, body=None, **kwargs)</code>  <code>async</code>","text":"<p>Send an async PATCH request to the Revolut API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to send the request to</p> required <code>response_model</code> <code>Type[BaseModel]</code> <p>The model to use for the response</p> required <code>body</code> <code>Type[BaseModel] | None</code> <p>The body to send in the request</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from the request</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>async def patch(\n    self,\n    path: str,\n    response_model: Type[BaseModel],\n    body: Type[BaseModel] | None = None,\n    **kwargs,\n):\n    \"\"\"Send an async PATCH request to the Revolut API\n\n    Parameters\n    ----------\n    path : str\n        The path to send the request to\n    response_model : Type[BaseModel]\n        The model to use for the response\n    body : Type[BaseModel] | None\n        The body to send in the request\n\n    Returns\n    -------\n    Response\n        The response from the request\n    \"\"\"\n    resp = await self.client.patch(\n        **self._prep_patch(\n            path=path,\n            body=body,\n            **kwargs,\n        )\n    )\n    return self.process_response(\n        response=resp,\n        response_model=response_model,\n        return_type=None,\n        error_response=None,\n    )\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient.post","title":"<code>post(path, response_model, body=None, **kwargs)</code>  <code>async</code>","text":"<p>Send an async POST request to the Revolut API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to send the request to</p> required <code>response_model</code> <code>Type[BaseModel]</code> <p>The model to use for the response</p> required <code>body</code> <code>Type[BaseModel] | None</code> <p>The body to send in the request</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from the request</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>async def post(\n    self,\n    path: str,\n    response_model: Type[BaseModel],\n    body: Type[BaseModel] | None = None,\n    **kwargs,\n):\n    \"\"\"Send an async POST request to the Revolut API\n\n    Parameters\n    ----------\n    path : str\n        The path to send the request to\n    response_model : Type[BaseModel]\n        The model to use for the response\n    body : Type[BaseModel] | None\n        The body to send in the request\n\n    Returns\n    -------\n    Response\n        The response from the request\n    \"\"\"\n    resp = await self.client.post(\n        **self._prep_post(\n            path=path,\n            body=body,\n            **kwargs,\n        )\n    )\n    return self.process_response(\n        response=resp,\n        response_model=response_model,\n        return_type=None,\n        error_response=None,\n    )\n</code></pre>"},{"location":"code_reference/http_client/asynchronous/#pyrevolut.client.asynchronous.AsyncClient.put","title":"<code>put(path, response_model, body=None, **kwargs)</code>  <code>async</code>","text":"<p>Send an async PUT request to the Revolut API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to send the request to</p> required <code>response_model</code> <code>Type[BaseModel]</code> <p>The model to use for the response</p> required <code>body</code> <code>Type[BaseModel] | None</code> <p>The body to send in the request</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from the request</p> Source code in <code>pyrevolut/client/asynchronous.py</code> <pre><code>async def put(\n    self,\n    path: str,\n    response_model: Type[BaseModel],\n    body: Type[BaseModel] | None = None,\n    **kwargs,\n):\n    \"\"\"Send an async PUT request to the Revolut API\n\n    Parameters\n    ----------\n    path : str\n        The path to send the request to\n    response_model : Type[BaseModel]\n        The model to use for the response\n    body : Type[BaseModel] | None\n        The body to send in the request\n\n    Returns\n    -------\n    Response\n        The response from the request\n    \"\"\"\n    resp = await self.client.put(\n        **self._prep_put(\n            path=path,\n            body=body,\n            **kwargs,\n        )\n    )\n    return self.process_response(\n        response=resp,\n        response_model=response_model,\n        return_type=None,\n        error_response=None,\n    )\n</code></pre>"},{"location":"code_reference/http_client/base/","title":"PyRevolut Base Client","text":"<p>This base class provides the common interface for the synchronous and asynchronous clients. The base client is not meant to be used directly.</p>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient","title":"<code>BaseClient</code>","text":"<p>The base client for the Revolut API</p> Source code in <code>pyrevolut/client/base.py</code> <pre><code>class BaseClient:\n    \"\"\"The base client for the Revolut API\"\"\"\n\n    creds_loc: str\n    creds: str | dict | None = None\n    credentials: ModelCreds\n    domain: str\n    sandbox: bool\n    return_type: Literal[\"raw\", \"dict\", \"model\"] = \"dict\"\n    error_response: Literal[\"raw\", \"raise\", \"dict\", \"model\"] = \"raise\"\n    custom_save_fn: Callable[[ModelCreds], None] | None = None\n    custom_load_fn: Callable[..., ModelCreds] | None = None\n    client: SyncClient | AsyncClient | None = None\n\n    def __init__(\n        self,\n        creds_loc: str = \"credentials/creds.json\",\n        creds: str | dict | None = None,\n        sandbox: bool = True,\n        return_type: Literal[\"raw\", \"dict\", \"model\"] = \"dict\",\n        error_response: Literal[\"raw\", \"raise\", \"dict\", \"model\"] = \"raise\",\n        custom_save_fn: Callable[[ModelCreds], None] | None = None,\n        custom_load_fn: Callable[..., ModelCreds] | None = None,\n    ):\n        \"\"\"Create a new Revolut client\n\n        Parameters\n        ----------\n        creds_loc : str, optional\n            The location of the credentials file, by default \"credentials/creds.json\".\n            If the creds input is not provided, will load the credentials from this file.\n        creds : str | dict, optional\n            The credentials to use for the client, by default None. If not provided, will\n            load the credentials from the creds_loc file.\n            Can be a dictionary of the credentials or a base64 encoded string of the credentials json.\n        sandbox : bool, optional\n            Whether to use the sandbox environment, by default True\n        return_type : Literal[\"raw\", \"dict\", \"model\"], optional\n            The return type for the API responses, by default \"dict\"\n            If \"raw\":\n                The raw response will be returned\n            If \"dict\":\n                The response will be the dictionary representation of the Pydantic model.\n                So it will have UUIDs, pendulum DateTimes, etc instead of the raw string values.\n            If \"model\":\n                The response will be a Pydantic model containing all processed response data.\n        error_response : Literal[\"raw\", \"raise\", \"dict\", \"model\"], optional\n            How the client should handle error responses, by default \"raise\"\n            If \"raw\":\n                The client will return the raw error response\n            If \"raise\":\n                The client will raise a ValueError if the response is an error\n            If \"dict\":\n                The client will return a dictionary representation of the error response\n            If \"model\":\n                The client will return a Pydantic model of the error response\n        custom_save_fn : Callable[[ModelCreds], None], optional\n            A custom function to save the credentials, by default None\n        custom_load_fn : Callable[..., ModelCreds], optional\n            A custom function to load the credentials, by default None\n        \"\"\"\n        assert return_type in [\n            \"raw\",\n            \"dict\",\n            \"model\",\n        ], \"return_type must be 'raw', 'dict', or 'model'\"\n        assert error_response in [\n            \"raise\",\n            \"dict\",\n            \"model\",\n        ], \"error_response must be 'raise', 'dict', or 'model'\"\n        assert \".json\" in creds_loc, \"creds_loc must be a .json file\"\n\n        self.creds_loc = creds_loc\n        self.creds = creds\n        self.sandbox = sandbox\n        self.return_type = return_type\n        self.error_response = error_response\n        self.custom_save_fn = custom_save_fn\n        self.custom_load_fn = custom_load_fn\n\n        # Set domain based on environment\n        if self.sandbox:\n            self.domain = \"https://sandbox-b2b.revolut.com/api\"\n        else:\n            self.domain = \"https://b2b.revolut.com/api\"\n\n        # Load the credentials\n        self.load_credentials()\n\n        # Load the endpoints\n        self.load_endpoints()\n\n    def process_response(\n        self,\n        response: Response,\n        response_model: BM,\n        return_type: Literal[\"raw\", \"dict\", \"model\"] | None = None,\n        error_response: Literal[\"raw\", \"raise\", \"dict\", \"model\"] | None = \"raise\",\n    ):\n        \"\"\"Processes the response and returns the desired format.\n        Will additionally log the request and response.\n\n        Parameters\n        ----------\n        response : Response\n            The HTTPX response to process\n        response_model : BM\n            The Pydantic model to use for the response\n        return_type : Literal[\"raw\", \"dict\", \"model\"] | None, optional\n            The return type for the API responses, by default None.\n            If \"raw\":\n                The raw response will be returned\n            If \"dict\":\n                The response will be the dictionary representation of the Pydantic model.\n                So it will have UUIDs, pendulum DateTimes, etc instead of the raw string values.\n            If \"model\":\n                The response will be a Pydantic model containing all processed response data.\n            If None:\n                The default return type of the client will be used.\n        error_response : Literal[\"raw\", \"raise\", \"dict\", \"model\"] | None, optional\n            How the client should handle error responses, by default None.\n            If \"raw\":\n                The client will return the raw error response\n            If \"raise\":\n                The client will raise a ValueError if the response is an error\n            If \"dict\":\n                The client will return a dictionary representation of the error response\n            If \"model\":\n                The client will return a Pydantic model of the error response\n            If None:\n                The default error response type of the client will be used.\n\n        Returns\n        -------\n        BM | dict | list[BM] | list[dict]\n            The response in the desired format\n        \"\"\"\n        if return_type is None:\n            return_type = self.return_type\n        if error_response is None:\n            error_response = self.error_response\n\n        # Log the request\n        self.log_request(request=response.request)\n\n        # Log the response\n        self.log_response(response=response)\n\n        # Check for error response\n        if response.is_error:\n            if error_response == \"raise\":\n                try:\n                    response.raise_for_status()\n                except TimeoutException as exc:\n                    raise PyRevolutTimeoutError() from exc\n                except NetworkError as exc:\n                    raise PyRevolutNetworkError() from exc\n                except HTTPError as exc:\n                    if response.status_code == 400:\n                        raise PyRevolutBadRequest() from exc\n                    elif response.status_code == 401:\n                        raise PyRevolutUnauthorized() from exc\n                    elif response.status_code == 403:\n                        raise PyRevolutForbidden() from exc\n                    elif response.status_code == 404:\n                        raise PyRevolutNotFound() from exc\n                    elif response.status_code == 405:\n                        raise PyRevolutMethodNotAllowed() from exc\n                    elif response.status_code == 406:\n                        raise PyRevolutNotAcceptable() from exc\n                    elif response.status_code == 409:\n                        raise PyRevolutConflict() from exc\n                    elif response.status_code == 429:\n                        raise PyRevolutTooManyRequests() from exc\n                    elif response.status_code == 500:\n                        raise PyRevolutInternalServerError() from exc\n                    elif response.status_code == 503:\n                        raise PyRevolutServerUnavailable() from exc\n                    raise PyRevolutBaseException() from exc\n            elif error_response == \"raw\":\n                return response.json()\n            elif error_response == \"dict\":\n                return ModelError(**response.json()).model_dump()\n            elif error_response == \"model\":\n                return ModelError(**response.json())\n            else:\n                raise ValueError(f\"Invalid error response type: {error_response}\")\n\n        # Raw response\n        try:\n            raw_response = response.json()\n        except json.JSONDecodeError:\n            raw_response = {}\n        if return_type == \"raw\":\n            return raw_response\n\n        # Dict response\n        if isinstance(raw_response, list):\n            model_response = [response_model(**resp) for resp in raw_response]\n        else:\n            model_response = response_model(**raw_response)\n        if return_type == \"dict\":\n            if isinstance(model_response, list):\n                return [resp.model_dump() for resp in model_response]\n            return model_response.model_dump()\n\n        # Model response\n        if return_type == \"model\":\n            return model_response\n\n    def log_request(self, request: Request):\n        \"\"\"Log the request to the API\n\n        Parameters\n        ----------\n        request : Request\n            The request to log\n\n        Returns\n        -------\n        None\n        \"\"\"\n        logging.info(\n            f\"Request: {request.method} {request.url} - {request.headers} - {request.read().decode()}\"\n        )\n\n    def log_response(self, response: Response):\n        \"\"\"Log the response from the API.\n\n        Parameters\n        ----------\n        response : Response\n            The response from the API\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if not response.is_error:\n            logging.info(f\"Response: {response.status_code} - {response.text}\")\n        else:\n            logging.error(f\"Response: {response.status_code} - {response.text}\")\n\n    def _prep_get(\n        self,\n        path: str,\n        params: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Method to prepare the GET request inputs for the HTTPX client.\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        params : Type[BaseModel] | None\n            The parameters to add to the request route\n        **kwargs\n            Additional keyword arguments to pass to the HTTPX client\n\n        Returns\n        -------\n        dict\n            The prepared inputs for the HTTPX client\n        \"\"\"\n        self.__check_client()\n        path = self.__process_path(path)\n        url = f\"{self.domain}/{path}\"\n        headers = self.__create_headers(kwargs.pop(\"headers\", {}))\n        params = (\n            self.__replace_null_with_none(\n                data=params.model_dump(mode=\"json\", exclude_none=True, by_alias=True)\n            )\n            if params is not None\n            else None\n        )\n        return {\n            \"url\": url,\n            \"params\": params,\n            \"headers\": headers,\n            **kwargs,\n        }\n\n    def _prep_post(\n        self,\n        path: str,\n        body: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Method to prepare the POST request inputs for the HTTPX client.\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        body : Type[BaseModel] | None\n            The body to send in the request\n        **kwargs\n            Additional keyword arguments to pass to the HTTPX client\n\n        Returns\n        -------\n        dict\n            The prepared inputs for the HTTPX client\n        \"\"\"\n        self.__check_client()\n        path = self.__process_path(path)\n        url = f\"{self.domain}/{path}\"\n        headers = self.__create_headers(kwargs.pop(\"headers\", {}))\n        json = (\n            self.__replace_null_with_none(\n                data=body.model_dump(mode=\"json\", exclude_none=True, by_alias=True)\n            )\n            if body is not None\n            else None\n        )\n        return {\n            \"url\": url,\n            \"json\": json,\n            \"headers\": headers,\n            **kwargs,\n        }\n\n    def _prep_patch(\n        self,\n        path: str,\n        body: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Method to prepare the PATCH request inputs for the HTTPX client.\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        body : Type[BaseModel] | None\n            The body to send in the request\n        **kwargs\n            Additional keyword arguments to pass to the HTTPX client\n\n        Returns\n        -------\n        dict\n            The prepared inputs for the HTTPX client\n        \"\"\"\n        self.__check_client()\n        path = self.__process_path(path)\n        url = f\"{self.domain}/{path}\"\n        headers = self.__create_headers(kwargs.pop(\"headers\", {}))\n        json = (\n            self.__replace_null_with_none(\n                data=body.model_dump(mode=\"json\", exclude_none=True, by_alias=True)\n            )\n            if body is not None\n            else None\n        )\n        return {\n            \"url\": url,\n            \"json\": json,\n            \"headers\": headers,\n            **kwargs,\n        }\n\n    def _prep_delete(\n        self,\n        path: str,\n        params: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Method to prepare the DELETE request inputs for the HTTPX client.\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        params : Type[BaseModel] | None\n            The parameters to add to the request route\n        **kwargs\n            Additional keyword arguments to pass to the HTTPX client\n\n        Returns\n        -------\n        dict\n            The prepared inputs for the HTTPX client\n        \"\"\"\n        self.__check_client()\n        path = self.__process_path(path)\n        url = f\"{self.domain}/{path}\"\n        headers = self.__create_headers(kwargs.pop(\"headers\", {}))\n        params = (\n            self.__replace_null_with_none(\n                data=params.model_dump(mode=\"json\", exclude_none=True, by_alias=True)\n            )\n            if params is not None\n            else None\n        )\n        return {\n            \"url\": url,\n            \"params\": params,\n            \"headers\": headers,\n            **kwargs,\n        }\n\n    def _prep_put(\n        self,\n        path: str,\n        body: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Method to prepare the PUT request inputs for the HTTPX client.\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        body : Type[BaseModel] | None\n            The body to send in the request\n        **kwargs\n            Additional keyword arguments to pass to the HTTPX client\n\n        Returns\n        -------\n        dict\n            The prepared inputs for the HTTPX client\n        \"\"\"\n        self.__check_client()\n        path = self.__process_path(path)\n        url = f\"{self.domain}/{path}\"\n        headers = self.__create_headers(kwargs.pop(\"headers\", {}))\n        json = (\n            self.__replace_null_with_none(\n                data=body.model_dump(mode=\"json\", exclude_none=True, by_alias=True)\n            )\n            if body is not None\n            else None\n        )\n        return {\n            \"url\": url,\n            \"json\": json,\n            \"headers\": headers,\n            **kwargs,\n        }\n\n    def load_endpoints(self):\n        \"\"\"Loads all the endpoints from the api directory\"\"\"\n        raise NotImplementedError(\"load_endpoints method must be implemented\")\n\n    @property\n    def required_headers(self) -&gt; dict[str, str]:\n        \"\"\"The headers to be attached to each request\n\n        Returns\n        -------\n        dict[str, str]\n            The headers to be attached to each request\n        \"\"\"\n        return {\n            \"Accept\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.credentials.tokens.access_token.get_secret_value()}\",\n        }\n\n    def __create_headers(self, headers: dict[str, str] = {}) -&gt; dict[str, str]:\n        \"\"\"Create the headers for the request by adding the required headers\n\n        Parameters\n        ----------\n        headers : dict[str, str]\n            The headers for the request\n\n        Returns\n        -------\n        dict[str, str]\n            The headers for the request\n        \"\"\"\n        headers.update(self.required_headers)\n        return headers\n\n    def __check_client(self):\n        \"\"\"Check if the client is open and that the credentials are still valid.\n\n        Raises\n        ------\n        ValueError\n            If the client is not open or if the long-term credentials have expired\n        \"\"\"\n        if self.client is None:\n            raise RuntimeError(\n                \"Client is not open. Use .open() or the contextmanager to open the client.\"\n            )\n\n        if self.credentials.credentials_expired:\n            raise ValueError(\n                \"Long-term credentials have expired. \"\n                \"\\n\\nPlease reauthenticate using the `pyrevolut auth-manual` command.\"\n            )\n\n        if self.credentials.access_token_expired:\n            self.refresh_access_token()\n\n    def __process_path(self, path: str) -&gt; str:\n        \"\"\"Process the path.\n\n        If 'http' not in the path:\n            Removing the leading slash if it exists\n        Else:\n            Return the path as is\n\n        Parameters\n        ----------\n        path : str\n            The path to process\n\n        Returns\n        -------\n        str\n            The processed path\n        \"\"\"\n        if \"http\" in path:\n            return path\n\n        return self.__remove_leading_slash(path=path)\n\n    def __remove_leading_slash(self, path: str) -&gt; str:\n        \"\"\"Remove the leading slash from a path if it exists and\n        return it without the leading slash\n\n        Parameters\n        ----------\n        path : str\n            The path to remove the leading slash from\n\n        Returns\n        -------\n        str\n            The path without the leading slash\n        \"\"\"\n        if path.startswith(\"/\"):\n            return path[1:]\n        return path\n\n    def __replace_null_with_none(self, data: D) -&gt; D:\n        \"\"\"\n        Method that replaces all 'null' strings with None in a provided dictionary or list.\n\n        Must be called with either a dictionary or a list, not both.\n\n        Parameters\n        ----------\n        data : dict | list\n            The dictionary or list to replace 'null' strings with None\n\n        Returns\n        -------\n        dict | list\n            The dictionary or list with 'null' strings replaced with None\n        \"\"\"\n        if isinstance(data, dict):\n            for k, v in data.items():\n                if isinstance(v, dict):\n                    self.__replace_null_with_none(data=v)\n                elif isinstance(v, list):\n                    self.__replace_null_with_none(data=v)\n                elif v == \"null\":\n                    data[k] = None\n        elif isinstance(data, list):\n            for i in range(len(data)):\n                if isinstance(data[i], dict):\n                    self.__replace_null_with_none(data=data[i])\n                elif isinstance(data[i], list):\n                    self.__replace_null_with_none(data=data[i])\n                elif data[i] == \"null\":\n                    data[i] = None\n        else:\n            raise ValueError(\"Data must be either a dictionary or a list\")\n\n        return data\n\n    def load_credentials(self):\n        \"\"\"Load the credentials from the credentials inputs.\n\n        - If credentials are provided:\n            - If the credentials are a string, decode it and load the credentials.\n            - If the credentials are a dictionary, load the credentials.\n        - If credentials are not provided:\n            - If the custom load function is provided, use it.\n            - Otherwise load the credentials from the credentials file using the default loader / location. Expects a .json file.\n\n        \"\"\"\n        solution_msg = (\n            \"\\n\\nPlease reauthenticate using the `pyrevolut auth-manual` command.\"\n        )\n\n        # Load the credentials\n        if self.creds is not None:\n            if isinstance(self.creds, str):\n                _creds = json.loads(base64.b64decode(self.creds).decode(\"utf-8\"))\n            else:\n                _creds = self.creds\n            try:\n                self.credentials = ModelCreds(**_creds)\n            except Exception as exc:\n                raise ValueError(\n                    f\"Error loading credentials: {exc}. {solution_msg}\"\n                ) from exc\n        else:\n            if self.custom_load_fn is not None:\n                self.credentials = self.custom_load_fn()\n            else:\n                try:\n                    self.credentials = load_creds_fn(location=self.creds_loc)\n                except FileNotFoundError as exc:\n                    raise ValueError(\n                        f\"Credentials file not found: {exc}. {solution_msg}\"\n                    ) from exc\n                except Exception as exc:\n                    raise ValueError(\n                        f\"Error loading credentials: {exc}. {solution_msg}\"\n                    ) from exc\n\n        # Check if the credentials are still valid\n        if self.credentials.credentials_expired:\n            raise ValueError(f\"Credentials are expired. {solution_msg}\")\n\n        # Check if the access token is expired\n        if self.credentials.access_token_expired:\n            self.refresh_access_token()\n\n    def save_credentials(self):\n        \"\"\"Save the credentials to the credentials file.\"\"\"\n        if self.custom_save_fn is not None:\n            self.custom_save_fn(self.credentials)\n        else:\n            save_creds_fn(creds=self.credentials, location=self.creds_loc, indent=4)\n\n    def refresh_access_token(self):\n        \"\"\"Refresh the access token using the refresh token.\n        Will call the endpoint to refresh the access token.\n        Then it will save the new access token to the credentials file.\n\n        Parameters\n        ----------\n        None\n\n        Raises\n        ------\n        ValueError\n            If there is an error refreshing the access token.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        try:\n            resp = refresh_access_token(\n                client=SyncClient(),\n                refresh_token=self.credentials.tokens.refresh_token.get_secret_value(),\n                client_assert_jwt=self.credentials.client_assert_jwt.jwt.get_secret_value(),\n                sandbox=self.sandbox,\n            )\n            self.credentials.tokens.access_token = resp.access_token.get_secret_value()\n            self.credentials.tokens.token_type = resp.token_type\n            self.credentials.tokens.access_token_expiration_dt = pendulum.now(\n                tz=\"UTC\"\n            ).add(seconds=resp.expires_in)\n\n            # Save the new credentials\n            self.save_credentials()\n        except Exception as exc:\n            raise ValueError(f\"Error refreshing access token: {exc}.\") from exc\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.required_headers","title":"<code>required_headers: dict[str, str]</code>  <code>property</code>","text":"<p>The headers to be attached to each request</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>The headers to be attached to each request</p>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.__check_client","title":"<code>__check_client()</code>","text":"<p>Check if the client is open and that the credentials are still valid.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the client is not open or if the long-term credentials have expired</p> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def __check_client(self):\n    \"\"\"Check if the client is open and that the credentials are still valid.\n\n    Raises\n    ------\n    ValueError\n        If the client is not open or if the long-term credentials have expired\n    \"\"\"\n    if self.client is None:\n        raise RuntimeError(\n            \"Client is not open. Use .open() or the contextmanager to open the client.\"\n        )\n\n    if self.credentials.credentials_expired:\n        raise ValueError(\n            \"Long-term credentials have expired. \"\n            \"\\n\\nPlease reauthenticate using the `pyrevolut auth-manual` command.\"\n        )\n\n    if self.credentials.access_token_expired:\n        self.refresh_access_token()\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.__create_headers","title":"<code>__create_headers(headers={})</code>","text":"<p>Create the headers for the request by adding the required headers</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>dict[str, str]</code> <p>The headers for the request</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>The headers for the request</p> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def __create_headers(self, headers: dict[str, str] = {}) -&gt; dict[str, str]:\n    \"\"\"Create the headers for the request by adding the required headers\n\n    Parameters\n    ----------\n    headers : dict[str, str]\n        The headers for the request\n\n    Returns\n    -------\n    dict[str, str]\n        The headers for the request\n    \"\"\"\n    headers.update(self.required_headers)\n    return headers\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.__init__","title":"<code>__init__(creds_loc='credentials/creds.json', creds=None, sandbox=True, return_type='dict', error_response='raise', custom_save_fn=None, custom_load_fn=None)</code>","text":"<p>Create a new Revolut client</p> <p>Parameters:</p> Name Type Description Default <code>creds_loc</code> <code>str</code> <p>The location of the credentials file, by default \"credentials/creds.json\". If the creds input is not provided, will load the credentials from this file.</p> <code>'credentials/creds.json'</code> <code>creds</code> <code>str | dict</code> <p>The credentials to use for the client, by default None. If not provided, will load the credentials from the creds_loc file. Can be a dictionary of the credentials or a base64 encoded string of the credentials json.</p> <code>None</code> <code>sandbox</code> <code>bool</code> <p>Whether to use the sandbox environment, by default True</p> <code>True</code> <code>return_type</code> <code>Literal['raw', 'dict', 'model']</code> <p>The return type for the API responses, by default \"dict\" If \"raw\":     The raw response will be returned If \"dict\":     The response will be the dictionary representation of the Pydantic model.     So it will have UUIDs, pendulum DateTimes, etc instead of the raw string values. If \"model\":     The response will be a Pydantic model containing all processed response data.</p> <code>'dict'</code> <code>error_response</code> <code>Literal['raw', 'raise', 'dict', 'model']</code> <p>How the client should handle error responses, by default \"raise\" If \"raw\":     The client will return the raw error response If \"raise\":     The client will raise a ValueError if the response is an error If \"dict\":     The client will return a dictionary representation of the error response If \"model\":     The client will return a Pydantic model of the error response</p> <code>'raise'</code> <code>custom_save_fn</code> <code>Callable[[ModelCreds], None]</code> <p>A custom function to save the credentials, by default None</p> <code>None</code> <code>custom_load_fn</code> <code>Callable[..., ModelCreds]</code> <p>A custom function to load the credentials, by default None</p> <code>None</code> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def __init__(\n    self,\n    creds_loc: str = \"credentials/creds.json\",\n    creds: str | dict | None = None,\n    sandbox: bool = True,\n    return_type: Literal[\"raw\", \"dict\", \"model\"] = \"dict\",\n    error_response: Literal[\"raw\", \"raise\", \"dict\", \"model\"] = \"raise\",\n    custom_save_fn: Callable[[ModelCreds], None] | None = None,\n    custom_load_fn: Callable[..., ModelCreds] | None = None,\n):\n    \"\"\"Create a new Revolut client\n\n    Parameters\n    ----------\n    creds_loc : str, optional\n        The location of the credentials file, by default \"credentials/creds.json\".\n        If the creds input is not provided, will load the credentials from this file.\n    creds : str | dict, optional\n        The credentials to use for the client, by default None. If not provided, will\n        load the credentials from the creds_loc file.\n        Can be a dictionary of the credentials or a base64 encoded string of the credentials json.\n    sandbox : bool, optional\n        Whether to use the sandbox environment, by default True\n    return_type : Literal[\"raw\", \"dict\", \"model\"], optional\n        The return type for the API responses, by default \"dict\"\n        If \"raw\":\n            The raw response will be returned\n        If \"dict\":\n            The response will be the dictionary representation of the Pydantic model.\n            So it will have UUIDs, pendulum DateTimes, etc instead of the raw string values.\n        If \"model\":\n            The response will be a Pydantic model containing all processed response data.\n    error_response : Literal[\"raw\", \"raise\", \"dict\", \"model\"], optional\n        How the client should handle error responses, by default \"raise\"\n        If \"raw\":\n            The client will return the raw error response\n        If \"raise\":\n            The client will raise a ValueError if the response is an error\n        If \"dict\":\n            The client will return a dictionary representation of the error response\n        If \"model\":\n            The client will return a Pydantic model of the error response\n    custom_save_fn : Callable[[ModelCreds], None], optional\n        A custom function to save the credentials, by default None\n    custom_load_fn : Callable[..., ModelCreds], optional\n        A custom function to load the credentials, by default None\n    \"\"\"\n    assert return_type in [\n        \"raw\",\n        \"dict\",\n        \"model\",\n    ], \"return_type must be 'raw', 'dict', or 'model'\"\n    assert error_response in [\n        \"raise\",\n        \"dict\",\n        \"model\",\n    ], \"error_response must be 'raise', 'dict', or 'model'\"\n    assert \".json\" in creds_loc, \"creds_loc must be a .json file\"\n\n    self.creds_loc = creds_loc\n    self.creds = creds\n    self.sandbox = sandbox\n    self.return_type = return_type\n    self.error_response = error_response\n    self.custom_save_fn = custom_save_fn\n    self.custom_load_fn = custom_load_fn\n\n    # Set domain based on environment\n    if self.sandbox:\n        self.domain = \"https://sandbox-b2b.revolut.com/api\"\n    else:\n        self.domain = \"https://b2b.revolut.com/api\"\n\n    # Load the credentials\n    self.load_credentials()\n\n    # Load the endpoints\n    self.load_endpoints()\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.__process_path","title":"<code>__process_path(path)</code>","text":"<p>Process the path.</p> <p>If 'http' not in the path:     Removing the leading slash if it exists Else:     Return the path as is</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to process</p> required <p>Returns:</p> Type Description <code>str</code> <p>The processed path</p> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def __process_path(self, path: str) -&gt; str:\n    \"\"\"Process the path.\n\n    If 'http' not in the path:\n        Removing the leading slash if it exists\n    Else:\n        Return the path as is\n\n    Parameters\n    ----------\n    path : str\n        The path to process\n\n    Returns\n    -------\n    str\n        The processed path\n    \"\"\"\n    if \"http\" in path:\n        return path\n\n    return self.__remove_leading_slash(path=path)\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.__remove_leading_slash","title":"<code>__remove_leading_slash(path)</code>","text":"<p>Remove the leading slash from a path if it exists and return it without the leading slash</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to remove the leading slash from</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path without the leading slash</p> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def __remove_leading_slash(self, path: str) -&gt; str:\n    \"\"\"Remove the leading slash from a path if it exists and\n    return it without the leading slash\n\n    Parameters\n    ----------\n    path : str\n        The path to remove the leading slash from\n\n    Returns\n    -------\n    str\n        The path without the leading slash\n    \"\"\"\n    if path.startswith(\"/\"):\n        return path[1:]\n    return path\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.__replace_null_with_none","title":"<code>__replace_null_with_none(data)</code>","text":"<p>Method that replaces all 'null' strings with None in a provided dictionary or list.</p> <p>Must be called with either a dictionary or a list, not both.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>The dictionary or list to replace 'null' strings with None</p> required <p>Returns:</p> Type Description <code>dict | list</code> <p>The dictionary or list with 'null' strings replaced with None</p> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def __replace_null_with_none(self, data: D) -&gt; D:\n    \"\"\"\n    Method that replaces all 'null' strings with None in a provided dictionary or list.\n\n    Must be called with either a dictionary or a list, not both.\n\n    Parameters\n    ----------\n    data : dict | list\n        The dictionary or list to replace 'null' strings with None\n\n    Returns\n    -------\n    dict | list\n        The dictionary or list with 'null' strings replaced with None\n    \"\"\"\n    if isinstance(data, dict):\n        for k, v in data.items():\n            if isinstance(v, dict):\n                self.__replace_null_with_none(data=v)\n            elif isinstance(v, list):\n                self.__replace_null_with_none(data=v)\n            elif v == \"null\":\n                data[k] = None\n    elif isinstance(data, list):\n        for i in range(len(data)):\n            if isinstance(data[i], dict):\n                self.__replace_null_with_none(data=data[i])\n            elif isinstance(data[i], list):\n                self.__replace_null_with_none(data=data[i])\n            elif data[i] == \"null\":\n                data[i] = None\n    else:\n        raise ValueError(\"Data must be either a dictionary or a list\")\n\n    return data\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.load_credentials","title":"<code>load_credentials()</code>","text":"<p>Load the credentials from the credentials inputs.</p> <ul> <li>If credentials are provided:<ul> <li>If the credentials are a string, decode it and load the credentials.</li> <li>If the credentials are a dictionary, load the credentials.</li> </ul> </li> <li>If credentials are not provided:<ul> <li>If the custom load function is provided, use it.</li> <li>Otherwise load the credentials from the credentials file using the default loader / location. Expects a .json file.</li> </ul> </li> </ul> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def load_credentials(self):\n    \"\"\"Load the credentials from the credentials inputs.\n\n    - If credentials are provided:\n        - If the credentials are a string, decode it and load the credentials.\n        - If the credentials are a dictionary, load the credentials.\n    - If credentials are not provided:\n        - If the custom load function is provided, use it.\n        - Otherwise load the credentials from the credentials file using the default loader / location. Expects a .json file.\n\n    \"\"\"\n    solution_msg = (\n        \"\\n\\nPlease reauthenticate using the `pyrevolut auth-manual` command.\"\n    )\n\n    # Load the credentials\n    if self.creds is not None:\n        if isinstance(self.creds, str):\n            _creds = json.loads(base64.b64decode(self.creds).decode(\"utf-8\"))\n        else:\n            _creds = self.creds\n        try:\n            self.credentials = ModelCreds(**_creds)\n        except Exception as exc:\n            raise ValueError(\n                f\"Error loading credentials: {exc}. {solution_msg}\"\n            ) from exc\n    else:\n        if self.custom_load_fn is not None:\n            self.credentials = self.custom_load_fn()\n        else:\n            try:\n                self.credentials = load_creds_fn(location=self.creds_loc)\n            except FileNotFoundError as exc:\n                raise ValueError(\n                    f\"Credentials file not found: {exc}. {solution_msg}\"\n                ) from exc\n            except Exception as exc:\n                raise ValueError(\n                    f\"Error loading credentials: {exc}. {solution_msg}\"\n                ) from exc\n\n    # Check if the credentials are still valid\n    if self.credentials.credentials_expired:\n        raise ValueError(f\"Credentials are expired. {solution_msg}\")\n\n    # Check if the access token is expired\n    if self.credentials.access_token_expired:\n        self.refresh_access_token()\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.load_endpoints","title":"<code>load_endpoints()</code>","text":"<p>Loads all the endpoints from the api directory</p> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def load_endpoints(self):\n    \"\"\"Loads all the endpoints from the api directory\"\"\"\n    raise NotImplementedError(\"load_endpoints method must be implemented\")\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.log_request","title":"<code>log_request(request)</code>","text":"<p>Log the request to the API</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The request to log</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def log_request(self, request: Request):\n    \"\"\"Log the request to the API\n\n    Parameters\n    ----------\n    request : Request\n        The request to log\n\n    Returns\n    -------\n    None\n    \"\"\"\n    logging.info(\n        f\"Request: {request.method} {request.url} - {request.headers} - {request.read().decode()}\"\n    )\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.log_response","title":"<code>log_response(response)</code>","text":"<p>Log the response from the API.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The response from the API</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def log_response(self, response: Response):\n    \"\"\"Log the response from the API.\n\n    Parameters\n    ----------\n    response : Response\n        The response from the API\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if not response.is_error:\n        logging.info(f\"Response: {response.status_code} - {response.text}\")\n    else:\n        logging.error(f\"Response: {response.status_code} - {response.text}\")\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.process_response","title":"<code>process_response(response, response_model, return_type=None, error_response='raise')</code>","text":"<p>Processes the response and returns the desired format. Will additionally log the request and response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The HTTPX response to process</p> required <code>response_model</code> <code>BM</code> <p>The Pydantic model to use for the response</p> required <code>return_type</code> <code>Literal['raw', 'dict', 'model'] | None</code> <p>The return type for the API responses, by default None. If \"raw\":     The raw response will be returned If \"dict\":     The response will be the dictionary representation of the Pydantic model.     So it will have UUIDs, pendulum DateTimes, etc instead of the raw string values. If \"model\":     The response will be a Pydantic model containing all processed response data. If None:     The default return type of the client will be used.</p> <code>None</code> <code>error_response</code> <code>Literal['raw', 'raise', 'dict', 'model'] | None</code> <p>How the client should handle error responses, by default None. If \"raw\":     The client will return the raw error response If \"raise\":     The client will raise a ValueError if the response is an error If \"dict\":     The client will return a dictionary representation of the error response If \"model\":     The client will return a Pydantic model of the error response If None:     The default error response type of the client will be used.</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>BM | dict | list[BM] | list[dict]</code> <p>The response in the desired format</p> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def process_response(\n    self,\n    response: Response,\n    response_model: BM,\n    return_type: Literal[\"raw\", \"dict\", \"model\"] | None = None,\n    error_response: Literal[\"raw\", \"raise\", \"dict\", \"model\"] | None = \"raise\",\n):\n    \"\"\"Processes the response and returns the desired format.\n    Will additionally log the request and response.\n\n    Parameters\n    ----------\n    response : Response\n        The HTTPX response to process\n    response_model : BM\n        The Pydantic model to use for the response\n    return_type : Literal[\"raw\", \"dict\", \"model\"] | None, optional\n        The return type for the API responses, by default None.\n        If \"raw\":\n            The raw response will be returned\n        If \"dict\":\n            The response will be the dictionary representation of the Pydantic model.\n            So it will have UUIDs, pendulum DateTimes, etc instead of the raw string values.\n        If \"model\":\n            The response will be a Pydantic model containing all processed response data.\n        If None:\n            The default return type of the client will be used.\n    error_response : Literal[\"raw\", \"raise\", \"dict\", \"model\"] | None, optional\n        How the client should handle error responses, by default None.\n        If \"raw\":\n            The client will return the raw error response\n        If \"raise\":\n            The client will raise a ValueError if the response is an error\n        If \"dict\":\n            The client will return a dictionary representation of the error response\n        If \"model\":\n            The client will return a Pydantic model of the error response\n        If None:\n            The default error response type of the client will be used.\n\n    Returns\n    -------\n    BM | dict | list[BM] | list[dict]\n        The response in the desired format\n    \"\"\"\n    if return_type is None:\n        return_type = self.return_type\n    if error_response is None:\n        error_response = self.error_response\n\n    # Log the request\n    self.log_request(request=response.request)\n\n    # Log the response\n    self.log_response(response=response)\n\n    # Check for error response\n    if response.is_error:\n        if error_response == \"raise\":\n            try:\n                response.raise_for_status()\n            except TimeoutException as exc:\n                raise PyRevolutTimeoutError() from exc\n            except NetworkError as exc:\n                raise PyRevolutNetworkError() from exc\n            except HTTPError as exc:\n                if response.status_code == 400:\n                    raise PyRevolutBadRequest() from exc\n                elif response.status_code == 401:\n                    raise PyRevolutUnauthorized() from exc\n                elif response.status_code == 403:\n                    raise PyRevolutForbidden() from exc\n                elif response.status_code == 404:\n                    raise PyRevolutNotFound() from exc\n                elif response.status_code == 405:\n                    raise PyRevolutMethodNotAllowed() from exc\n                elif response.status_code == 406:\n                    raise PyRevolutNotAcceptable() from exc\n                elif response.status_code == 409:\n                    raise PyRevolutConflict() from exc\n                elif response.status_code == 429:\n                    raise PyRevolutTooManyRequests() from exc\n                elif response.status_code == 500:\n                    raise PyRevolutInternalServerError() from exc\n                elif response.status_code == 503:\n                    raise PyRevolutServerUnavailable() from exc\n                raise PyRevolutBaseException() from exc\n        elif error_response == \"raw\":\n            return response.json()\n        elif error_response == \"dict\":\n            return ModelError(**response.json()).model_dump()\n        elif error_response == \"model\":\n            return ModelError(**response.json())\n        else:\n            raise ValueError(f\"Invalid error response type: {error_response}\")\n\n    # Raw response\n    try:\n        raw_response = response.json()\n    except json.JSONDecodeError:\n        raw_response = {}\n    if return_type == \"raw\":\n        return raw_response\n\n    # Dict response\n    if isinstance(raw_response, list):\n        model_response = [response_model(**resp) for resp in raw_response]\n    else:\n        model_response = response_model(**raw_response)\n    if return_type == \"dict\":\n        if isinstance(model_response, list):\n            return [resp.model_dump() for resp in model_response]\n        return model_response.model_dump()\n\n    # Model response\n    if return_type == \"model\":\n        return model_response\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.refresh_access_token","title":"<code>refresh_access_token()</code>","text":"<p>Refresh the access token using the refresh token. Will call the endpoint to refresh the access token. Then it will save the new access token to the credentials file.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is an error refreshing the access token.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def refresh_access_token(self):\n    \"\"\"Refresh the access token using the refresh token.\n    Will call the endpoint to refresh the access token.\n    Then it will save the new access token to the credentials file.\n\n    Parameters\n    ----------\n    None\n\n    Raises\n    ------\n    ValueError\n        If there is an error refreshing the access token.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    try:\n        resp = refresh_access_token(\n            client=SyncClient(),\n            refresh_token=self.credentials.tokens.refresh_token.get_secret_value(),\n            client_assert_jwt=self.credentials.client_assert_jwt.jwt.get_secret_value(),\n            sandbox=self.sandbox,\n        )\n        self.credentials.tokens.access_token = resp.access_token.get_secret_value()\n        self.credentials.tokens.token_type = resp.token_type\n        self.credentials.tokens.access_token_expiration_dt = pendulum.now(\n            tz=\"UTC\"\n        ).add(seconds=resp.expires_in)\n\n        # Save the new credentials\n        self.save_credentials()\n    except Exception as exc:\n        raise ValueError(f\"Error refreshing access token: {exc}.\") from exc\n</code></pre>"},{"location":"code_reference/http_client/base/#pyrevolut.client.base.BaseClient.save_credentials","title":"<code>save_credentials()</code>","text":"<p>Save the credentials to the credentials file.</p> Source code in <code>pyrevolut/client/base.py</code> <pre><code>def save_credentials(self):\n    \"\"\"Save the credentials to the credentials file.\"\"\"\n    if self.custom_save_fn is not None:\n        self.custom_save_fn(self.credentials)\n    else:\n        save_creds_fn(creds=self.credentials, location=self.creds_loc, indent=4)\n</code></pre>"},{"location":"code_reference/http_client/synchronous/","title":"PyRevolut Synchronous Client","text":"<p>PyRevolut provides a synchronous client that can be used to interact with the Revolut Business API.</p> <p>Example initialization of the client object:</p> <pre><code>from pyrevolut.client import Client\n\nCREDS_JSON_LOC = \"path/to/creds.json\"\n\nclient = Client(\n    creds_loc=CREDS_JSON_LOC,\n    sandbox=True,\n)\n\nwith client:\n    accounts = client.Accounts.get_all_accounts()\n    print(accounts)\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client","title":"<code>Client</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>The synchronous client for the Revolut API</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>class Client(BaseClient):\n    \"\"\"The synchronous client for the Revolut API\"\"\"\n\n    Accounts: EndpointAccountsSync\n    Cards: EndpointCardsSync\n    Counterparties: EndpointCounterpartiesSync\n    ForeignExchange: EndpointForeignExchangeSync\n    PaymentDrafts: EndpointPaymentDraftsSync\n    PayoutLinks: EndpointPayoutLinksSync\n    Simulations: EndpointSimulationsSync\n    TeamMembers: EndpointTeamMembersSync\n    Transactions: EndpointTransactionsSync\n    Transfers: EndpointTransfersSync\n    Webhooks: EndpointWebhooksSync\n\n    def open(self):\n        \"\"\"Opens the client connection\"\"\"\n        if self.client is not None:\n            return\n\n        self.client = HTTPClient()\n\n    def close(self):\n        \"\"\"Closes the client connection\"\"\"\n        if self.client is None:\n            return\n\n        self.client.close()\n        self.client = None\n\n    def get(\n        self,\n        path: str,\n        response_model: Type[BaseModel],\n        params: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Send a GET request to the Revolut API\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        response_model : Type[BaseModel]\n            The model to use for the response\n        params : Type[BaseModel] | None\n            The parameters to add to the request route\n\n        Returns\n        -------\n        Response\n            The response from the request\n        \"\"\"\n        resp = self.client.get(\n            **self._prep_get(\n                path=path,\n                params=params,\n                **kwargs,\n            )\n        )\n        return self.process_response(\n            response=resp,\n            response_model=response_model,\n            return_type=None,\n            error_response=None,\n        )\n\n    def post(\n        self,\n        path: str,\n        response_model: Type[BaseModel],\n        body: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Send a POST request to the Revolut API\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        response_model : Type[BaseModel]\n            The model to use for the response\n        body : Type[BaseModel] | None\n            The body to send in the request\n\n        Returns\n        -------\n        Response\n            The response from the request\n        \"\"\"\n        resp = self.client.post(\n            **self._prep_post(\n                path=path,\n                body=body,\n                **kwargs,\n            )\n        )\n        return self.process_response(\n            response=resp,\n            response_model=response_model,\n            return_type=None,\n            error_response=None,\n        )\n\n    def patch(\n        self,\n        path: str,\n        response_model: Type[BaseModel],\n        body: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Send a PATCH request to the Revolut API\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        response_model : Type[BaseModel]\n            The model to use for the response\n        body : Type[BaseModel]\n            The body to send in the request\n\n        Returns\n        -------\n        Response\n            The response from the request\n        \"\"\"\n        resp = self.client.patch(\n            **self._prep_patch(\n                path=path,\n                body=body,\n                **kwargs,\n            )\n        )\n        return self.process_response(\n            response=resp,\n            response_model=response_model,\n            return_type=None,\n            error_response=None,\n        )\n\n    def delete(\n        self,\n        path: str,\n        response_model: Type[BaseModel],\n        params: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Send a DELETE request to the Revolut API\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        response_model : Type[BaseModel]\n            The model to use for the response\n        params : Type[BaseModel] | None\n            The parameters to add to the request route\n\n        Returns\n        -------\n        Response\n            The response from the request\n        \"\"\"\n        resp = self.client.delete(\n            **self._prep_delete(\n                path=path,\n                params=params,\n                **kwargs,\n            )\n        )\n        return self.process_response(\n            response=resp,\n            response_model=response_model,\n            return_type=None,\n            error_response=None,\n        )\n\n    def put(\n        self,\n        response_model: Type[BaseModel],\n        path: str,\n        body: Type[BaseModel] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Send a PUT request to the Revolut API\n\n        Parameters\n        ----------\n        path : str\n            The path to send the request to\n        response_model : Type[BaseModel]\n            The model to use for the response\n        body : Type[BaseModel] | None\n            The body to send in the request\n\n        Returns\n        -------\n        Response\n            The response from the request\n        \"\"\"\n        resp = self.client.put(\n            **self._prep_put(\n                path=path,\n                body=body,\n                **kwargs,\n            )\n        )\n        return self.process_response(\n            response=resp,\n            response_model=response_model,\n            return_type=None,\n            error_response=None,\n        )\n\n    def load_endpoints(self):\n        \"\"\"Loads all the endpoints from the api directory\"\"\"\n        self.Accounts = EndpointAccountsSync(client=self)\n        self.Cards = EndpointCardsSync(client=self)\n        self.Counterparties = EndpointCounterpartiesSync(client=self)\n        self.ForeignExchange = EndpointForeignExchangeSync(client=self)\n        self.PaymentDrafts = EndpointPaymentDraftsSync(client=self)\n        self.PayoutLinks = EndpointPayoutLinksSync(client=self)\n        self.Simulations = EndpointSimulationsSync(client=self)\n        self.TeamMembers = EndpointTeamMembersSync(client=self)\n        self.Transactions = EndpointTransactionsSync(client=self)\n        self.Transfers = EndpointTransfersSync(client=self)\n        self.Webhooks = EndpointWebhooksSync(client=self)\n\n    def __enter__(self):\n        \"\"\"Open the client connection\"\"\"\n        self.open()\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        \"\"\"Close the client connection\"\"\"\n        self.close()\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client.__enter__","title":"<code>__enter__()</code>","text":"<p>Open the client connection</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>def __enter__(self):\n    \"\"\"Open the client connection\"\"\"\n    self.open()\n    return self\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client.__exit__","title":"<code>__exit__(*args, **kwargs)</code>","text":"<p>Close the client connection</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>def __exit__(self, *args, **kwargs):\n    \"\"\"Close the client connection\"\"\"\n    self.close()\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client.close","title":"<code>close()</code>","text":"<p>Closes the client connection</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>def close(self):\n    \"\"\"Closes the client connection\"\"\"\n    if self.client is None:\n        return\n\n    self.client.close()\n    self.client = None\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client.delete","title":"<code>delete(path, response_model, params=None, **kwargs)</code>","text":"<p>Send a DELETE request to the Revolut API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to send the request to</p> required <code>response_model</code> <code>Type[BaseModel]</code> <p>The model to use for the response</p> required <code>params</code> <code>Type[BaseModel] | None</code> <p>The parameters to add to the request route</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from the request</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>def delete(\n    self,\n    path: str,\n    response_model: Type[BaseModel],\n    params: Type[BaseModel] | None = None,\n    **kwargs,\n):\n    \"\"\"Send a DELETE request to the Revolut API\n\n    Parameters\n    ----------\n    path : str\n        The path to send the request to\n    response_model : Type[BaseModel]\n        The model to use for the response\n    params : Type[BaseModel] | None\n        The parameters to add to the request route\n\n    Returns\n    -------\n    Response\n        The response from the request\n    \"\"\"\n    resp = self.client.delete(\n        **self._prep_delete(\n            path=path,\n            params=params,\n            **kwargs,\n        )\n    )\n    return self.process_response(\n        response=resp,\n        response_model=response_model,\n        return_type=None,\n        error_response=None,\n    )\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client.get","title":"<code>get(path, response_model, params=None, **kwargs)</code>","text":"<p>Send a GET request to the Revolut API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to send the request to</p> required <code>response_model</code> <code>Type[BaseModel]</code> <p>The model to use for the response</p> required <code>params</code> <code>Type[BaseModel] | None</code> <p>The parameters to add to the request route</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from the request</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>def get(\n    self,\n    path: str,\n    response_model: Type[BaseModel],\n    params: Type[BaseModel] | None = None,\n    **kwargs,\n):\n    \"\"\"Send a GET request to the Revolut API\n\n    Parameters\n    ----------\n    path : str\n        The path to send the request to\n    response_model : Type[BaseModel]\n        The model to use for the response\n    params : Type[BaseModel] | None\n        The parameters to add to the request route\n\n    Returns\n    -------\n    Response\n        The response from the request\n    \"\"\"\n    resp = self.client.get(\n        **self._prep_get(\n            path=path,\n            params=params,\n            **kwargs,\n        )\n    )\n    return self.process_response(\n        response=resp,\n        response_model=response_model,\n        return_type=None,\n        error_response=None,\n    )\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client.load_endpoints","title":"<code>load_endpoints()</code>","text":"<p>Loads all the endpoints from the api directory</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>def load_endpoints(self):\n    \"\"\"Loads all the endpoints from the api directory\"\"\"\n    self.Accounts = EndpointAccountsSync(client=self)\n    self.Cards = EndpointCardsSync(client=self)\n    self.Counterparties = EndpointCounterpartiesSync(client=self)\n    self.ForeignExchange = EndpointForeignExchangeSync(client=self)\n    self.PaymentDrafts = EndpointPaymentDraftsSync(client=self)\n    self.PayoutLinks = EndpointPayoutLinksSync(client=self)\n    self.Simulations = EndpointSimulationsSync(client=self)\n    self.TeamMembers = EndpointTeamMembersSync(client=self)\n    self.Transactions = EndpointTransactionsSync(client=self)\n    self.Transfers = EndpointTransfersSync(client=self)\n    self.Webhooks = EndpointWebhooksSync(client=self)\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client.open","title":"<code>open()</code>","text":"<p>Opens the client connection</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>def open(self):\n    \"\"\"Opens the client connection\"\"\"\n    if self.client is not None:\n        return\n\n    self.client = HTTPClient()\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client.patch","title":"<code>patch(path, response_model, body=None, **kwargs)</code>","text":"<p>Send a PATCH request to the Revolut API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to send the request to</p> required <code>response_model</code> <code>Type[BaseModel]</code> <p>The model to use for the response</p> required <code>body</code> <code>Type[BaseModel]</code> <p>The body to send in the request</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from the request</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>def patch(\n    self,\n    path: str,\n    response_model: Type[BaseModel],\n    body: Type[BaseModel] | None = None,\n    **kwargs,\n):\n    \"\"\"Send a PATCH request to the Revolut API\n\n    Parameters\n    ----------\n    path : str\n        The path to send the request to\n    response_model : Type[BaseModel]\n        The model to use for the response\n    body : Type[BaseModel]\n        The body to send in the request\n\n    Returns\n    -------\n    Response\n        The response from the request\n    \"\"\"\n    resp = self.client.patch(\n        **self._prep_patch(\n            path=path,\n            body=body,\n            **kwargs,\n        )\n    )\n    return self.process_response(\n        response=resp,\n        response_model=response_model,\n        return_type=None,\n        error_response=None,\n    )\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client.post","title":"<code>post(path, response_model, body=None, **kwargs)</code>","text":"<p>Send a POST request to the Revolut API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to send the request to</p> required <code>response_model</code> <code>Type[BaseModel]</code> <p>The model to use for the response</p> required <code>body</code> <code>Type[BaseModel] | None</code> <p>The body to send in the request</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from the request</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>def post(\n    self,\n    path: str,\n    response_model: Type[BaseModel],\n    body: Type[BaseModel] | None = None,\n    **kwargs,\n):\n    \"\"\"Send a POST request to the Revolut API\n\n    Parameters\n    ----------\n    path : str\n        The path to send the request to\n    response_model : Type[BaseModel]\n        The model to use for the response\n    body : Type[BaseModel] | None\n        The body to send in the request\n\n    Returns\n    -------\n    Response\n        The response from the request\n    \"\"\"\n    resp = self.client.post(\n        **self._prep_post(\n            path=path,\n            body=body,\n            **kwargs,\n        )\n    )\n    return self.process_response(\n        response=resp,\n        response_model=response_model,\n        return_type=None,\n        error_response=None,\n    )\n</code></pre>"},{"location":"code_reference/http_client/synchronous/#pyrevolut.client.synchronous.Client.put","title":"<code>put(response_model, path, body=None, **kwargs)</code>","text":"<p>Send a PUT request to the Revolut API</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to send the request to</p> required <code>response_model</code> <code>Type[BaseModel]</code> <p>The model to use for the response</p> required <code>body</code> <code>Type[BaseModel] | None</code> <p>The body to send in the request</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from the request</p> Source code in <code>pyrevolut/client/synchronous.py</code> <pre><code>def put(\n    self,\n    response_model: Type[BaseModel],\n    path: str,\n    body: Type[BaseModel] | None = None,\n    **kwargs,\n):\n    \"\"\"Send a PUT request to the Revolut API\n\n    Parameters\n    ----------\n    path : str\n        The path to send the request to\n    response_model : Type[BaseModel]\n        The model to use for the response\n    body : Type[BaseModel] | None\n        The body to send in the request\n\n    Returns\n    -------\n    Response\n        The response from the request\n    \"\"\"\n    resp = self.client.put(\n        **self._prep_put(\n            path=path,\n            body=body,\n            **kwargs,\n        )\n    )\n    return self.process_response(\n        response=resp,\n        response_model=response_model,\n        return_type=None,\n        error_response=None,\n    )\n</code></pre>"}]}